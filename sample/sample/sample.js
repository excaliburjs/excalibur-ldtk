(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/compare-versions/lib/esm/compare.js":
/*!**********************************************************!*\
  !*** ./node_modules/compare-versions/lib/esm/compare.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare)
/* harmony export */ });
/* harmony import */ var _compareVersions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compareVersions.js */ "./node_modules/compare-versions/lib/esm/compareVersions.js");

/**
 * Compare [semver](https://semver.org/) version strings using the specified operator.
 *
 * @param v1 First version to compare
 * @param v2 Second version to compare
 * @param operator Allowed arithmetic operator to use
 * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.
 *
 * @example
 * ```
 * compare('10.1.8', '10.0.4', '>'); // return true
 * compare('10.0.1', '10.0.1', '='); // return true
 * compare('10.1.1', '10.2.2', '<'); // return true
 * compare('10.1.1', '10.2.2', '<='); // return true
 * compare('10.1.1', '10.2.2', '>='); // return false
 * ```
 */
const compare = (v1, v2, operator) => {
    // validate input operator
    assertValidOperator(operator);
    // since result of compareVersions can only be -1 or 0 or 1
    // a simple map can be used to replace switch
    const res = (0,_compareVersions_js__WEBPACK_IMPORTED_MODULE_0__.compareVersions)(v1, v2);
    return operatorResMap[operator].includes(res);
};
const operatorResMap = {
    '>': [1],
    '>=': [0, 1],
    '=': [0],
    '<=': [-1, 0],
    '<': [-1],
    '!=': [-1, 1],
};
const allowedOperators = Object.keys(operatorResMap);
const assertValidOperator = (op) => {
    if (typeof op !== 'string') {
        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
    }
    if (allowedOperators.indexOf(op) === -1) {
        throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);
    }
};
//# sourceMappingURL=compare.js.map

/***/ }),

/***/ "./node_modules/compare-versions/lib/esm/compareVersions.js":
/*!******************************************************************!*\
  !*** ./node_modules/compare-versions/lib/esm/compareVersions.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareVersions: () => (/* binding */ compareVersions)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/compare-versions/lib/esm/utils.js");

/**
 * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.
 * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.
 * @param v1 - First version to compare
 * @param v2 - Second version to compare
 * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
 */
const compareVersions = (v1, v2) => {
    // validate input and split into segments
    const n1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateAndParse)(v1);
    const n2 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateAndParse)(v2);
    // pop off the patch
    const p1 = n1.pop();
    const p2 = n2.pop();
    // validate numbers
    const r = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.compareSegments)(n1, n2);
    if (r !== 0)
        return r;
    // validate pre-release
    if (p1 && p2) {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.compareSegments)(p1.split('.'), p2.split('.'));
    }
    else if (p1 || p2) {
        return p1 ? -1 : 1;
    }
    return 0;
};
//# sourceMappingURL=compareVersions.js.map

/***/ }),

/***/ "./node_modules/compare-versions/lib/esm/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/compare-versions/lib/esm/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareSegments: () => (/* binding */ compareSegments),
/* harmony export */   semver: () => (/* binding */ semver),
/* harmony export */   validateAndParse: () => (/* binding */ validateAndParse)
/* harmony export */ });
const semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
const validateAndParse = (version) => {
    if (typeof version !== 'string') {
        throw new TypeError('Invalid argument expected string');
    }
    const match = version.match(semver);
    if (!match) {
        throw new Error(`Invalid argument not valid semver ('${version}' received)`);
    }
    match.shift();
    return match;
};
const isWildcard = (s) => s === '*' || s === 'x' || s === 'X';
const tryParse = (v) => {
    const n = parseInt(v, 10);
    return isNaN(n) ? v : n;
};
const forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
const compareStrings = (a, b) => {
    if (isWildcard(a) || isWildcard(b))
        return 0;
    const [ap, bp] = forceType(tryParse(a), tryParse(b));
    if (ap > bp)
        return 1;
    if (ap < bp)
        return -1;
    return 0;
};
const compareSegments = (a, b) => {
    for (let i = 0; i < Math.max(a.length, b.length); i++) {
        const r = compareStrings(a[i] || '0', b[i] || '0');
        if (r !== 0)
            return r;
    }
    return 0;
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/excalibur/build/esm/excalibur.development.js":
/*!*******************************************************************!*\
  !*** ./node_modules/excalibur/build/esm/excalibur.development.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionCompleteEvent: () => (/* binding */ __webpack_exports__ActionCompleteEvent),
/* harmony export */   ActionContext: () => (/* binding */ __webpack_exports__ActionContext),
/* harmony export */   ActionQueue: () => (/* binding */ __webpack_exports__ActionQueue),
/* harmony export */   ActionSequence: () => (/* binding */ __webpack_exports__ActionSequence),
/* harmony export */   ActionStartEvent: () => (/* binding */ __webpack_exports__ActionStartEvent),
/* harmony export */   ActionsComponent: () => (/* binding */ __webpack_exports__ActionsComponent),
/* harmony export */   ActionsSystem: () => (/* binding */ __webpack_exports__ActionsSystem),
/* harmony export */   ActivateEvent: () => (/* binding */ __webpack_exports__ActivateEvent),
/* harmony export */   Actor: () => (/* binding */ __webpack_exports__Actor),
/* harmony export */   ActorEvents: () => (/* binding */ __webpack_exports__ActorEvents),
/* harmony export */   AddEvent: () => (/* binding */ __webpack_exports__AddEvent),
/* harmony export */   AddedComponent: () => (/* binding */ __webpack_exports__AddedComponent),
/* harmony export */   AffineMatrix: () => (/* binding */ __webpack_exports__AffineMatrix),
/* harmony export */   Animation: () => (/* binding */ __webpack_exports__Animation),
/* harmony export */   AnimationDirection: () => (/* binding */ __webpack_exports__AnimationDirection),
/* harmony export */   AnimationEvents: () => (/* binding */ __webpack_exports__AnimationEvents),
/* harmony export */   AnimationStrategy: () => (/* binding */ __webpack_exports__AnimationStrategy),
/* harmony export */   ArcadeSolver: () => (/* binding */ __webpack_exports__ArcadeSolver),
/* harmony export */   AudioContextFactory: () => (/* binding */ __webpack_exports__AudioContextFactory),
/* harmony export */   Axes: () => (/* binding */ __webpack_exports__Axes),
/* harmony export */   Axis: () => (/* binding */ __webpack_exports__Axis),
/* harmony export */   BaseAlign: () => (/* binding */ __webpack_exports__BaseAlign),
/* harmony export */   BezierCurve: () => (/* binding */ __webpack_exports__BezierCurve),
/* harmony export */   Blink: () => (/* binding */ __webpack_exports__Blink),
/* harmony export */   BodyComponent: () => (/* binding */ __webpack_exports__BodyComponent),
/* harmony export */   BoundingBox: () => (/* binding */ __webpack_exports__BoundingBox),
/* harmony export */   BrowserComponent: () => (/* binding */ __webpack_exports__BrowserComponent),
/* harmony export */   BrowserEvents: () => (/* binding */ __webpack_exports__BrowserEvents),
/* harmony export */   Buttons: () => (/* binding */ __webpack_exports__Buttons),
/* harmony export */   Camera: () => (/* binding */ __webpack_exports__Camera),
/* harmony export */   CameraEvents: () => (/* binding */ __webpack_exports__CameraEvents),
/* harmony export */   Canvas: () => (/* binding */ __webpack_exports__Canvas),
/* harmony export */   Circle: () => (/* binding */ __webpack_exports__Circle),
/* harmony export */   CircleCollider: () => (/* binding */ __webpack_exports__CircleCollider),
/* harmony export */   Clock: () => (/* binding */ __webpack_exports__Clock),
/* harmony export */   ClosestLineJumpTable: () => (/* binding */ __webpack_exports__ClosestLineJumpTable),
/* harmony export */   Collider: () => (/* binding */ __webpack_exports__Collider),
/* harmony export */   ColliderComponent: () => (/* binding */ __webpack_exports__ColliderComponent),
/* harmony export */   CollisionContact: () => (/* binding */ __webpack_exports__CollisionContact),
/* harmony export */   CollisionEndEvent: () => (/* binding */ __webpack_exports__CollisionEndEvent),
/* harmony export */   CollisionGroup: () => (/* binding */ __webpack_exports__CollisionGroup),
/* harmony export */   CollisionGroupManager: () => (/* binding */ __webpack_exports__CollisionGroupManager),
/* harmony export */   CollisionJumpTable: () => (/* binding */ __webpack_exports__CollisionJumpTable),
/* harmony export */   CollisionPostSolveEvent: () => (/* binding */ __webpack_exports__CollisionPostSolveEvent),
/* harmony export */   CollisionPreSolveEvent: () => (/* binding */ __webpack_exports__CollisionPreSolveEvent),
/* harmony export */   CollisionStartEvent: () => (/* binding */ __webpack_exports__CollisionStartEvent),
/* harmony export */   CollisionSystem: () => (/* binding */ __webpack_exports__CollisionSystem),
/* harmony export */   CollisionType: () => (/* binding */ __webpack_exports__CollisionType),
/* harmony export */   Color: () => (/* binding */ __webpack_exports__Color),
/* harmony export */   ColorBlindFlags: () => (/* binding */ __webpack_exports__ColorBlindFlags),
/* harmony export */   ColorBlindnessMode: () => (/* binding */ __webpack_exports__ColorBlindnessMode),
/* harmony export */   ColorBlindnessPostProcessor: () => (/* binding */ __webpack_exports__ColorBlindnessPostProcessor),
/* harmony export */   Component: () => (/* binding */ __webpack_exports__Component),
/* harmony export */   CompositeCollider: () => (/* binding */ __webpack_exports__CompositeCollider),
/* harmony export */   ConsoleAppender: () => (/* binding */ __webpack_exports__ConsoleAppender),
/* harmony export */   ContactConstraintPoint: () => (/* binding */ __webpack_exports__ContactConstraintPoint),
/* harmony export */   ContactEndEvent: () => (/* binding */ __webpack_exports__ContactEndEvent),
/* harmony export */   ContactSolveBias: () => (/* binding */ __webpack_exports__ContactSolveBias),
/* harmony export */   ContactStartEvent: () => (/* binding */ __webpack_exports__ContactStartEvent),
/* harmony export */   CoordPlane: () => (/* binding */ __webpack_exports__CoordPlane),
/* harmony export */   CrossFade: () => (/* binding */ __webpack_exports__CrossFade),
/* harmony export */   CurveBy: () => (/* binding */ __webpack_exports__CurveBy),
/* harmony export */   CurveTo: () => (/* binding */ __webpack_exports__CurveTo),
/* harmony export */   DeactivateEvent: () => (/* binding */ __webpack_exports__DeactivateEvent),
/* harmony export */   Debug: () => (/* binding */ __webpack_exports__Debug),
/* harmony export */   DebugConfig: () => (/* binding */ __webpack_exports__DebugConfig),
/* harmony export */   DebugGraphicsComponent: () => (/* binding */ __webpack_exports__DebugGraphicsComponent),
/* harmony export */   DebugSystem: () => (/* binding */ __webpack_exports__DebugSystem),
/* harmony export */   DebugText: () => (/* binding */ __webpack_exports__DebugText),
/* harmony export */   DefaultAntialiasOptions: () => (/* binding */ __webpack_exports__DefaultAntialiasOptions),
/* harmony export */   DefaultGarbageCollectionOptions: () => (/* binding */ __webpack_exports__DefaultGarbageCollectionOptions),
/* harmony export */   DefaultLoader: () => (/* binding */ __webpack_exports__DefaultLoader),
/* harmony export */   DefaultPixelArtOptions: () => (/* binding */ __webpack_exports__DefaultPixelArtOptions),
/* harmony export */   DegreeOfFreedom: () => (/* binding */ __webpack_exports__DegreeOfFreedom),
/* harmony export */   Delay: () => (/* binding */ __webpack_exports__Delay),
/* harmony export */   Detector: () => (/* binding */ __webpack_exports__Detector),
/* harmony export */   Die: () => (/* binding */ __webpack_exports__Die),
/* harmony export */   Direction: () => (/* binding */ __webpack_exports__Direction),
/* harmony export */   Director: () => (/* binding */ __webpack_exports__Director),
/* harmony export */   DirectorEvents: () => (/* binding */ __webpack_exports__DirectorEvents),
/* harmony export */   DisplayMode: () => (/* binding */ __webpack_exports__DisplayMode),
/* harmony export */   DynamicTree: () => (/* binding */ __webpack_exports__DynamicTree),
/* harmony export */   DynamicTreeCollisionProcessor: () => (/* binding */ __webpack_exports__DynamicTreeCollisionProcessor),
/* harmony export */   EX_VERSION: () => (/* binding */ __webpack_exports__EX_VERSION),
/* harmony export */   EaseBy: () => (/* binding */ __webpack_exports__EaseBy),
/* harmony export */   EaseTo: () => (/* binding */ __webpack_exports__EaseTo),
/* harmony export */   EasingFunctions: () => (/* binding */ __webpack_exports__EasingFunctions),
/* harmony export */   EdgeCollider: () => (/* binding */ __webpack_exports__EdgeCollider),
/* harmony export */   ElasticToActorStrategy: () => (/* binding */ __webpack_exports__ElasticToActorStrategy),
/* harmony export */   EmitterType: () => (/* binding */ __webpack_exports__EmitterType),
/* harmony export */   Engine: () => (/* binding */ __webpack_exports__Engine),
/* harmony export */   EngineEvents: () => (/* binding */ __webpack_exports__EngineEvents),
/* harmony export */   EnterTriggerEvent: () => (/* binding */ __webpack_exports__EnterTriggerEvent),
/* harmony export */   EnterViewPortEvent: () => (/* binding */ __webpack_exports__EnterViewPortEvent),
/* harmony export */   Entity: () => (/* binding */ __webpack_exports__Entity),
/* harmony export */   EntityEvents: () => (/* binding */ __webpack_exports__EntityEvents),
/* harmony export */   EntityManager: () => (/* binding */ __webpack_exports__EntityManager),
/* harmony export */   EventEmitter: () => (/* binding */ __webpack_exports__EventEmitter),
/* harmony export */   EventTypes: () => (/* binding */ __webpack_exports__EventTypes),
/* harmony export */   Events: () => (/* binding */ __webpack_exports__Events),
/* harmony export */   ExResponse: () => (/* binding */ __webpack_exports__ExResponse),
/* harmony export */   ExcaliburGraphicsContext2DCanvas: () => (/* binding */ __webpack_exports__ExcaliburGraphicsContext2DCanvas),
/* harmony export */   ExcaliburGraphicsContextWebGL: () => (/* binding */ __webpack_exports__ExcaliburGraphicsContextWebGL),
/* harmony export */   ExitTriggerEvent: () => (/* binding */ __webpack_exports__ExitTriggerEvent),
/* harmony export */   ExitViewPortEvent: () => (/* binding */ __webpack_exports__ExitViewPortEvent),
/* harmony export */   Fade: () => (/* binding */ __webpack_exports__Fade),
/* harmony export */   FadeInOut: () => (/* binding */ __webpack_exports__FadeInOut),
/* harmony export */   Flags: () => (/* binding */ __webpack_exports__Flags),
/* harmony export */   Flash: () => (/* binding */ __webpack_exports__Flash),
/* harmony export */   Follow: () => (/* binding */ __webpack_exports__Follow),
/* harmony export */   Font: () => (/* binding */ __webpack_exports__Font),
/* harmony export */   FontCache: () => (/* binding */ __webpack_exports__FontCache),
/* harmony export */   FontSource: () => (/* binding */ __webpack_exports__FontSource),
/* harmony export */   FontStyle: () => (/* binding */ __webpack_exports__FontStyle),
/* harmony export */   FontUnit: () => (/* binding */ __webpack_exports__FontUnit),
/* harmony export */   FpsSampler: () => (/* binding */ __webpack_exports__FpsSampler),
/* harmony export */   FrameStats: () => (/* binding */ __webpack_exports__FrameStats),
/* harmony export */   Future: () => (/* binding */ __webpack_exports__Future),
/* harmony export */   GameEvent: () => (/* binding */ __webpack_exports__GameEvent),
/* harmony export */   GameStartEvent: () => (/* binding */ __webpack_exports__GameStartEvent),
/* harmony export */   GameStopEvent: () => (/* binding */ __webpack_exports__GameStopEvent),
/* harmony export */   Gamepad: () => (/* binding */ __webpack_exports__Gamepad),
/* harmony export */   GamepadAxisEvent: () => (/* binding */ __webpack_exports__GamepadAxisEvent),
/* harmony export */   GamepadButtonEvent: () => (/* binding */ __webpack_exports__GamepadButtonEvent),
/* harmony export */   GamepadConnectEvent: () => (/* binding */ __webpack_exports__GamepadConnectEvent),
/* harmony export */   GamepadDisconnectEvent: () => (/* binding */ __webpack_exports__GamepadDisconnectEvent),
/* harmony export */   Gamepads: () => (/* binding */ __webpack_exports__Gamepads),
/* harmony export */   GarbageCollector: () => (/* binding */ __webpack_exports__GarbageCollector),
/* harmony export */   Gif: () => (/* binding */ __webpack_exports__Gif),
/* harmony export */   GifParser: () => (/* binding */ __webpack_exports__GifParser),
/* harmony export */   GlobalCoordinates: () => (/* binding */ __webpack_exports__GlobalCoordinates),
/* harmony export */   GpuParticleEmitter: () => (/* binding */ __webpack_exports__GpuParticleEmitter),
/* harmony export */   GpuParticleRenderer: () => (/* binding */ __webpack_exports__GpuParticleRenderer),
/* harmony export */   Graphic: () => (/* binding */ __webpack_exports__Graphic),
/* harmony export */   GraphicsComponent: () => (/* binding */ __webpack_exports__GraphicsComponent),
/* harmony export */   GraphicsGroup: () => (/* binding */ __webpack_exports__GraphicsGroup),
/* harmony export */   GraphicsSystem: () => (/* binding */ __webpack_exports__GraphicsSystem),
/* harmony export */   HashColliderProxy: () => (/* binding */ __webpack_exports__HashColliderProxy),
/* harmony export */   HashGridCell: () => (/* binding */ __webpack_exports__HashGridCell),
/* harmony export */   HashGridProxy: () => (/* binding */ __webpack_exports__HashGridProxy),
/* harmony export */   HiddenEvent: () => (/* binding */ __webpack_exports__HiddenEvent),
/* harmony export */   HorizontalFirst: () => (/* binding */ __webpack_exports__HorizontalFirst),
/* harmony export */   ImageFiltering: () => (/* binding */ __webpack_exports__ImageFiltering),
/* harmony export */   ImageSource: () => (/* binding */ __webpack_exports__ImageSource),
/* harmony export */   ImageSourceAttributeConstants: () => (/* binding */ __webpack_exports__ImageSourceAttributeConstants),
/* harmony export */   ImageWrapping: () => (/* binding */ __webpack_exports__ImageWrapping),
/* harmony export */   InitializeEvent: () => (/* binding */ __webpack_exports__InitializeEvent),
/* harmony export */   InputHost: () => (/* binding */ __webpack_exports__InputHost),
/* harmony export */   InputMapper: () => (/* binding */ __webpack_exports__InputMapper),
/* harmony export */   IsometricEntityComponent: () => (/* binding */ __webpack_exports__IsometricEntityComponent),
/* harmony export */   IsometricEntitySystem: () => (/* binding */ __webpack_exports__IsometricEntitySystem),
/* harmony export */   IsometricMap: () => (/* binding */ __webpack_exports__IsometricMap),
/* harmony export */   IsometricTile: () => (/* binding */ __webpack_exports__IsometricTile),
/* harmony export */   KeyEvent: () => (/* binding */ __webpack_exports__KeyEvent),
/* harmony export */   Keyboard: () => (/* binding */ __webpack_exports__Keyboard),
/* harmony export */   Keys: () => (/* binding */ __webpack_exports__Keys),
/* harmony export */   KillEvent: () => (/* binding */ __webpack_exports__KillEvent),
/* harmony export */   Label: () => (/* binding */ __webpack_exports__Label),
/* harmony export */   LimitCameraBoundsStrategy: () => (/* binding */ __webpack_exports__LimitCameraBoundsStrategy),
/* harmony export */   Line: () => (/* binding */ __webpack_exports__Line),
/* harmony export */   LineSegment: () => (/* binding */ __webpack_exports__LineSegment),
/* harmony export */   Loader: () => (/* binding */ __webpack_exports__Loader),
/* harmony export */   LoaderEvents: () => (/* binding */ __webpack_exports__LoaderEvents),
/* harmony export */   LockCameraToActorAxisStrategy: () => (/* binding */ __webpack_exports__LockCameraToActorAxisStrategy),
/* harmony export */   LockCameraToActorStrategy: () => (/* binding */ __webpack_exports__LockCameraToActorStrategy),
/* harmony export */   LogLevel: () => (/* binding */ __webpack_exports__LogLevel),
/* harmony export */   Logger: () => (/* binding */ __webpack_exports__Logger),
/* harmony export */   Material: () => (/* binding */ __webpack_exports__Material),
/* harmony export */   Matrix: () => (/* binding */ __webpack_exports__Matrix),
/* harmony export */   MatrixLocations: () => (/* binding */ __webpack_exports__MatrixLocations),
/* harmony export */   MediaEvent: () => (/* binding */ __webpack_exports__MediaEvent),
/* harmony export */   Meet: () => (/* binding */ __webpack_exports__Meet),
/* harmony export */   MotionComponent: () => (/* binding */ __webpack_exports__MotionComponent),
/* harmony export */   MotionSystem: () => (/* binding */ __webpack_exports__MotionSystem),
/* harmony export */   MoveBy: () => (/* binding */ __webpack_exports__MoveBy),
/* harmony export */   MoveByWithOptions: () => (/* binding */ __webpack_exports__MoveByWithOptions),
/* harmony export */   MoveTo: () => (/* binding */ __webpack_exports__MoveTo),
/* harmony export */   MoveToWithOptions: () => (/* binding */ __webpack_exports__MoveToWithOptions),
/* harmony export */   NativePointerButton: () => (/* binding */ __webpack_exports__NativePointerButton),
/* harmony export */   NativeSoundEvent: () => (/* binding */ __webpack_exports__NativeSoundEvent),
/* harmony export */   NativeSoundProcessedEvent: () => (/* binding */ __webpack_exports__NativeSoundProcessedEvent),
/* harmony export */   NineSlice: () => (/* binding */ __webpack_exports__NineSlice),
/* harmony export */   NineSliceStretch: () => (/* binding */ __webpack_exports__NineSliceStretch),
/* harmony export */   None: () => (/* binding */ __webpack_exports__None),
/* harmony export */   Observable: () => (/* binding */ __webpack_exports__Observable),
/* harmony export */   OffscreenSystem: () => (/* binding */ __webpack_exports__OffscreenSystem),
/* harmony export */   Pair: () => (/* binding */ __webpack_exports__Pair),
/* harmony export */   ParallaxComponent: () => (/* binding */ __webpack_exports__ParallaxComponent),
/* harmony export */   ParallelActions: () => (/* binding */ __webpack_exports__ParallelActions),
/* harmony export */   Particle: () => (/* binding */ __webpack_exports__Particle),
/* harmony export */   ParticleEmitter: () => (/* binding */ __webpack_exports__ParticleEmitter),
/* harmony export */   ParticleRenderer: () => (/* binding */ __webpack_exports__ParticleRenderer),
/* harmony export */   ParticleTransform: () => (/* binding */ __webpack_exports__ParticleTransform),
/* harmony export */   PhysicsStats: () => (/* binding */ __webpack_exports__PhysicsStats),
/* harmony export */   PhysicsWorld: () => (/* binding */ __webpack_exports__PhysicsWorld),
/* harmony export */   PointerAbstraction: () => (/* binding */ __webpack_exports__PointerAbstraction),
/* harmony export */   PointerButton: () => (/* binding */ __webpack_exports__PointerButton),
/* harmony export */   PointerComponent: () => (/* binding */ __webpack_exports__PointerComponent),
/* harmony export */   PointerEvent: () => (/* binding */ __webpack_exports__PointerEvent),
/* harmony export */   PointerEventReceiver: () => (/* binding */ __webpack_exports__PointerEventReceiver),
/* harmony export */   PointerScope: () => (/* binding */ __webpack_exports__PointerScope),
/* harmony export */   PointerSystem: () => (/* binding */ __webpack_exports__PointerSystem),
/* harmony export */   PointerType: () => (/* binding */ __webpack_exports__PointerType),
/* harmony export */   Polygon: () => (/* binding */ __webpack_exports__Polygon),
/* harmony export */   PolygonCollider: () => (/* binding */ __webpack_exports__PolygonCollider),
/* harmony export */   Pool: () => (/* binding */ __webpack_exports__Pool),
/* harmony export */   PostCollisionEvent: () => (/* binding */ __webpack_exports__PostCollisionEvent),
/* harmony export */   PostDebugDrawEvent: () => (/* binding */ __webpack_exports__PostDebugDrawEvent),
/* harmony export */   PostDrawEvent: () => (/* binding */ __webpack_exports__PostDrawEvent),
/* harmony export */   PostFrameEvent: () => (/* binding */ __webpack_exports__PostFrameEvent),
/* harmony export */   PostKillEvent: () => (/* binding */ __webpack_exports__PostKillEvent),
/* harmony export */   PostTransformDrawEvent: () => (/* binding */ __webpack_exports__PostTransformDrawEvent),
/* harmony export */   PostUpdateEvent: () => (/* binding */ __webpack_exports__PostUpdateEvent),
/* harmony export */   PreCollisionEvent: () => (/* binding */ __webpack_exports__PreCollisionEvent),
/* harmony export */   PreDebugDrawEvent: () => (/* binding */ __webpack_exports__PreDebugDrawEvent),
/* harmony export */   PreDrawEvent: () => (/* binding */ __webpack_exports__PreDrawEvent),
/* harmony export */   PreFrameEvent: () => (/* binding */ __webpack_exports__PreFrameEvent),
/* harmony export */   PreKillEvent: () => (/* binding */ __webpack_exports__PreKillEvent),
/* harmony export */   PreLoadEvent: () => (/* binding */ __webpack_exports__PreLoadEvent),
/* harmony export */   PreTransformDrawEvent: () => (/* binding */ __webpack_exports__PreTransformDrawEvent),
/* harmony export */   PreUpdateEvent: () => (/* binding */ __webpack_exports__PreUpdateEvent),
/* harmony export */   Projection: () => (/* binding */ __webpack_exports__Projection),
/* harmony export */   QuadIndexBuffer: () => (/* binding */ __webpack_exports__QuadIndexBuffer),
/* harmony export */   QuadTree: () => (/* binding */ __webpack_exports__QuadTree),
/* harmony export */   Query: () => (/* binding */ __webpack_exports__Query),
/* harmony export */   QueryManager: () => (/* binding */ __webpack_exports__QueryManager),
/* harmony export */   RadiusAroundActorStrategy: () => (/* binding */ __webpack_exports__RadiusAroundActorStrategy),
/* harmony export */   Random: () => (/* binding */ __webpack_exports__Random),
/* harmony export */   Raster: () => (/* binding */ __webpack_exports__Raster),
/* harmony export */   Ray: () => (/* binding */ __webpack_exports__Ray),
/* harmony export */   RealisticSolver: () => (/* binding */ __webpack_exports__RealisticSolver),
/* harmony export */   Rectangle: () => (/* binding */ __webpack_exports__Rectangle),
/* harmony export */   RemoveEvent: () => (/* binding */ __webpack_exports__RemoveEvent),
/* harmony export */   RemovedComponent: () => (/* binding */ __webpack_exports__RemovedComponent),
/* harmony export */   Repeat: () => (/* binding */ __webpack_exports__Repeat),
/* harmony export */   RepeatForever: () => (/* binding */ __webpack_exports__RepeatForever),
/* harmony export */   Resolution: () => (/* binding */ __webpack_exports__Resolution),
/* harmony export */   Resource: () => (/* binding */ __webpack_exports__Resource),
/* harmony export */   ResourceEvents: () => (/* binding */ __webpack_exports__ResourceEvents),
/* harmony export */   RotateBy: () => (/* binding */ __webpack_exports__RotateBy),
/* harmony export */   RotateByWithOptions: () => (/* binding */ __webpack_exports__RotateByWithOptions),
/* harmony export */   RotateTo: () => (/* binding */ __webpack_exports__RotateTo),
/* harmony export */   RotateToWithOptions: () => (/* binding */ __webpack_exports__RotateToWithOptions),
/* harmony export */   RotationType: () => (/* binding */ __webpack_exports__RotationType),
/* harmony export */   ScaleBy: () => (/* binding */ __webpack_exports__ScaleBy),
/* harmony export */   ScaleByWithOptions: () => (/* binding */ __webpack_exports__ScaleByWithOptions),
/* harmony export */   ScaleTo: () => (/* binding */ __webpack_exports__ScaleTo),
/* harmony export */   ScaleToWithOptions: () => (/* binding */ __webpack_exports__ScaleToWithOptions),
/* harmony export */   Scene: () => (/* binding */ __webpack_exports__Scene),
/* harmony export */   SceneEvents: () => (/* binding */ __webpack_exports__SceneEvents),
/* harmony export */   Screen: () => (/* binding */ __webpack_exports__Screen),
/* harmony export */   ScreenAppender: () => (/* binding */ __webpack_exports__ScreenAppender),
/* harmony export */   ScreenElement: () => (/* binding */ __webpack_exports__ScreenElement),
/* harmony export */   ScreenEvents: () => (/* binding */ __webpack_exports__ScreenEvents),
/* harmony export */   ScreenShader: () => (/* binding */ __webpack_exports__ScreenShader),
/* harmony export */   ScrollPreventionMode: () => (/* binding */ __webpack_exports__ScrollPreventionMode),
/* harmony export */   Semaphore: () => (/* binding */ __webpack_exports__Semaphore),
/* harmony export */   SeparatingAxis: () => (/* binding */ __webpack_exports__SeparatingAxis),
/* harmony export */   SeparationInfo: () => (/* binding */ __webpack_exports__SeparationInfo),
/* harmony export */   Shader: () => (/* binding */ __webpack_exports__Shader),
/* harmony export */   Shape: () => (/* binding */ __webpack_exports__Shape),
/* harmony export */   Side: () => (/* binding */ __webpack_exports__Side),
/* harmony export */   Slide: () => (/* binding */ __webpack_exports__Slide),
/* harmony export */   SolverStrategy: () => (/* binding */ __webpack_exports__SolverStrategy),
/* harmony export */   Sound: () => (/* binding */ __webpack_exports__Sound),
/* harmony export */   SoundEvents: () => (/* binding */ __webpack_exports__SoundEvents),
/* harmony export */   SparseHashGrid: () => (/* binding */ __webpack_exports__SparseHashGrid),
/* harmony export */   SparseHashGridCollisionProcessor: () => (/* binding */ __webpack_exports__SparseHashGridCollisionProcessor),
/* harmony export */   SpatialPartitionStrategy: () => (/* binding */ __webpack_exports__SpatialPartitionStrategy),
/* harmony export */   Sprite: () => (/* binding */ __webpack_exports__Sprite),
/* harmony export */   SpriteFont: () => (/* binding */ __webpack_exports__SpriteFont),
/* harmony export */   SpriteSheet: () => (/* binding */ __webpack_exports__SpriteSheet),
/* harmony export */   StandardClock: () => (/* binding */ __webpack_exports__StandardClock),
/* harmony export */   StateMachine: () => (/* binding */ __webpack_exports__StateMachine),
/* harmony export */   StrategyContainer: () => (/* binding */ __webpack_exports__StrategyContainer),
/* harmony export */   Stream: () => (/* binding */ __webpack_exports__Stream),
/* harmony export */   System: () => (/* binding */ __webpack_exports__System),
/* harmony export */   SystemManager: () => (/* binding */ __webpack_exports__SystemManager),
/* harmony export */   SystemPriority: () => (/* binding */ __webpack_exports__SystemPriority),
/* harmony export */   SystemType: () => (/* binding */ __webpack_exports__SystemType),
/* harmony export */   TagQuery: () => (/* binding */ __webpack_exports__TagQuery),
/* harmony export */   TestClock: () => (/* binding */ __webpack_exports__TestClock),
/* harmony export */   Text: () => (/* binding */ __webpack_exports__Text),
/* harmony export */   TextAlign: () => (/* binding */ __webpack_exports__TextAlign),
/* harmony export */   TextureLoader: () => (/* binding */ __webpack_exports__TextureLoader),
/* harmony export */   Tile: () => (/* binding */ __webpack_exports__Tile),
/* harmony export */   TileMap: () => (/* binding */ __webpack_exports__TileMap),
/* harmony export */   TileMapEvents: () => (/* binding */ __webpack_exports__TileMapEvents),
/* harmony export */   TiledAnimation: () => (/* binding */ __webpack_exports__TiledAnimation),
/* harmony export */   TiledSprite: () => (/* binding */ __webpack_exports__TiledSprite),
/* harmony export */   Timer: () => (/* binding */ __webpack_exports__Timer),
/* harmony export */   Toaster: () => (/* binding */ __webpack_exports__Toaster),
/* harmony export */   Transform: () => (/* binding */ __webpack_exports__Transform),
/* harmony export */   TransformComponent: () => (/* binding */ __webpack_exports__TransformComponent),
/* harmony export */   Transition: () => (/* binding */ __webpack_exports__Transition),
/* harmony export */   TreeNode: () => (/* binding */ __webpack_exports__TreeNode),
/* harmony export */   Trigger: () => (/* binding */ __webpack_exports__Trigger),
/* harmony export */   TriggerEvents: () => (/* binding */ __webpack_exports__TriggerEvents),
/* harmony export */   TwoPI: () => (/* binding */ __webpack_exports__TwoPI),
/* harmony export */   Util: () => (/* binding */ __webpack_exports__Util),
/* harmony export */   Vector: () => (/* binding */ __webpack_exports__Vector),
/* harmony export */   VectorView: () => (/* binding */ __webpack_exports__VectorView),
/* harmony export */   VertexBuffer: () => (/* binding */ __webpack_exports__VertexBuffer),
/* harmony export */   VertexLayout: () => (/* binding */ __webpack_exports__VertexLayout),
/* harmony export */   VerticalFirst: () => (/* binding */ __webpack_exports__VerticalFirst),
/* harmony export */   VisibleEvent: () => (/* binding */ __webpack_exports__VisibleEvent),
/* harmony export */   WebAudio: () => (/* binding */ __webpack_exports__WebAudio),
/* harmony export */   WebAudioInstance: () => (/* binding */ __webpack_exports__WebAudioInstance),
/* harmony export */   WheelDeltaMode: () => (/* binding */ __webpack_exports__WheelDeltaMode),
/* harmony export */   WheelEvent: () => (/* binding */ __webpack_exports__WheelEvent),
/* harmony export */   World: () => (/* binding */ __webpack_exports__World),
/* harmony export */   approximatelyEqual: () => (/* binding */ __webpack_exports__approximatelyEqual),
/* harmony export */   assert: () => (/* binding */ __webpack_exports__assert),
/* harmony export */   canonicalizeAngle: () => (/* binding */ __webpack_exports__canonicalizeAngle),
/* harmony export */   clamp: () => (/* binding */ __webpack_exports__clamp),
/* harmony export */   coroutine: () => (/* binding */ __webpack_exports__coroutine),
/* harmony export */   createId: () => (/* binding */ __webpack_exports__createId),
/* harmony export */   frac: () => (/* binding */ __webpack_exports__frac),
/* harmony export */   getDefaultPhysicsConfig: () => (/* binding */ __webpack_exports__getDefaultPhysicsConfig),
/* harmony export */   hasGraphicsTick: () => (/* binding */ __webpack_exports__hasGraphicsTick),
/* harmony export */   hasOnAdd: () => (/* binding */ __webpack_exports__hasOnAdd),
/* harmony export */   hasOnInitialize: () => (/* binding */ __webpack_exports__hasOnInitialize),
/* harmony export */   hasOnPostUpdate: () => (/* binding */ __webpack_exports__hasOnPostUpdate),
/* harmony export */   hasOnPreUpdate: () => (/* binding */ __webpack_exports__hasOnPreUpdate),
/* harmony export */   hasOnRemove: () => (/* binding */ __webpack_exports__hasOnRemove),
/* harmony export */   hasPostDraw: () => (/* binding */ __webpack_exports__hasPostDraw),
/* harmony export */   hasPreDraw: () => (/* binding */ __webpack_exports__hasPreDraw),
/* harmony export */   has_add: () => (/* binding */ __webpack_exports__has_add),
/* harmony export */   has_initialize: () => (/* binding */ __webpack_exports__has_initialize),
/* harmony export */   has_postupdate: () => (/* binding */ __webpack_exports__has_postupdate),
/* harmony export */   has_preupdate: () => (/* binding */ __webpack_exports__has_preupdate),
/* harmony export */   has_remove: () => (/* binding */ __webpack_exports__has_remove),
/* harmony export */   inverseLerp: () => (/* binding */ __webpack_exports__inverseLerp),
/* harmony export */   inverseLerpVector: () => (/* binding */ __webpack_exports__inverseLerpVector),
/* harmony export */   isActor: () => (/* binding */ __webpack_exports__isActor),
/* harmony export */   isAddedComponent: () => (/* binding */ __webpack_exports__isAddedComponent),
/* harmony export */   isComponentCtor: () => (/* binding */ __webpack_exports__isComponentCtor),
/* harmony export */   isLoaderConstructor: () => (/* binding */ __webpack_exports__isLoaderConstructor),
/* harmony export */   isMoveByOptions: () => (/* binding */ __webpack_exports__isMoveByOptions),
/* harmony export */   isMoveToOptions: () => (/* binding */ __webpack_exports__isMoveToOptions),
/* harmony export */   isRemovedComponent: () => (/* binding */ __webpack_exports__isRemovedComponent),
/* harmony export */   isRotateByOptions: () => (/* binding */ __webpack_exports__isRotateByOptions),
/* harmony export */   isRotateToOptions: () => (/* binding */ __webpack_exports__isRotateToOptions),
/* harmony export */   isScaleByOptions: () => (/* binding */ __webpack_exports__isScaleByOptions),
/* harmony export */   isScaleToOptions: () => (/* binding */ __webpack_exports__isScaleToOptions),
/* harmony export */   isSceneConstructor: () => (/* binding */ __webpack_exports__isSceneConstructor),
/* harmony export */   isScreenElement: () => (/* binding */ __webpack_exports__isScreenElement),
/* harmony export */   isSystemConstructor: () => (/* binding */ __webpack_exports__isSystemConstructor),
/* harmony export */   lerp: () => (/* binding */ __webpack_exports__lerp),
/* harmony export */   lerpAngle: () => (/* binding */ __webpack_exports__lerpAngle),
/* harmony export */   lerpVector: () => (/* binding */ __webpack_exports__lerpVector),
/* harmony export */   maxMessages: () => (/* binding */ __webpack_exports__maxMessages),
/* harmony export */   nextActionId: () => (/* binding */ __webpack_exports__nextActionId),
/* harmony export */   obsolete: () => (/* binding */ __webpack_exports__obsolete),
/* harmony export */   parseImageFiltering: () => (/* binding */ __webpack_exports__parseImageFiltering),
/* harmony export */   parseImageWrapping: () => (/* binding */ __webpack_exports__parseImageWrapping),
/* harmony export */   pixelSnapEpsilon: () => (/* binding */ __webpack_exports__pixelSnapEpsilon),
/* harmony export */   randomInRange: () => (/* binding */ __webpack_exports__randomInRange),
/* harmony export */   randomIntInRange: () => (/* binding */ __webpack_exports__randomIntInRange),
/* harmony export */   range: () => (/* binding */ __webpack_exports__range),
/* harmony export */   remap: () => (/* binding */ __webpack_exports__remap),
/* harmony export */   remapVector: () => (/* binding */ __webpack_exports__remapVector),
/* harmony export */   resetObsoleteCounter: () => (/* binding */ __webpack_exports__resetObsoleteCounter),
/* harmony export */   sign: () => (/* binding */ __webpack_exports__sign),
/* harmony export */   toDegrees: () => (/* binding */ __webpack_exports__toDegrees),
/* harmony export */   toRadians: () => (/* binding */ __webpack_exports__toRadians),
/* harmony export */   vec: () => (/* binding */ __webpack_exports__vec),
/* harmony export */   webgl: () => (/* binding */ __webpack_exports__webgl)
/* harmony export */ });
/*!
 * excalibur - 0.30.1 - 2024-12-12
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2024 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
/******/ var __webpack_modules__ = ({

/***/ "./Director/Loader.css":
/*!*****************************!*\
  !*** ./Director/Loader.css ***!
  \*****************************/
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_434__) => {

__nested_webpack_require_434__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_434__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_434__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_434__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_434__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_434__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* Buttons styles start */

button#excalibur-play {
  display: inline-block;
  position: relative;
  z-index: 999;
  border-radius: 6px;
  border: none;
  /*border: 3px solid;
    border-color: white;
    box-shadow: 0 0 10px #ccc;*/
  padding: 1rem 1.5rem 1rem 4rem;
  margin: 0;
  text-decoration: none;
  background: #00b233;
  color: #ffffff;
  font-family: sans-serif;
  font-size: 2rem;
  white-space: nowrap;
  line-height: 1;
  cursor: pointer;
  text-align: center;
  transition:
    background 250ms ease-in-out,
    transform 150ms ease;
  -webkit-appearance: none;
  -moz-appearance: none;

  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */
  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */
  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */
  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */
  animation: excalibur-button-fadein 200ms;
}

/*
button#excalibur-play {
  display: none;
}*/

button#excalibur-play:after {
  position: absolute;
  content: '';
  border: 8px solid;
  border-color: transparent transparent transparent white;
  left: 35px;
  top: 24px;
  width: 0;
  height: 0;
}

button#excalibur-play:before {
  position: absolute;
  content: '';
  border: 3px solid;
  left: 19px;
  top: 14px;
  border-radius: 20px;
  width: 30px;
  height: 30px;
}

button#excalibur-play:hover,
button#excalibur-play:focus {
  background: #00982c;
}

button#excalibur-play:focus {
  outline: 1px solid #fff;
  outline-offset: -4px;
}

button#excalibur-play:active {
  transform: scale(0.99);
}

@keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Firefox < 16 */
@-moz-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Safari, Chrome and Opera > 12.1 */
@-webkit-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Internet Explorer */
@-ms-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Opera < 12.1 */
@-o-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
`, "",{"version":3,"sources":["webpack://./Director/Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB;;wBAEsB;EACtB,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition:\r\n    background 250ms ease-in-out,\r\n    transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./Util/Toaster.css":
/*!**************************!*\
  !*** ./Util/Toaster.css ***!
  \**************************/
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_8167__) => {

__nested_webpack_require_8167__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_8167__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_8167__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_8167__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_8167__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_8167__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#ex-toast-container {
  position: absolute;
  height: 0;
  min-width: 50%;
  left: 50%;
  top: 0;
}

.ex-toast-message {
  left: -50%;
  position: relative;
  display: flex;
  justify-content: space-between;

  padding: 10px;
  margin-top: 5px;
  font-size: 18px;
  font-family: sans-serif;
  border-radius: 6px;
  border: 3px solid #b7b779;
  background-color: rgb(253, 253, 192);
}

.ex-toast-message button {
  align-self: flex-start;
}
`, "",{"version":3,"sources":["webpack://./Util/Toaster.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;EAE9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;AAEA;EACE,sBAAsB;AACxB","sourcesContent":["#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/api.js":
/*!*********************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/api.js ***!
  \*********************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!****************************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \****************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./Graphics/Context/circle-renderer/circle-renderer.frag.glsl":
/*!********************************************************************!*\
  !*** ./Graphics/Context/circle-renderer/circle-renderer.frag.glsl ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_14790__) => {

__nested_webpack_require_14790__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_14790__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision highp float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness;\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  // make (0, 0) the center the uv \r\n  vec2 uv = v_uv * 2.0 - 1.0;\r\n\r\n  vec4 color = v_color;\r\n  vec4 strokeColor = v_strokeColor;\r\n\r\n  // circle border is at radius 1.0 \r\n  // dist is > 0 when inside the circle \r\n  float d = length(uv);\r\n  float dist = 1.0 - length(uv);\r\n\r\n  // Fade based on fwidth\r\n  float fade = fwidth(dot(uv, uv));\r\n\r\n  // if dist is greater than 0 step to 1;\r\n  // when we cross this 0 threshold add a smooth fade\r\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\r\n\r\n  // if dist is greater than the stroke thickness step to 1\r\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\r\n\r\n  strokeColor.a *= fill * stroke;\r\n  strokeColor.rgb *= strokeColor.a;\r\n\r\n  color.a *= fill * (1.0 - stroke);\r\n  color.rgb *= color.a;\r\n\r\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\r\n  finalColor.rgb = finalColor.rgb * v_opacity;\r\n  finalColor.a = finalColor.a * v_opacity;\r\n  fragColor = finalColor;\r\n}");

/***/ }),

/***/ "./Graphics/Context/circle-renderer/circle-renderer.vert.glsl":
/*!********************************************************************!*\
  !*** ./Graphics/Context/circle-renderer/circle-renderer.vert.glsl ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_16850__) => {

__nested_webpack_require_16850__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_16850__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");

/***/ }),

/***/ "./Graphics/Context/image-renderer-v2/image-renderer-v2.frag.glsl":
/*!************************************************************************!*\
  !*** ./Graphics/Context/image-renderer-v2/image-renderer-v2.frag.glsl ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_18472__) => {

__nested_webpack_require_18472__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_18472__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_texcoord;\r\n\r\n// Textures in the current draw\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\nuniform bool u_pixelart;\r\n\r\nin float v_texture_index;\r\n\r\nin float v_opacity;\r\n\r\nin vec4 v_tint;\r\n\r\n// texture resolution\r\nin vec2 v_res;\r\n\r\nin vec2 v_uv_min;\r\nin vec2 v_uv_max;\r\n\r\nout vec4 fragColor;\r\n\r\n// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/\r\nvec2 uv_iq(in vec2 uv, in vec2 texture_size) {\r\n  vec2 pixel = uv * texture_size;\r\n\r\n  vec2 seam=floor(pixel+.5);\r\n  vec2 dudv=fwidth(pixel);\r\n  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);\r\n\r\n  return pixel/texture_size;\r\n}\r\n\r\nfloat lerp(float from, float to, float rel){\r\n  return ((1. - rel) * from) + (rel * to);\r\n}\r\n\r\nfloat invLerp(float from, float to, float value){\r\n  return (value - from) / (to - from);\r\n}\r\n\r\nfloat remap(float origFrom, float origTo, float targetFrom, float targetTo, float value){\r\n  float rel = invLerp(origFrom, origTo, value);\r\n  return lerp(targetFrom, targetTo, rel);\r\n}\r\n\r\nvoid main(){\r\n  // In order to support the most efficient sprite batching, we have multiple\r\n  // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n  // that do not apply to a particular sprite.\r\n\r\n  vec4 color=vec4(1.,0,0,1.);\r\n\r\n  // GLSL is templated out to pick the right texture and set the vec4 color\r\n  vec2 uv = u_pixelart ? uv_iq(v_texcoord, v_res) : v_texcoord;\r\n  uv.x = remap(0.,1., v_uv_min.x, v_uv_max.x, uv.x);\r\n  uv.y = remap(0.,1., v_uv_min.y, v_uv_max.y, uv.y);\r\n\r\n  %%texture_picker%%\r\n\r\n  color.rgb = color.rgb * v_opacity;\r\n  color.a = color.a * v_opacity;\r\n  fragColor = color * v_tint;\r\n}");

/***/ }),

/***/ "./Graphics/Context/image-renderer-v2/image-renderer-v2.vert.glsl":
/*!************************************************************************!*\
  !*** ./Graphics/Context/image-renderer-v2/image-renderer-v2.vert.glsl ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_20977__) => {

__nested_webpack_require_20977__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_20977__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nlayout(location=0) in vec2 pos;\r\nlayout(location=1) in vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\nlayout(location=2) in vec2 a_offset;\r\nlayout(location=3) in vec2 a_mat_column1;\r\nlayout(location=4) in vec2 a_mat_column2;\r\nlayout(location=5) in vec2 a_mat_column3;\r\n\r\nlayout(location=6) in float a_opacity;\r\nout float v_opacity;\r\n\r\n// Texture resolution (could be bigger than a_siz)\r\nlayout(location=7) in vec2 a_res;\r\nout vec2 v_res;\r\n\r\n// Final size of graphic\r\nlayout(location=8) in vec2 a_size;\r\n\r\nlayout(location=9) in lowp float a_texture_index;\r\nout lowp float v_texture_index;\r\n\r\nlayout(location=10) in vec2 a_uv_min;\r\nout vec2 v_uv_min;\r\n\r\nlayout(location=11) in vec2 a_uv_max;\r\nout vec2 v_uv_max;\r\n\r\nlayout(location=12) in vec4 a_tint;\r\nout vec4 v_tint;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main(){\r\n  mat4 world_mat = mat4(\r\n    a_mat_column1.x, a_mat_column1.y, 0., 0.,\r\n    a_mat_column2.x, a_mat_column2.y, 0., 0.,\r\n    0.             , 0.             , 1., 0.,\r\n    a_mat_column3.x, a_mat_column3.y, 0., 1.\r\n  );\r\n\r\n  vec2 newPos = vec2(pos.x * a_res.x, pos.y * a_res.y);\r\n  gl_Position = u_matrix * world_mat * vec4(newPos + a_offset, 0., 1.);\r\n\r\n  v_opacity = a_opacity;\r\n  v_texcoord = a_texcoord;\r\n  v_uv_min = a_uv_min;\r\n  v_uv_max = a_uv_max;\r\n  v_res = a_res;\r\n  v_texture_index = a_texture_index;\r\n  v_tint = a_tint;\r\n}");

/***/ }),

/***/ "./Graphics/Context/image-renderer/image-renderer.frag.glsl":
/*!******************************************************************!*\
  !*** ./Graphics/Context/image-renderer/image-renderer.frag.glsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_23085__) => {

__nested_webpack_require_23085__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_23085__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_texcoord;\r\n\r\n// Texture index\r\nin lowp float v_textureIndex;\r\n\r\n// Textures in the current draw\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\nuniform bool u_pixelart;\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nin vec4 v_tint;\r\n\r\nin vec2 v_res;\r\n\r\nout vec4 fragColor;\r\n\r\n// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/\r\nvec2 uv_iq(in vec2 uv, in vec2 texture_size) {\r\n  vec2 pixel = uv * texture_size;\r\n  \r\n  vec2 seam=floor(pixel+.5);\r\n  vec2 dudv=fwidth(pixel);\r\n  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);\r\n  \r\n  return pixel/texture_size;\r\n}\r\n\r\nvoid main(){\r\n  // In order to support the most efficient sprite batching, we have multiple\r\n  // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n  // that do not apply to a particular sprite.\r\n  \r\n  vec4 color=vec4(1.,0,0,1.);\r\n  \r\n  // GLSL is templated out to pick the right texture and set the vec4 color\r\n  %%texture_picker%%\r\n  \r\n  color.rgb=color.rgb*v_opacity;\r\n  color.a=color.a*v_opacity;\r\n  fragColor=color*v_tint;\r\n}");

/***/ }),

/***/ "./Graphics/Context/image-renderer/image-renderer.vert.glsl":
/*!******************************************************************!*\
  !*** ./Graphics/Context/image-renderer/image-renderer.vert.glsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_24943__) => {

__nested_webpack_require_24943__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_24943__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// Opacity\r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\n// UV coordinate\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\n// Texture res\r\nin vec2 a_res;\r\nout vec2 v_res;\r\n\r\n// Texture number\r\nin lowp float a_textureIndex;\r\nout lowp float v_textureIndex;\r\n\r\nin vec4 a_tint;\r\nout vec4 v_tint;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main(){\r\n  // Set the vertex position using the ortho transform matrix\r\n  gl_Position=u_matrix*vec4(a_position,0.,1.);\r\n  \r\n  // Pass through the Opacity to the fragment shader\r\n  v_opacity=a_opacity;\r\n  // Pass through the UV coord to the fragment shader\r\n  v_texcoord=a_texcoord;\r\n\r\n  v_res = a_res;\r\n\r\n  // Pass through the texture number to the fragment shader\r\n  v_textureIndex=a_textureIndex;\r\n  // Pass through the tint\r\n  v_tint=a_tint;\r\n}");

/***/ }),

/***/ "./Graphics/Context/line-renderer/line-fragment.glsl":
/*!***********************************************************!*\
  !*** ./Graphics/Context/line-renderer/line-fragment.glsl ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_26453__) => {

__nested_webpack_require_26453__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_26453__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Color\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  fragColor = v_color;\r\n}");

/***/ }),

/***/ "./Graphics/Context/line-renderer/line-vertex.glsl":
/*!*********************************************************!*\
  !*** ./Graphics/Context/line-renderer/line-vertex.glsl ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_27230__) => {

__nested_webpack_require_27230__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_27230__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\n\r\nout lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");

/***/ }),

/***/ "./Graphics/Context/particle-renderer/particle-fragment.glsl":
/*!*******************************************************************!*\
  !*** ./Graphics/Context/particle-renderer/particle-fragment.glsl ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_28213__) => {

__nested_webpack_require_28213__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_28213__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\nuniform sampler2D graphic;\r\nuniform bool useTexture;\r\nuniform float maxLifeMs;\r\n\r\nuniform vec4 beginColor;\r\nuniform vec4 endColor;\r\nuniform bool fade;\r\nuniform float startOpacity;\r\n\r\nin float finalRotation;\r\nin float finalLifeMs;\r\nout vec4 fragColor;\r\n\r\nvoid main(){\r\n\r\n  float lifePct = finalLifeMs / maxLifeMs;\r\n\r\n  if (useTexture) {\r\n    /** Draw texture */\r\n    if (lifePct <= 0.) discard;\r\n    float mid = .5;\r\n    float cosine = cos(finalRotation);\r\n    float sine = sin(finalRotation);\r\n    vec2 rotated = vec2(cosine * (gl_PointCoord.x - mid) + sine * (gl_PointCoord.y - mid) + mid,\r\n                        cosine * (gl_PointCoord.y - mid) - sine * (gl_PointCoord.x - mid) + mid);\r\n    vec4 color = texture(graphic, rotated);\r\n    fragColor = color * (fade ? lifePct : 1.0);\r\n  } else {\r\n    /** Draw circle */\r\n    if (lifePct <= 0.) discard;\r\n    vec2 uv = gl_PointCoord.xy * 2.0 - 1.0;\r\n    float dist = 1.0 - length(uv);\r\n    float edge = fwidth(dot(uv, uv));\r\n    float circle = smoothstep(-edge/2.0, edge/2.0, dist);\r\n    vec3 color = mix(beginColor.rgb, endColor.rgb, 1.0 - lifePct);\r\n    fragColor.rgb = color;\r\n    fragColor.a = startOpacity * circle * (fade ? lifePct : 1.0);// * mix(beginColor.a, endColor.a, 1.0 - lifePct);\r\n    fragColor.rgb *= fragColor.a;\r\n  }\r\n}");

/***/ }),

/***/ "./Graphics/Context/particle-renderer/particle-vertex.glsl":
/*!*****************************************************************!*\
  !*** ./Graphics/Context/particle-renderer/particle-vertex.glsl ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_30275__) => {

__nested_webpack_require_30275__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_30275__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\nuniform float deltaMs;\r\nuniform float maxLifeMs;\r\nuniform vec2 gravity;\r\nuniform vec2 focus;\r\nuniform float focusAccel;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_transform;\r\nuniform float startSize;\r\nuniform float endSize;\r\n// uniform sampler2D obstacle;\r\n\r\nlayout(location=0)in vec2 position;\r\nlayout(location=1)in vec2 velocity;\r\nlayout(location=2)in float rotation;\r\nlayout(location=3)in float angularVelocity;\r\nlayout(location=4)in float lifeMs;\r\n\r\n// TODO z index to handle buffer wrapping?\r\n\r\n// DO NOT RE-ORDER\r\nout vec2 finalPosition;\r\nout vec2 finalVelocity;\r\nout float finalRotation;\r\nout float finalAngularVelocity;\r\nout float finalLifeMs;\r\nvoid main(){\r\n  // Evolve particle\r\n  float seconds = deltaMs / 1000.;\r\n  // euler integration\r\n  // Weird artifact of re-using the same buffer layout for update/draw\r\n  // we need differently named variables\r\n  vec2 finalGravity = gravity + normalize(focus - position) * focusAccel;\r\n  finalVelocity = velocity + finalGravity * seconds;\r\n  finalPosition = position + velocity * seconds + finalGravity * .5 * seconds * seconds;\r\n  finalRotation = rotation + angularVelocity * seconds;\r\n  finalAngularVelocity = angularVelocity;\r\n  finalLifeMs = clamp(lifeMs - deltaMs, 0., maxLifeMs);\r\n\r\n  // Collision mask sampling\r\n  // vec2 samplePoint = finalPosition / vec2(width, height);\r\n  // vec4 collides = texture(obstacle, samplePoint);\r\n  // if (distance(collides,vec4(0.)) > .01) {\r\n  //   // non opaque means we collide! recalc final pos/vel\r\n  //   vec2 newVelocity = velocity * -.1;// lose energy\r\n  //   finalVelocity = newVelocity + gravity * seconds;\r\n  //   finalPosition = position + newVelocity * seconds + gravity * .5 * seconds * seconds;\r\n  // }\r\n\r\n  float lifePercent = finalLifeMs / maxLifeMs;\r\n  vec2 transformedPos = (u_matrix * u_transform * vec4(finalPosition,0.,1.)).xy;\r\n  float scale = sqrt(u_transform[0][0] * u_transform[0][0] + u_transform[1][1] * u_transform[1][1]);\r\n  gl_Position = vec4(transformedPos, 1.0 - lifePercent, 1.); // use life percent to sort z\r\n  gl_PointSize = mix(startSize, endSize, 1.0 - lifePercent) * scale;\r\n}");

/***/ }),

/***/ "./Graphics/Context/point-renderer/point-fragment.glsl":
/*!*************************************************************!*\
  !*** ./Graphics/Context/point-renderer/point-fragment.glsl ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_33166__) => {

__nested_webpack_require_33166__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_33166__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\n\r\nprecision mediump float;\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n  // \"premultiply\" the color by alpha\r\n  vec4 color = v_color;\r\n  color.a = color.a * alpha;\r\n  color.rgb = color.rgb * color.a;\r\n  fragColor = color;\r\n}");

/***/ }),

/***/ "./Graphics/Context/point-renderer/point-vertex.glsl":
/*!***********************************************************!*\
  !*** ./Graphics/Context/point-renderer/point-vertex.glsl ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_34278__) => {

__nested_webpack_require_34278__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_34278__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\nin float a_size;\r\nout lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");

/***/ }),

/***/ "./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl":
/*!**************************************************************************!*\
  !*** ./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_35232__) => {

__nested_webpack_require_35232__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_35232__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\nin vec2 v_size; // in pixels\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness; // in pixels\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    vec2 uv = v_uv;\r\n    vec2 fragCoord = uv * v_size;\r\n    float maxX = v_size.x - v_strokeThickness;\r\n    float minX = v_strokeThickness;\r\n    float maxY = v_size.y - v_strokeThickness;\r\n    float minY = v_strokeThickness;\r\n\r\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\r\n        fragCoord.y < maxY && fragCoord.y > minY) {\r\n      fragColor = v_color;\r\n    } else {\r\n      fragColor = v_strokeColor;\r\n    }\r\n    fragColor.a *= v_opacity;\r\n    fragColor.rgb *= fragColor.a;\r\n\r\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\r\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\r\n\r\n    // float fHalfBorderDist      = 0.0;\r\n    // float fHalfBorderThickness = 0.0;\r\n\r\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \r\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \r\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else\r\n    // {\r\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\r\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\r\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\r\n        \r\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\r\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\r\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \r\n            \r\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\r\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\r\n    // }\r\n\r\n    // vec4 v4FromColor = v_strokeColor;\r\n    // v4FromColor.rgb *= v4FromColor.a;\r\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\r\n    // if (fHalfBorderDist < 0.0) {\r\n    //     v4ToColor = v_color;\r\n    //     v4ToColor.rgb *= v4ToColor.a;\r\n    // }\r\n\r\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\r\n\r\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\r\n    // gl_FragColor = finalColor;\r\n}");

/***/ }),

/***/ "./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl":
/*!**************************************************************************!*\
  !*** ./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_39016__) => {

__nested_webpack_require_39016__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_39016__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\nin vec2 a_size;\r\nout vec2 v_size;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through size\r\n   v_size = a_size;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");

/***/ }),

/***/ "./Graphics/Context/screen-pass-painter/screen-fragment.glsl":
/*!*******************************************************************!*\
  !*** ./Graphics/Context/screen-pass-painter/screen-fragment.glsl ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_40711__) => {

__nested_webpack_require_40711__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_40711__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// The texture.\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   fragColor = texture(u_texture, v_texcoord);\r\n}");

/***/ }),

/***/ "./Graphics/Context/screen-pass-painter/screen-vertex.glsl":
/*!*****************************************************************!*\
  !*** ./Graphics/Context/screen-pass-painter/screen-vertex.glsl ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_41625__) => {

__nested_webpack_require_41625__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_41625__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nin vec2 a_position;\r\n\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n  gl_Position = vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texcoord to the fragment shader.\r\n  v_texcoord = a_texcoord;\r\n}");

/***/ }),

/***/ "./Graphics/PostProcessor/color-blind-fragment.glsl":
/*!**********************************************************!*\
  !*** ./Graphics/PostProcessor/color-blind-fragment.glsl ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_42489__) => {

__nested_webpack_require_42489__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_42489__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#version 300 es\r\nprecision mediump float;\r\n// our texture\r\nuniform sampler2D u_image;\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// color blind type\r\nuniform int u_type;\r\n\r\n// simulation?\r\nuniform bool u_simulate;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec4 o =  texture(u_image, v_texcoord);\r\n  // RGB to LMS matrix conversion\r\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\r\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\r\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\r\n  // Simulate color blindness\r\n  float l;\r\n  float m;\r\n  float s;\r\n  //MODE CODE//\r\n  if (u_type == 0) {\r\n    // Protanope\r\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\r\n  } else if (u_type == 1) {\r\n    // Deuteranope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\r\n  } else if (u_type == 2) {\r\n    // Tritanope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\r\n  }\r\n\r\n  // LMS to RGB matrix conversion\r\n  vec4 error; // simulate the colors\r\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\r\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\r\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\r\n  error.a = 1.0;\r\n  vec4 diff = o - error;\r\n  vec4 correction; // correct the colors\r\n  correction.r = 0.0;\r\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\r\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\r\n  correction = o + correction;\r\n  correction.a = o.a;\r\n  //SIMULATE//\r\n\r\n  // sim \r\n  if (u_simulate) {\r\n    fragColor = error.rgba;\r\n  } else {\r\n    fragColor = correction.rgba;\r\n  }\r\n}");

/***/ }),

/***/ "./Actions/Action.ts":
/*!***************************!*\
  !*** ./Actions/Action.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_44978__) => {

__nested_webpack_require_44978__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_44978__.d(__nested_webpack_exports__, {
/* harmony export */   nextActionId: () => (/* binding */ nextActionId)
/* harmony export */ });
let _ACTION_ID = 0;
/**
 *
 */
function nextActionId() {
    return _ACTION_ID++;
}


/***/ }),

/***/ "./Actions/ActionContext.ts":
/*!**********************************!*\
  !*** ./Actions/ActionContext.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_45518__) => {

__nested_webpack_require_45518__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_45518__.d(__nested_webpack_exports__, {
/* harmony export */   ActionContext: () => (/* binding */ ActionContext)
/* harmony export */ });
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_45518__(/*! ../Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _ActionQueue__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_45518__(/*! ./ActionQueue */ "./Actions/ActionQueue.ts");
/* harmony import */ var _Action_Repeat__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_45518__(/*! ./Action/Repeat */ "./Actions/Action/Repeat.ts");
/* harmony import */ var _Action_RepeatForever__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_45518__(/*! ./Action/RepeatForever */ "./Actions/Action/RepeatForever.ts");
/* harmony import */ var _Action_MoveBy__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_45518__(/*! ./Action/MoveBy */ "./Actions/Action/MoveBy.ts");
/* harmony import */ var _Action_MoveTo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_45518__(/*! ./Action/MoveTo */ "./Actions/Action/MoveTo.ts");
/* harmony import */ var _Action_RotateTo__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_45518__(/*! ./Action/RotateTo */ "./Actions/Action/RotateTo.ts");
/* harmony import */ var _Action_RotateBy__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_45518__(/*! ./Action/RotateBy */ "./Actions/Action/RotateBy.ts");
/* harmony import */ var _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_45518__(/*! ./Action/ScaleTo */ "./Actions/Action/ScaleTo.ts");
/* harmony import */ var _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_45518__(/*! ./Action/ScaleBy */ "./Actions/Action/ScaleBy.ts");
/* harmony import */ var _Action_CallMethod__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_45518__(/*! ./Action/CallMethod */ "./Actions/Action/CallMethod.ts");
/* harmony import */ var _Action_EaseTo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_45518__(/*! ./Action/EaseTo */ "./Actions/Action/EaseTo.ts");
/* harmony import */ var _Action_EaseBy__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_45518__(/*! ./Action/EaseBy */ "./Actions/Action/EaseBy.ts");
/* harmony import */ var _Action_Blink__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_45518__(/*! ./Action/Blink */ "./Actions/Action/Blink.ts");
/* harmony import */ var _Action_Fade__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_45518__(/*! ./Action/Fade */ "./Actions/Action/Fade.ts");
/* harmony import */ var _Action_Delay__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_45518__(/*! ./Action/Delay */ "./Actions/Action/Delay.ts");
/* harmony import */ var _Action_Die__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_45518__(/*! ./Action/Die */ "./Actions/Action/Die.ts");
/* harmony import */ var _Action_Follow__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_45518__(/*! ./Action/Follow */ "./Actions/Action/Follow.ts");
/* harmony import */ var _Action_Meet__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_45518__(/*! ./Action/Meet */ "./Actions/Action/Meet.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_45518__(/*! ../Math */ "./Math/vector.ts");
/* harmony import */ var _Action_Flash__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_45518__(/*! ./Action/Flash */ "./Actions/Action/Flash.ts");
/* harmony import */ var _Action_CurveTo__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_45518__(/*! ./Action/CurveTo */ "./Actions/Action/CurveTo.ts");
/* harmony import */ var _Action_CurveBy__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_45518__(/*! ./Action/CurveBy */ "./Actions/Action/CurveBy.ts");























/**
 * The fluent Action API allows you to perform "actions" on
 * {@apilink Actor | `actors`} such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the {@apilink Action} interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new _ActionQueue__WEBPACK_IMPORTED_MODULE_0__.ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsed) {
        this._queue.update(elapsed);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    runAction(action) {
        action.reset();
        this._queue.add(action);
        return this;
    }
    /**
     * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
     * to be the actors current position
     * @param options
     */
    curveBy(options) {
        this._queue.add(new _Action_CurveBy__WEBPACK_IMPORTED_MODULE_1__.CurveBy(this._entity, options));
        return this;
    }
    /**
     * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
     * to be the actors current position
     * @param options
     */
    curveTo(options) {
        this._queue.add(new _Action_CurveTo__WEBPACK_IMPORTED_MODULE_2__.CurveTo(this._entity, options));
        return this;
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_3__.EasingFunctions.Linear;
        if (args[0] instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new _Action_EaseTo__WEBPACK_IMPORTED_MODULE_5__.EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    easeBy(...args) {
        var _a, _b;
        let offsetX = 0;
        let offsetY = 0;
        let duration = 0;
        let easingFcn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_3__.EasingFunctions.Linear;
        if (args[0] instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            offsetX = args[0].x;
            offsetY = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            offsetX = args[0];
            offsetY = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new _Action_EaseBy__WEBPACK_IMPORTED_MODULE_6__.EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));
        return this;
    }
    moveTo(xOrPosOrOptions, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPosOrOptions instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            x = xOrPosOrOptions.x;
            y = xOrPosOrOptions.y;
            speed = +(yOrSpeed !== null && yOrSpeed !== void 0 ? yOrSpeed : 0);
            this._queue.add(new _Action_MoveTo__WEBPACK_IMPORTED_MODULE_7__.MoveTo(this._entity, x, y, speed));
        }
        else if (typeof xOrPosOrOptions === 'number' && typeof yOrSpeed === 'number' && typeof speedOrUndefined === 'number') {
            x = xOrPosOrOptions;
            y = yOrSpeed;
            speed = speedOrUndefined;
            this._queue.add(new _Action_MoveTo__WEBPACK_IMPORTED_MODULE_7__.MoveTo(this._entity, x, y, speed));
        }
        else if ((0,_Action_MoveTo__WEBPACK_IMPORTED_MODULE_7__.isMoveToOptions)(xOrPosOrOptions)) {
            this._queue.add(new _Action_MoveTo__WEBPACK_IMPORTED_MODULE_7__.MoveToWithOptions(this._entity, xOrPosOrOptions));
        }
        return this;
    }
    moveBy(xOffsetOrVectorOrOptions, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVectorOrOptions instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector && typeof yOffsetOrSpeed === 'number') {
            xOffset = xOffsetOrVectorOrOptions.x;
            yOffset = xOffsetOrVectorOrOptions.y;
            speed = yOffsetOrSpeed;
            this._queue.add(new _Action_MoveBy__WEBPACK_IMPORTED_MODULE_8__.MoveBy(this._entity, xOffset, yOffset, speed));
        }
        else if (typeof xOffsetOrVectorOrOptions === 'number' && typeof yOffsetOrSpeed === 'number' && typeof speedOrUndefined === 'number') {
            xOffset = xOffsetOrVectorOrOptions;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
            this._queue.add(new _Action_MoveBy__WEBPACK_IMPORTED_MODULE_8__.MoveBy(this._entity, xOffset, yOffset, speed));
        }
        else if ((0,_Action_MoveBy__WEBPACK_IMPORTED_MODULE_8__.isMoveByOptions)(xOffsetOrVectorOrOptions)) {
            this._queue.add(new _Action_MoveBy__WEBPACK_IMPORTED_MODULE_8__.MoveByWithOptions(this._entity, xOffsetOrVectorOrOptions));
        }
        return this;
    }
    rotateTo(angleRadiansOrOptions, speed, rotationType) {
        if (typeof angleRadiansOrOptions === 'number' && typeof speed === 'number') {
            this._queue.add(new _Action_RotateTo__WEBPACK_IMPORTED_MODULE_9__.RotateTo(this._entity, angleRadiansOrOptions, speed, rotationType));
        }
        else if (typeof angleRadiansOrOptions === 'object') {
            this._queue.add(new _Action_RotateTo__WEBPACK_IMPORTED_MODULE_9__.RotateToWithOptions(this._entity, angleRadiansOrOptions));
        }
        return this;
    }
    rotateBy(angleRadiansOffsetOrOptions, speed, rotationType) {
        if (typeof angleRadiansOffsetOrOptions === 'object') {
            this._queue.add(new _Action_RotateBy__WEBPACK_IMPORTED_MODULE_10__.RotateByWithOptions(this._entity, angleRadiansOffsetOrOptions));
        }
        else {
            this._queue.add(new _Action_RotateBy__WEBPACK_IMPORTED_MODULE_10__.RotateBy(this._entity, angleRadiansOffsetOrOptions, speed, rotationType));
        }
        return this;
    }
    scaleTo(sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if ((0,_Action_ScaleTo__WEBPACK_IMPORTED_MODULE_11__.isScaleToOptions)(sizeXOrVectorOrOptions)) {
            this._queue.add(new _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_11__.ScaleToWithOptions(this._entity, sizeXOrVectorOrOptions));
            return this;
        }
        if (sizeXOrVectorOrOptions instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector && sizeYOrSpeed instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            sizeX = sizeXOrVectorOrOptions.x;
            sizeY = sizeXOrVectorOrOptions.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVectorOrOptions === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVectorOrOptions;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_11__.ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed) {
        if ((0,_Action_ScaleBy__WEBPACK_IMPORTED_MODULE_12__.isScaleByOptions)(sizeOffsetXOrVectorOrOptions)) {
            this._queue.add(new _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_12__.ScaleByWithOptions(this._entity, sizeOffsetXOrVectorOrOptions));
            return this;
        }
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVectorOrOptions instanceof _Math__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            sizeOffsetX = sizeOffsetXOrVectorOrOptions.x;
            sizeOffsetY = sizeOffsetXOrVectorOrOptions.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVectorOrOptions === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVectorOrOptions;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_12__.ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new _Action_Blink__WEBPACK_IMPORTED_MODULE_13__.Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param duration     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, duration) {
        this._queue.add(new _Action_Fade__WEBPACK_IMPORTED_MODULE_14__.Fade(this._entity, opacity, duration));
        return this;
    }
    /**
     * This will cause an actor to flash a specific color for a period of time
     * @param color
     * @param duration The duration in milliseconds
     */
    flash(color, duration = 1000) {
        this._queue.add(new _Action_Flash__WEBPACK_IMPORTED_MODULE_15__.Flash(this._entity, color, duration));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(duration) {
        this._queue.add(new _Action_Delay__WEBPACK_IMPORTED_MODULE_16__.Delay(duration));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new _Action_Die__WEBPACK_IMPORTED_MODULE_17__.Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new _Action_CallMethod__WEBPACK_IMPORTED_MODULE_18__.CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     * repeatCtx.moveBy(10, 0, 10);
     * repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new _Action_Repeat__WEBPACK_IMPORTED_MODULE_19__.Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     * repeatCtx.moveBy(10, 0, 10);
     * repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new _Action_RepeatForever__WEBPACK_IMPORTED_MODULE_20__.RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new _Action_Follow__WEBPACK_IMPORTED_MODULE_21__.Follow(this._entity, entity));
        }
        else {
            this._queue.add(new _Action_Follow__WEBPACK_IMPORTED_MODULE_21__.Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new _Action_Meet__WEBPACK_IMPORTED_MODULE_22__.Meet(this._entity, entity));
        }
        else {
            this._queue.add(new _Action_Meet__WEBPACK_IMPORTED_MODULE_22__.Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new _Action_CallMethod__WEBPACK_IMPORTED_MODULE_18__.CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}


/***/ }),

/***/ "./Actions/ActionQueue.ts":
/*!********************************!*\
  !*** ./Actions/ActionQueue.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_64500__) => {

__nested_webpack_require_64500__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_64500__.d(__nested_webpack_exports__, {
/* harmony export */   ActionQueue: () => (/* binding */ ActionQueue)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_64500__(/*! ../Events */ "./Events.ts");

/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the {@apilink ActionContext | `Action API`} and
 * store the list of actions to be executed for an {@apilink Actor}.
 *
 * Actors implement {@apilink Actor.actions} which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._currentAction = null;
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    getIncompleteActions() {
        return this._actions;
    }
    getCurrentAction() {
        return this._currentAction;
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsed
     */
    update(elapsed) {
        if (this._actions.length > 0) {
            if (this._currentAction !== this._actions[0]) {
                this._currentAction = this._actions[0];
                this._entity.emit('actionstart', new _Events__WEBPACK_IMPORTED_MODULE_0__.ActionStartEvent(this._currentAction, this._entity));
            }
            this._currentAction.update(elapsed);
            if (this._currentAction.isComplete(this._entity)) {
                this._entity.emit('actioncomplete', new _Events__WEBPACK_IMPORTED_MODULE_0__.ActionCompleteEvent(this._currentAction, this._entity));
                const complete = this._actions.shift();
                if (complete) {
                    this._completedActions.push(complete);
                }
            }
        }
    }
}


/***/ }),

/***/ "./Actions/Action/ActionSequence.ts":
/*!******************************************!*\
  !*** ./Actions/Action/ActionSequence.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_68136__) => {

__nested_webpack_require_68136__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_68136__.d(__nested_webpack_exports__, {
/* harmony export */   ActionSequence: () => (/* binding */ ActionSequence)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_68136__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_68136__(/*! ../ActionContext */ "./Actions/ActionContext.ts");


/**
 * Action that can represent a sequence of actions, this can be useful in conjunction with
 * {@apilink ParallelActions} to run multiple sequences in parallel.
 */
class ActionSequence {
    constructor(entity, actionBuilder) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._stopped = false;
        this._sequenceBuilder = actionBuilder;
        this._sequenceContext = new _ActionContext__WEBPACK_IMPORTED_MODULE_1__.ActionContext(entity);
        this._actionQueue = this._sequenceContext.getQueue();
        this._sequenceBuilder(this._sequenceContext);
    }
    update(elapsed) {
        this._actionQueue.update(elapsed);
    }
    isComplete() {
        return this._stopped || this._actionQueue.isComplete();
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._stopped = false;
        this._actionQueue.reset();
    }
    clone(entity) {
        return new ActionSequence(entity, this._sequenceBuilder);
    }
}


/***/ }),

/***/ "./Actions/Action/Blink.ts":
/*!*********************************!*\
  !*** ./Actions/Action/Blink.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_69864__) => {

__nested_webpack_require_69864__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_69864__.d(__nested_webpack_exports__, {
/* harmony export */   Blink: () => (/* binding */ Blink)
/* harmony export */ });
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_69864__(/*! ../../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_69864__(/*! ../Action */ "./Actions/Action.ts");


class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__.GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._elapsedTime = 0;
            this._totalTime = 0;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += elapsed;
        this._totalTime += elapsed;
        if (this._graphics.isVisible && this._elapsedTime >= this._timeVisible) {
            this._graphics.isVisible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.isVisible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.isVisible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.isVisible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.isVisible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}


/***/ }),

/***/ "./Actions/Action/CallMethod.ts":
/*!**************************************!*\
  !*** ./Actions/Action/CallMethod.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_72363__) => {

__nested_webpack_require_72363__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_72363__.d(__nested_webpack_exports__, {
/* harmony export */   CallMethod: () => (/* binding */ CallMethod)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72363__(/*! ../Action */ "./Actions/Action.ts");

class CallMethod {
    constructor(method) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(elapsed) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}


/***/ }),

/***/ "./Actions/Action/CurveBy.ts":
/*!***********************************!*\
  !*** ./Actions/Action/CurveBy.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_73402__) => {

__nested_webpack_require_73402__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_73402__.d(__nested_webpack_exports__, {
/* harmony export */   CurveBy: () => (/* binding */ CurveBy)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_73402__(/*! ../../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_73402__(/*! ../../Math */ "./Math/bezier-curve.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_73402__(/*! ../../Math */ "./Math/vector.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_73402__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_73402__(/*! ../../Math */ "./Math/lerp.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_73402__(/*! ../Action */ "./Actions/Action.ts");



class CurveBy {
    constructor(entity, options) {
        var _a;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._mode = 'dynamic';
        this._entity = entity;
        this._tx = this._entity.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
        }
        this._curve = this._curve = new _Math__WEBPACK_IMPORTED_MODULE_2__.BezierCurve({
            controlPoints: [(0,_Math__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0), ...options.controlPoints],
            quality: options.quality
        });
        this._durationMs = options.duration;
        this._mode = (_a = options.mode) !== null && _a !== void 0 ? _a : this._mode;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._curve.setControlPoint(0, this._tx.globalPos);
            this._curve.setControlPoint(1, this._curve.controlPoints[1].add(this._tx.globalPos));
            this._curve.setControlPoint(2, this._curve.controlPoints[2].add(this._tx.globalPos));
            this._curve.setControlPoint(3, this._curve.controlPoints[3].add(this._tx.globalPos));
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        if (this._mode === 'dynamic') {
            this._tx.pos = this._curve.getPoint(t);
        }
        else {
            this._tx.pos = this._curve.getUniformPoint(t);
        }
        if (this.isComplete(this._entity)) {
            if (this._mode === 'dynamic') {
                this._tx.pos = this._curve.getPoint(1);
            }
            else {
                this._tx.pos = this._curve.getUniformPoint(1);
            }
        }
    }
    isComplete(entity) {
        return this._stopped || this._currentMs < 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
    stop() {
        this._stopped = true;
    }
}


/***/ }),

/***/ "./Actions/Action/CurveTo.ts":
/*!***********************************!*\
  !*** ./Actions/Action/CurveTo.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_77019__) => {

__nested_webpack_require_77019__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_77019__.d(__nested_webpack_exports__, {
/* harmony export */   CurveTo: () => (/* binding */ CurveTo)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_77019__(/*! ../../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_77019__(/*! ../../Math */ "./Math/bezier-curve.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_77019__(/*! ../../Math */ "./Math/vector.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_77019__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_77019__(/*! ../../Math */ "./Math/lerp.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_77019__(/*! ../Action */ "./Actions/Action.ts");



class CurveTo {
    constructor(entity, options) {
        var _a;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._mode = 'dynamic';
        this._entity = entity;
        this._tx = this._entity.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
        }
        this._curve = new _Math__WEBPACK_IMPORTED_MODULE_2__.BezierCurve({
            controlPoints: [(0,_Math__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0), ...options.controlPoints],
            quality: options.quality
        });
        this._durationMs = options.duration;
        this._mode = (_a = options.mode) !== null && _a !== void 0 ? _a : this._mode;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._curve.setControlPoint(0, this._tx.globalPos.clone());
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        if (this._mode === 'dynamic') {
            this._tx.pos = this._curve.getPoint(t);
        }
        else {
            this._tx.pos = this._curve.getUniformPoint(t);
        }
        if (this.isComplete(this._entity)) {
            if (this._mode === 'dynamic') {
                this._tx.pos = this._curve.getPoint(1);
            }
            else {
                this._tx.pos = this._curve.getUniformPoint(1);
            }
        }
    }
    isComplete(entity) {
        return this._stopped || this._currentMs < 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
    stop() {
        this._stopped = true;
        this._currentMs = 0;
    }
}


/***/ }),

/***/ "./Actions/Action/Delay.ts":
/*!*********************************!*\
  !*** ./Actions/Action/Delay.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_80357__) => {

__nested_webpack_require_80357__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_80357__.d(__nested_webpack_exports__, {
/* harmony export */   Delay: () => (/* binding */ Delay)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_80357__(/*! ../Action */ "./Actions/Action.ts");

class Delay {
    constructor(duration) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = duration;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += elapsed;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/Die.ts":
/*!*******************************!*\
  !*** ./Actions/Action/Die.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_81556__) => {

__nested_webpack_require_81556__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_81556__.d(__nested_webpack_exports__, {
/* harmony export */   Die: () => (/* binding */ Die)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_81556__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _ActionsComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_81556__(/*! ../ActionsComponent */ "./Actions/ActionsComponent.ts");


class Die {
    constructor(entity) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._stopped = false;
        this._entity = entity;
    }
    update(elapsed) {
        this._entity.get(_ActionsComponent__WEBPACK_IMPORTED_MODULE_1__.ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}


/***/ }),

/***/ "./Actions/Action/EaseBy.ts":
/*!**********************************!*\
  !*** ./Actions/Action/EaseBy.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_82778__) => {

__nested_webpack_require_82778__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_82778__.d(__nested_webpack_exports__, {
/* harmony export */   EaseBy: () => (/* binding */ EaseBy)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_82778__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_82778__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_82778__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_82778__(/*! ../Action */ "./Actions/Action.ts");




/**
 * @deprecated use moveBy({offset: Vector, duration: number, easing: EasingFunction})
 */
class EaseBy {
    constructor(entity, offsetX, offsetY, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);
        this._lerpEnd = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        this._lerpDuration = duration;
        this._offset = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(offsetX, offsetY);
    }
    _initialize() {
        this._lerpStart = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._lerpEnd = this._lerpStart.add(this._offset);
    }
    update(elapsed) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += elapsed;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)((newX - this._tx.pos.x) / (elapsed / 1000), (newY - this._tx.pos.y) / (elapsed / 1000));
        }
        else {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._stopped = true;
    }
}


/***/ }),

/***/ "./Actions/Action/EaseTo.ts":
/*!**********************************!*\
  !*** ./Actions/Action/EaseTo.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_87321__) => {

__nested_webpack_require_87321__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_87321__.d(__nested_webpack_exports__, {
/* harmony export */   EaseTo: () => (/* binding */ EaseTo)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_87321__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_87321__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_87321__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_87321__(/*! ../Action */ "./Actions/Action.ts");




/**
 * @deprecated use moveTo({pos: Vector, duration: number, easing: EasingFunction})
 */
class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);
        this._lerpEnd = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
    }
    update(elapsed) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += elapsed;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)((newX - this._tx.pos.x) / (elapsed / 1000), (newY - this._tx.pos.y) / (elapsed / 1000));
        }
        else {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._stopped = true;
    }
}


/***/ }),

/***/ "./Actions/Action/Fade.ts":
/*!********************************!*\
  !*** ./Actions/Action/Fade.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_91771__) => {

__nested_webpack_require_91771__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_91771__.d(__nested_webpack_exports__, {
/* harmony export */   Fade: () => (/* binding */ Fade)
/* harmony export */ });
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_91771__(/*! ../../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_91771__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_91771__(/*! ../Action */ "./Actions/Action.ts");



class Fade {
    constructor(entity, endOpacity, duration) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__.GraphicsComponent);
        this._endOpacity = endOpacity;
        this._remainingTime = this._originalTime = duration;
    }
    update(elapsed) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            this._remainingTime = this._originalTime;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._remainingTime > 0) {
            this._graphics.opacity += (this._multiplier * (Math.abs(this._graphics.opacity - this._endOpacity) * elapsed)) / this._remainingTime;
        }
        this._remainingTime -= elapsed;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        _Util_Log__WEBPACK_IMPORTED_MODULE_2__.Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || this._remainingTime <= 0;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._remainingTime = this._originalTime;
    }
}


/***/ }),

/***/ "./Actions/Action/Flash.ts":
/*!*********************************!*\
  !*** ./Actions/Action/Flash.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_94269__) => {

__nested_webpack_require_94269__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_94269__.d(__nested_webpack_exports__, {
/* harmony export */   Flash: () => (/* binding */ Flash)
/* harmony export */ });
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_94269__(/*! ../../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_94269__(/*! ../Action */ "./Actions/Action.ts");


class Flash {
    constructor(entity, color, duration = 1000) {
        var _a;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._stopped = false;
        this._started = false;
        this._total = 0;
        this._currentDuration = 0;
        this._graphics = entity.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_1__.GraphicsComponent);
        this._duration = duration;
        this._entity = entity;
        this._material = (_a = entity.scene) === null || _a === void 0 ? void 0 : _a.engine.graphicsContext.createMaterial({
            name: 'flash-material',
            color,
            fragmentSource: `#version 300 es
    
        precision mediump float;
        uniform float u_blend;
        uniform sampler2D u_graphic;
        uniform vec4 u_color;
    
        in vec2 v_uv; 
        out vec4 color;
    
        void main() { 
            vec4 textureColor = texture(u_graphic, v_uv); 
            color = mix(textureColor, u_color, u_blend * textureColor.a);
            color.rgb = color.rgb * color.a;
        }`
        });
        this._total = duration;
    }
    update(elapsed) {
        var _a;
        if (!this._started) {
            this._started = true;
            this._total = this._duration;
            this._currentDuration = this._duration;
            this._entity.graphics.material = this._material;
        }
        if (!this._graphics) {
            return;
        }
        this._currentDuration -= elapsed;
        if (this._graphics) {
            (_a = this._material) === null || _a === void 0 ? void 0 : _a.update((shader) => {
                shader.trySetUniformFloat('u_blend', this._currentDuration / this._total);
            });
        }
        if (this.isComplete()) {
            this._entity.graphics.material = null;
        }
    }
    isComplete() {
        return this._stopped || this._currentDuration <= 0;
    }
    stop() {
        if (this._graphics) {
            this._graphics.isVisible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/Follow.ts":
/*!**********************************!*\
  !*** ./Actions/Action/Follow.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_97183__) => {

__nested_webpack_require_97183__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_97183__.d(__nested_webpack_exports__, {
/* harmony export */   Follow: () => (/* binding */ Follow)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_97183__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_97183__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_97183__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_97183__(/*! ../Action */ "./Actions/Action.ts");




class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._followTx = entityToFollow.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._followMotion = entityToFollow.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._current = new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._tx.pos.x, this._tx.pos.y);
        this._end = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(m.x, m.y);
        }
        else {
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        }
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/Meet.ts":
/*!********************************!*\
  !*** ./Actions/Action/Meet.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_101246__) => {

__nested_webpack_require_101246__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_101246__.d(__nested_webpack_exports__, {
/* harmony export */   Meet: () => (/* binding */ Meet)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_101246__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_101246__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_101246__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_101246__(/*! ../Action */ "./Actions/Action.ts");




class Meet {
    constructor(actor, actorToMeet, speed) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = actor.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._meetTx = actorToMeet.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._meetMotion = actorToMeet.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._current = new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._tx.pos.x, this._tx.pos.y);
        this._end = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._distanceBetween = Infinity;
    }
}


/***/ }),

/***/ "./Actions/Action/MoveBy.ts":
/*!**********************************!*\
  !*** ./Actions/Action/MoveBy.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_105124__) => {

__nested_webpack_require_105124__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_105124__.d(__nested_webpack_exports__, {
/* harmony export */   MoveBy: () => (/* binding */ MoveBy),
/* harmony export */   MoveByWithOptions: () => (/* binding */ MoveByWithOptions),
/* harmony export */   isMoveByOptions: () => (/* binding */ isMoveByOptions)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_105124__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_105124__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_105124__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_105124__(/*! ../../Math */ "./Math/lerp.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_105124__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_105124__(/*! ../../Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_105124__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_105124__(/*! ../Action */ "./Actions/Action.ts");







/**
 *
 */
function isMoveByOptions(x) {
    return x.offset instanceof _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector && typeof x.duration === 'number';
}
class MoveByWithOptions {
    constructor(entity, options) {
        var _a;
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_1__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._easing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_2__.EasingFunctions.Linear;
        this._offset = options.offset;
        this._easing = (_a = options.easing) !== null && _a !== void 0 ? _a : this._easing;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only MoveBy on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._start = this._tx.pos.clone();
            this._end = this._start.add(this._offset);
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_6__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const currentPos = this._tx.pos;
        const newPosX = this._easing(t, this._start.x, this._end.x, 1);
        const newPosY = this._easing(t, this._start.y, this._end.y, 1);
        const velX = (newPosX - currentPos.x) / (elapsed / 1000);
        const velY = (newPosY - currentPos.y) / (elapsed / 1000);
        this._motion.vel.x = velX;
        this._motion.vel.y = velY;
        if (this.isComplete(this.entity)) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        }
    }
    isComplete(entity) {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_1__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__.MotionComponent);
        this._speed = speed;
        this._offset = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(offsetX, offsetY);
        if (speed <= 0) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_7__.Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._start = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.magnitude;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/MoveTo.ts":
/*!**********************************!*\
  !*** ./Actions/Action/MoveTo.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_111685__) => {

__nested_webpack_require_111685__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_111685__.d(__nested_webpack_exports__, {
/* harmony export */   MoveTo: () => (/* binding */ MoveTo),
/* harmony export */   MoveToWithOptions: () => (/* binding */ MoveToWithOptions),
/* harmony export */   isMoveToOptions: () => (/* binding */ isMoveToOptions)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_111685__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_111685__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_111685__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_111685__(/*! ../../Math */ "./Math/lerp.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_111685__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_111685__(/*! ../../Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_111685__(/*! ../Action */ "./Actions/Action.ts");






/**
 *
 */
function isMoveToOptions(x) {
    return x.pos instanceof _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector && typeof x.duration === 'number';
}
class MoveToWithOptions {
    constructor(entity, options) {
        var _a;
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_1__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._easing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_2__.EasingFunctions.Linear;
        this._end = options.pos;
        this._easing = (_a = options.easing) !== null && _a !== void 0 ? _a : this._easing;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only moveTo on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._start = this._tx.pos.clone();
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_6__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const currentPos = this._tx.pos;
        const newPosX = this._easing(t, this._start.x, this._end.x, 1);
        const newPosY = this._easing(t, this._start.y, this._end.y, 1);
        const velX = (newPosX - currentPos.x) / (elapsed / 1000);
        const velY = (newPosY - currentPos.y) / (elapsed / 1000);
        this._motion.vel.x = velX;
        this._motion.vel.y = velY;
        if (this.isComplete(this.entity)) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        }
    }
    isComplete(entity) {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class MoveTo {
    constructor(entity, destX, destY, speed) {
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_1__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__.MotionComponent);
        this._end = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(destX, destY);
        this._speed = speed;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._start = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this._end.x, this._end.y);
            this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
        return this._stopped || new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/ParallelActions.ts":
/*!*******************************************!*\
  !*** ./Actions/Action/ParallelActions.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_117882__) => {

__nested_webpack_require_117882__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_117882__.d(__nested_webpack_exports__, {
/* harmony export */   ParallelActions: () => (/* binding */ ParallelActions)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_117882__(/*! ../Action */ "./Actions/Action.ts");

/**
 * Action that can run multiple {@apilink Action}s or {@apilink ActionSequence}s at the same time
 */
class ParallelActions {
    constructor(parallelActions) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._actions = parallelActions;
    }
    update(elapsed) {
        for (let i = 0; i < this._actions.length; i++) {
            this._actions[i].update(elapsed);
        }
    }
    isComplete(entity) {
        return this._actions.every((a) => a.isComplete(entity));
    }
    reset() {
        this._actions.forEach((a) => a.reset());
    }
    stop() {
        this._actions.forEach((a) => a.stop());
    }
}


/***/ }),

/***/ "./Actions/Action/Repeat.ts":
/*!**********************************!*\
  !*** ./Actions/Action/Repeat.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_119132__) => {

__nested_webpack_require_119132__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_119132__.d(__nested_webpack_exports__, {
/* harmony export */   Repeat: () => (/* binding */ Repeat)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_119132__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_119132__(/*! ../ActionContext */ "./Actions/ActionContext.ts");


class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new _ActionContext__WEBPACK_IMPORTED_MODULE_1__.ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(elapsed) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(elapsed);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}


/***/ }),

/***/ "./Actions/Action/RepeatForever.ts":
/*!*****************************************!*\
  !*** ./Actions/Action/RepeatForever.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_120927__) => {

__nested_webpack_require_120927__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_120927__.d(__nested_webpack_exports__, {
/* harmony export */   RepeatForever: () => (/* binding */ RepeatForever)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_120927__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_120927__(/*! ../ActionContext */ "./Actions/ActionContext.ts");


/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new _ActionContext__WEBPACK_IMPORTED_MODULE_1__.ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(elapsed) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(elapsed);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}


/***/ }),

/***/ "./Actions/Action/RotateBy.ts":
/*!************************************!*\
  !*** ./Actions/Action/RotateBy.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_122681__) => {

__nested_webpack_require_122681__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_122681__.d(__nested_webpack_exports__, {
/* harmony export */   RotateBy: () => (/* binding */ RotateBy),
/* harmony export */   RotateByWithOptions: () => (/* binding */ RotateByWithOptions),
/* harmony export */   isRotateByOptions: () => (/* binding */ isRotateByOptions)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_122681__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_122681__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_122681__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_122681__(/*! ../../Math/util */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_122681__(/*! ../../Math */ "./Math/rotation-type.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_122681__(/*! ../../Math */ "./Math/lerp.ts");





/**
 *
 */
function isRotateByOptions(x) {
    return typeof x.angleRadiansOffset === 'number' && typeof x.duration === 'number';
}
class RotateByWithOptions {
    constructor(entity, options) {
        var _a;
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._offset = 0;
        this._startAngle = 0;
        this._endAngle = 0;
        this._offset = options.angleRadiansOffset;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only RotateBy on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._rotationType = (_a = options.rotationType) !== null && _a !== void 0 ? _a : _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._startAngle = this._tx.rotation;
            this._endAngle = (0,_Math_util__WEBPACK_IMPORTED_MODULE_4__.canonicalizeAngle)(this._startAngle + this._offset);
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math_util__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const newAngle = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.lerpAngle)(this._startAngle, this._endAngle, this._rotationType, t);
        const currentAngle = this._tx.rotation;
        const rx = (newAngle - currentAngle) / (elapsed / 1000);
        this._motion.angularVelocity = rx;
        if (this.isComplete()) {
            this._tx.rotation = this._endAngle;
            this._motion.angularVelocity = 0;
        }
    }
    isComplete() {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI) % _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI >= Math.PI;
            switch (this._rotationType) {
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (elapsed / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._start = undefined;
        this._currentNonCannonAngle = undefined;
        this._distance = undefined;
    }
}


/***/ }),

/***/ "./Actions/Action/RotateTo.ts":
/*!************************************!*\
  !*** ./Actions/Action/RotateTo.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_130730__) => {

__nested_webpack_require_130730__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_130730__.d(__nested_webpack_exports__, {
/* harmony export */   RotateTo: () => (/* binding */ RotateTo),
/* harmony export */   RotateToWithOptions: () => (/* binding */ RotateToWithOptions),
/* harmony export */   isRotateToOptions: () => (/* binding */ isRotateToOptions)
/* harmony export */ });
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_130730__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_130730__(/*! ../../Math */ "./Math/rotation-type.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_130730__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_130730__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_130730__(/*! ../../Math/util */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_130730__(/*! ../../Math */ "./Math/lerp.ts");






/**
 *
 */
function isRotateToOptions(x) {
    return typeof x.angle === 'number' && typeof x.duration === 'number';
}
class RotateToWithOptions {
    constructor(entity, options) {
        var _a;
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._endAngle = 0;
        this._startAngle = 0;
        this._endAngle = options.angle;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only RotateTo on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._rotationType = (_a = options.rotationType) !== null && _a !== void 0 ? _a : _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._startAngle = this._tx.rotation;
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math_util__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const newAngle = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.lerpAngle)(this._startAngle, this._endAngle, this._rotationType, t);
        const currentAngle = this._tx.rotation;
        const rx = (newAngle - currentAngle) / (elapsed / 1000);
        this._motion.angularVelocity = rx;
        if (this.isComplete(this.entity)) {
            this._tx.rotation = this._endAngle;
            this._motion.angularVelocity = 0;
        }
    }
    isComplete(entity) {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class RotateTo {
    constructor(entity, angle, speed, rotationType) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
        this._end = angle;
        this._speed = speed;
        this._rotationType = rotationType || _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI) % _Math_util__WEBPACK_IMPORTED_MODULE_4__.TwoPI >= Math.PI;
            switch (this._rotationType) {
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case _Math__WEBPACK_IMPORTED_MODULE_3__.RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (elapsed / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/ScaleBy.ts":
/*!***********************************!*\
  !*** ./Actions/Action/ScaleBy.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_138428__) => {

__nested_webpack_require_138428__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_138428__.d(__nested_webpack_exports__, {
/* harmony export */   ScaleBy: () => (/* binding */ ScaleBy),
/* harmony export */   ScaleByWithOptions: () => (/* binding */ ScaleByWithOptions),
/* harmony export */   isScaleByOptions: () => (/* binding */ isScaleByOptions)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_138428__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_138428__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_138428__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_138428__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_138428__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_138428__(/*! ../../Math */ "./Math/lerp.ts");





/**
 *
 */
function isScaleByOptions(x) {
    return typeof x.scaleOffset === 'object' && typeof x.duration === 'number';
}
class ScaleByWithOptions {
    constructor(entity, options) {
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._endScale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1);
        this._scaleOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._startScale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1);
        this._scaleOffset = options.scaleOffset;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only ScaleBy on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._startScale = this._tx.scale;
            this._endScale = this._startScale.add(this._scaleOffset);
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const newScale = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.lerpVector)(this._startScale, this._endScale, t);
        const currentScale = this._tx.scale;
        const sx = newScale.sub(currentScale).scale(1 / (elapsed / 1000));
        this._motion.scaleFactor = sx;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.angularVelocity = 0;
        }
    }
    isComplete() {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.scaleFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        this._offset = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX - 0.01 &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY - 0.01));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/Action/ScaleTo.ts":
/*!***********************************!*\
  !*** ./Actions/Action/ScaleTo.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_144387__) => {

__nested_webpack_require_144387__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_144387__.d(__nested_webpack_exports__, {
/* harmony export */   ScaleTo: () => (/* binding */ ScaleTo),
/* harmony export */   ScaleToWithOptions: () => (/* binding */ ScaleToWithOptions),
/* harmony export */   isScaleToOptions: () => (/* binding */ isScaleToOptions)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_144387__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_144387__(/*! ../../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_144387__(/*! ../../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_144387__(/*! ../Action */ "./Actions/Action.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_144387__(/*! ../../Math */ "./Math/util.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_144387__(/*! ../../Math */ "./Math/lerp.ts");





/**
 *
 */
function isScaleToOptions(x) {
    return typeof x.scale === 'object' && typeof x.duration === 'number';
}
class ScaleToWithOptions {
    constructor(entity, options) {
        this.entity = entity;
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._endScale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1);
        this._startScale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1);
        this._endScale = options.scale;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        if (!this._tx) {
            throw new Error(`Entity ${entity.name} has no TransformComponent, can only ScaleTo on Entities with TransformComponents.`);
        }
        this._durationMs = options.duration;
        this._currentMs = this._durationMs;
    }
    update(elapsed) {
        if (!this._started) {
            this._startScale = this._tx.scale;
            this._started = true;
        }
        this._currentMs -= elapsed;
        const t = (0,_Math__WEBPACK_IMPORTED_MODULE_4__.clamp)((0,_Math__WEBPACK_IMPORTED_MODULE_5__.remap)(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
        const newScale = (0,_Math__WEBPACK_IMPORTED_MODULE_5__.lerpVector)(this._startScale, this._endScale, t);
        const currentScale = this._tx.scale;
        const sx = newScale.sub(currentScale).scale(1 / (elapsed / 1000));
        this._motion.scaleFactor = sx;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.angularVelocity = 0;
        }
    }
    isComplete() {
        return this._stopped || this._currentMs < 0;
    }
    stop() {
        this._motion.scaleFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        this._stopped = true;
        this._currentMs = 0;
    }
    reset() {
        this._currentMs = this._durationMs;
        this._started = false;
        this._stopped = false;
    }
}
class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this.id = (0,_Action__WEBPACK_IMPORTED_MODULE_0__.nextActionId)();
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_3__.MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(elapsed) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startX) >= this._distanceX - 0.01 &&
                Math.abs(this._tx.scale.y - this._startY) >= this._distanceY - 0.01));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}


/***/ }),

/***/ "./Actions/ActionsComponent.ts":
/*!*************************************!*\
  !*** ./Actions/ActionsComponent.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_150432__) => {

__nested_webpack_require_150432__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_150432__.d(__nested_webpack_exports__, {
/* harmony export */   ActionsComponent: () => (/* binding */ ActionsComponent)
/* harmony export */ });
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_150432__(/*! ./ActionContext */ "./Actions/ActionContext.ts");
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_150432__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_150432__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_150432__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");




class ActionsComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor() {
        super(...arguments);
        this.dependencies = [_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent, _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent];
        this._ctx = null;
    }
    onAdd(entity) {
        this._ctx = new _ActionContext__WEBPACK_IMPORTED_MODULE_3__.ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    _getCtx() {
        if (!this._ctx) {
            throw new Error('Actions component not attached to an entity, no context available');
        }
        return this._ctx;
    }
    /**
     * Returns the internal action queue
     * @returns action queue
     */
    getQueue() {
        if (!this._ctx) {
            throw new Error('Actions component not attached to an entity, no queue available');
        }
        return this._ctx.getQueue();
    }
    /**
     * Runs a specific action in the action queue
     * @param action
     */
    runAction(action) {
        if (!this._ctx) {
            throw new Error('Actions component not attached to an entity, cannot run action');
        }
        return this._ctx.runAction(action);
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsed
     */
    update(elapsed) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsed);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    /**
     * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
     * to be the actors current position
     * @param options
     */
    curveBy(options) {
        return this._getCtx().curveBy.apply(this._ctx, [options]);
    }
    /**
     * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
     * to be the actors current position
     * @param options
     */
    curveTo(options) {
        return this._getCtx().curveTo.apply(this._ctx, [options]);
    }
    easeTo(...args) {
        return this._getCtx().easeTo.apply(this._ctx, args);
    }
    easeBy(...args) {
        return this._getCtx().easeBy.apply(this._ctx, args);
    }
    moveTo(xOrPosOrOptions, yOrSpeed, speedOrUndefined) {
        return this._getCtx().moveTo.apply(this._ctx, [xOrPosOrOptions, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVectorOptions, yOffsetOrSpeed, speedOrUndefined) {
        return this._getCtx().moveBy.apply(this._ctx, [xOffsetOrVectorOptions, yOffsetOrSpeed, speedOrUndefined]);
    }
    rotateTo(angle, speed, rotationType) {
        return this._getCtx().rotateTo.apply(this._ctx, [angle, speed, rotationType]);
    }
    rotateBy(angleRadiansOffsetOrOptions, speed, rotationType) {
        return this._getCtx().rotateBy.apply(this._ctx, [angleRadiansOffsetOrOptions, speed, rotationType]);
    }
    scaleTo(sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._getCtx().scaleTo.apply(this._ctx, [sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed) {
        return this._getCtx().scaleBy.apply(this._ctx, [sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._getCtx().blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param duration     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, duration) {
        return this._getCtx().fade(opacity, duration);
    }
    /**
     * This will cause an actor to flash a specific color for a period of time
     * @param color
     * @param duration The duration in milliseconds
     */
    flash(color, duration = 1000) {
        return this._getCtx().flash(color, duration);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(duration) {
        return this._getCtx().delay(duration);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._getCtx().die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._getCtx().callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     * repeatCtx.moveBy(10, 0, 10);
     * repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._getCtx().repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     * repeatCtx.moveBy(10, 0, 10);
     * repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._getCtx().repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._getCtx().follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._getCtx().meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._getCtx().toPromise();
    }
}


/***/ }),

/***/ "./Actions/ActionsSystem.ts":
/*!**********************************!*\
  !*** ./Actions/ActionsSystem.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_160386__) => {

__nested_webpack_require_160386__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_160386__.d(__nested_webpack_exports__, {
/* harmony export */   ActionsSystem: () => (/* binding */ ActionsSystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_160386__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_160386__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _ActionsComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_160386__(/*! ./ActionsComponent */ "./Actions/ActionsComponent.ts");



class ActionsSystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Update;
        this._actions = [];
        this.query = this.world.query([_ActionsComponent__WEBPACK_IMPORTED_MODULE_1__.ActionsComponent]);
        this.query.entityAdded$.subscribe((e) => this._actions.push(e.get(_ActionsComponent__WEBPACK_IMPORTED_MODULE_1__.ActionsComponent)));
        this.query.entityRemoved$.subscribe((e) => {
            const action = e.get(_ActionsComponent__WEBPACK_IMPORTED_MODULE_1__.ActionsComponent);
            const index = this._actions.indexOf(action);
            if (index > -1) {
                this._actions.splice(index, 1);
            }
        });
    }
    update(elapsed) {
        for (let i = 0; i < this._actions.length; i++) {
            const action = this._actions[i];
            action.update(elapsed);
        }
    }
}
ActionsSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_2__.SystemPriority.Higher;


/***/ }),

/***/ "./Actions/index.ts":
/*!**************************!*\
  !*** ./Actions/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_162466__) => {

__nested_webpack_require_162466__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_162466__.d(__nested_webpack_exports__, {
/* harmony export */   ActionContext: () => (/* reexport safe */ _ActionContext__WEBPACK_IMPORTED_MODULE_0__.ActionContext),
/* harmony export */   ActionQueue: () => (/* reexport safe */ _ActionQueue__WEBPACK_IMPORTED_MODULE_1__.ActionQueue),
/* harmony export */   ActionSequence: () => (/* reexport safe */ _Action_ActionSequence__WEBPACK_IMPORTED_MODULE_3__.ActionSequence),
/* harmony export */   ActionsComponent: () => (/* reexport safe */ _ActionsComponent__WEBPACK_IMPORTED_MODULE_24__.ActionsComponent),
/* harmony export */   ActionsSystem: () => (/* reexport safe */ _ActionsSystem__WEBPACK_IMPORTED_MODULE_25__.ActionsSystem),
/* harmony export */   Blink: () => (/* reexport safe */ _Action_Blink__WEBPACK_IMPORTED_MODULE_7__.Blink),
/* harmony export */   CurveBy: () => (/* reexport safe */ _Action_CurveBy__WEBPACK_IMPORTED_MODULE_23__.CurveBy),
/* harmony export */   CurveTo: () => (/* reexport safe */ _Action_CurveTo__WEBPACK_IMPORTED_MODULE_22__.CurveTo),
/* harmony export */   Delay: () => (/* reexport safe */ _Action_Delay__WEBPACK_IMPORTED_MODULE_20__.Delay),
/* harmony export */   Die: () => (/* reexport safe */ _Action_Die__WEBPACK_IMPORTED_MODULE_8__.Die),
/* harmony export */   EaseBy: () => (/* reexport safe */ _Action_EaseBy__WEBPACK_IMPORTED_MODULE_10__.EaseBy),
/* harmony export */   EaseTo: () => (/* reexport safe */ _Action_EaseTo__WEBPACK_IMPORTED_MODULE_9__.EaseTo),
/* harmony export */   Fade: () => (/* reexport safe */ _Action_Fade__WEBPACK_IMPORTED_MODULE_11__.Fade),
/* harmony export */   Flash: () => (/* reexport safe */ _Action_Flash__WEBPACK_IMPORTED_MODULE_21__.Flash),
/* harmony export */   Follow: () => (/* reexport safe */ _Action_Follow__WEBPACK_IMPORTED_MODULE_12__.Follow),
/* harmony export */   Meet: () => (/* reexport safe */ _Action_Meet__WEBPACK_IMPORTED_MODULE_13__.Meet),
/* harmony export */   MoveBy: () => (/* reexport safe */ _Action_MoveBy__WEBPACK_IMPORTED_MODULE_14__.MoveBy),
/* harmony export */   MoveByWithOptions: () => (/* reexport safe */ _Action_MoveBy__WEBPACK_IMPORTED_MODULE_14__.MoveByWithOptions),
/* harmony export */   MoveTo: () => (/* reexport safe */ _Action_MoveTo__WEBPACK_IMPORTED_MODULE_15__.MoveTo),
/* harmony export */   MoveToWithOptions: () => (/* reexport safe */ _Action_MoveTo__WEBPACK_IMPORTED_MODULE_15__.MoveToWithOptions),
/* harmony export */   ParallelActions: () => (/* reexport safe */ _Action_ParallelActions__WEBPACK_IMPORTED_MODULE_4__.ParallelActions),
/* harmony export */   Repeat: () => (/* reexport safe */ _Action_Repeat__WEBPACK_IMPORTED_MODULE_5__.Repeat),
/* harmony export */   RepeatForever: () => (/* reexport safe */ _Action_RepeatForever__WEBPACK_IMPORTED_MODULE_6__.RepeatForever),
/* harmony export */   RotateBy: () => (/* reexport safe */ _Action_RotateBy__WEBPACK_IMPORTED_MODULE_16__.RotateBy),
/* harmony export */   RotateByWithOptions: () => (/* reexport safe */ _Action_RotateBy__WEBPACK_IMPORTED_MODULE_16__.RotateByWithOptions),
/* harmony export */   RotateTo: () => (/* reexport safe */ _Action_RotateTo__WEBPACK_IMPORTED_MODULE_17__.RotateTo),
/* harmony export */   RotateToWithOptions: () => (/* reexport safe */ _Action_RotateTo__WEBPACK_IMPORTED_MODULE_17__.RotateToWithOptions),
/* harmony export */   ScaleBy: () => (/* reexport safe */ _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_18__.ScaleBy),
/* harmony export */   ScaleByWithOptions: () => (/* reexport safe */ _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_18__.ScaleByWithOptions),
/* harmony export */   ScaleTo: () => (/* reexport safe */ _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_19__.ScaleTo),
/* harmony export */   ScaleToWithOptions: () => (/* reexport safe */ _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_19__.ScaleToWithOptions),
/* harmony export */   isMoveByOptions: () => (/* reexport safe */ _Action_MoveBy__WEBPACK_IMPORTED_MODULE_14__.isMoveByOptions),
/* harmony export */   isMoveToOptions: () => (/* reexport safe */ _Action_MoveTo__WEBPACK_IMPORTED_MODULE_15__.isMoveToOptions),
/* harmony export */   isRotateByOptions: () => (/* reexport safe */ _Action_RotateBy__WEBPACK_IMPORTED_MODULE_16__.isRotateByOptions),
/* harmony export */   isRotateToOptions: () => (/* reexport safe */ _Action_RotateTo__WEBPACK_IMPORTED_MODULE_17__.isRotateToOptions),
/* harmony export */   isScaleByOptions: () => (/* reexport safe */ _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_18__.isScaleByOptions),
/* harmony export */   isScaleToOptions: () => (/* reexport safe */ _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_19__.isScaleToOptions),
/* harmony export */   nextActionId: () => (/* reexport safe */ _Action__WEBPACK_IMPORTED_MODULE_2__.nextActionId)
/* harmony export */ });
/* harmony import */ var _ActionContext__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_162466__(/*! ./ActionContext */ "./Actions/ActionContext.ts");
/* harmony import */ var _ActionQueue__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_162466__(/*! ./ActionQueue */ "./Actions/ActionQueue.ts");
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_162466__(/*! ./Action */ "./Actions/Action.ts");
/* harmony import */ var _Action_ActionSequence__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_162466__(/*! ./Action/ActionSequence */ "./Actions/Action/ActionSequence.ts");
/* harmony import */ var _Action_ParallelActions__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_162466__(/*! ./Action/ParallelActions */ "./Actions/Action/ParallelActions.ts");
/* harmony import */ var _Action_Repeat__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_162466__(/*! ./Action/Repeat */ "./Actions/Action/Repeat.ts");
/* harmony import */ var _Action_RepeatForever__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_162466__(/*! ./Action/RepeatForever */ "./Actions/Action/RepeatForever.ts");
/* harmony import */ var _Action_Blink__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_162466__(/*! ./Action/Blink */ "./Actions/Action/Blink.ts");
/* harmony import */ var _Action_Die__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_162466__(/*! ./Action/Die */ "./Actions/Action/Die.ts");
/* harmony import */ var _Action_EaseTo__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_162466__(/*! ./Action/EaseTo */ "./Actions/Action/EaseTo.ts");
/* harmony import */ var _Action_EaseBy__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_162466__(/*! ./Action/EaseBy */ "./Actions/Action/EaseBy.ts");
/* harmony import */ var _Action_Fade__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_162466__(/*! ./Action/Fade */ "./Actions/Action/Fade.ts");
/* harmony import */ var _Action_Follow__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_162466__(/*! ./Action/Follow */ "./Actions/Action/Follow.ts");
/* harmony import */ var _Action_Meet__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_162466__(/*! ./Action/Meet */ "./Actions/Action/Meet.ts");
/* harmony import */ var _Action_MoveBy__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_162466__(/*! ./Action/MoveBy */ "./Actions/Action/MoveBy.ts");
/* harmony import */ var _Action_MoveTo__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_162466__(/*! ./Action/MoveTo */ "./Actions/Action/MoveTo.ts");
/* harmony import */ var _Action_RotateBy__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_162466__(/*! ./Action/RotateBy */ "./Actions/Action/RotateBy.ts");
/* harmony import */ var _Action_RotateTo__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_162466__(/*! ./Action/RotateTo */ "./Actions/Action/RotateTo.ts");
/* harmony import */ var _Action_ScaleBy__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_162466__(/*! ./Action/ScaleBy */ "./Actions/Action/ScaleBy.ts");
/* harmony import */ var _Action_ScaleTo__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_162466__(/*! ./Action/ScaleTo */ "./Actions/Action/ScaleTo.ts");
/* harmony import */ var _Action_Delay__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_162466__(/*! ./Action/Delay */ "./Actions/Action/Delay.ts");
/* harmony import */ var _Action_Flash__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_162466__(/*! ./Action/Flash */ "./Actions/Action/Flash.ts");
/* harmony import */ var _Action_CurveTo__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_162466__(/*! ./Action/CurveTo */ "./Actions/Action/CurveTo.ts");
/* harmony import */ var _Action_CurveBy__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_162466__(/*! ./Action/CurveBy */ "./Actions/Action/CurveBy.ts");
/* harmony import */ var _ActionsComponent__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_162466__(/*! ./ActionsComponent */ "./Actions/ActionsComponent.ts");
/* harmony import */ var _ActionsSystem__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_162466__(/*! ./ActionsSystem */ "./Actions/ActionsSystem.ts");





























/***/ }),

/***/ "./Actor.ts":
/*!******************!*\
  !*** ./Actor.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_171298__) => {

__nested_webpack_require_171298__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_171298__.d(__nested_webpack_exports__, {
/* harmony export */   Actor: () => (/* binding */ Actor),
/* harmony export */   ActorEvents: () => (/* binding */ ActorEvents),
/* harmony export */   isActor: () => (/* binding */ isActor)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_171298__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_171298__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_171298__(/*! ./Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_171298__(/*! ./Collision/BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_171298__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_171298__(/*! ./EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_171298__(/*! ./EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_171298__(/*! ./EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_171298__(/*! ./Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Graphics_Rectangle__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_171298__(/*! ./Graphics/Rectangle */ "./Graphics/Rectangle.ts");
/* harmony import */ var _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_171298__(/*! ./Collision/ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _Collision_Colliders_Shape__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_171298__(/*! ./Collision/Colliders/Shape */ "./Collision/Colliders/Shape.ts");
/* harmony import */ var _Util_Watch__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_171298__(/*! ./Util/Watch */ "./Util/Watch.ts");
/* harmony import */ var _Graphics_Circle__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_171298__(/*! ./Graphics/Circle */ "./Graphics/Circle.ts");
/* harmony import */ var _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_171298__(/*! ./Input/PointerComponent */ "./Input/PointerComponent.ts");
/* harmony import */ var _Actions_ActionsComponent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_171298__(/*! ./Actions/ActionsComponent */ "./Actions/ActionsComponent.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_171298__(/*! ./Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_171298__(/*! ./EventEmitter */ "./EventEmitter.ts");


















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
const ActorEvents = {
    CollisionStart: 'collisionstart',
    CollisionEnd: 'collisionend',
    PreCollision: 'precollision',
    PostCollision: 'postcollision',
    Kill: 'kill',
    PreKill: 'prekill',
    PostKill: 'postkill',
    PreDraw: 'predraw',
    PostDraw: 'postdraw',
    PreTransformDraw: 'pretransformdraw',
    PostTransformDraw: 'posttransformdraw',
    PreDebugDraw: 'predebugdraw',
    PostDebugDraw: 'postdebugdraw',
    PointerUp: 'pointerup',
    PointerDown: 'pointerdown',
    PointerEnter: 'pointerenter',
    PointerLeave: 'pointerleave',
    PointerMove: 'pointermove',
    PointerCancel: 'pointercancel',
    Wheel: 'pointerwheel',
    PointerDrag: 'pointerdragstart',
    PointerDragEnd: 'pointerdragend',
    PointerDragEnter: 'pointerdragenter',
    PointerDragLeave: 'pointerdragleave',
    PointerDragMove: 'pointerdragmove',
    EnterViewPort: 'enterviewport',
    ExitViewPort: 'exitviewport',
    ActionStart: 'actionstart',
    ActionComplete: 'actioncomplete'
};
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a {@apilink Scene} for it to be drawn to the screen.
 */
class Actor extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Gets the global position vector of the actor from the last frame
     */
    get oldGlobalPos() {
        return this.body.oldGlobalPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).scale;
    }
    set scale(scale) {
        this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).scale = scale;
    }
    /**
     * The anchor to apply all actor related transformations like rotation,
     * translation, and scaling. By default the anchor is in the center of
     * the actor. By default it is set to the center of the actor (.5, .5)
     *
     * An anchor of (.5, .5) will ensure that drawings are centered.
     *
     * Use `anchor.setTo` to set the anchor to a different point using
     * values between 0 and 1. For example, anchoring to the top-left would be
     * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
     */
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * The offset in pixels to apply to all actor graphics
     *
     * Default offset of (0, 0)
     */
    get offset() {
        return this._offset;
    }
    set offset(vec) {
        this._offset = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(vec, (v) => this._handleOffsetChange(v));
        this._handleOffsetChange(vec);
    }
    _handleOffsetChange(v) {
        if (this.graphics) {
            this.graphics.offset = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('ex.offscreen');
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.events.on('pointerdragstart', this._pointerDragStartHandler);
                this.events.on('pointerdragend', this._pointerDragEndHandler);
                this.events.on('pointerdragmove', this._pointerDragMoveHandler);
                this.events.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.events.off('pointerdragstart', this._pointerDragStartHandler);
                this.events.off('pointerdragend', this._pointerDragEndHandler);
                this.events.off('pointerdragmove', this._pointerDragMoveHandler);
                this.events.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor's current graphic
     */
    get color() {
        return this.graphics.color;
    }
    set color(v) {
        this.graphics.color = v;
    }
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
        this._anchor = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Half, (v) => this._handleAnchorChange(v));
        this._offset = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero, (v) => this._handleOffsetChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_5__.Logger.getInstance();
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        const { name, x, y, pos, coordPlane, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, opacity, anchor, offset, collisionType, collisionGroup, silenceWarnings } = {
            ...config
        };
        this.name = name !== null && name !== void 0 ? name : this.name;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        this.offset = offset !== null && offset !== void 0 ? offset : _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero;
        this.transform = new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent();
        this.addComponent(this.transform);
        this.pos = pos !== null && pos !== void 0 ? pos : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.transform.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.World;
        this._silenceWarnings = silenceWarnings !== null && silenceWarnings !== void 0 ? silenceWarnings : false;
        this.pointer = new _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_7__.PointerComponent();
        this.addComponent(this.pointer);
        this.graphics = new _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_8__.GraphicsComponent({
            anchor: this.anchor,
            offset: this.offset,
            opacity: opacity
        });
        this.addComponent(this.graphics);
        this.motion = new _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_9__.MotionComponent();
        this.addComponent(this.motion);
        this.vel = vel !== null && vel !== void 0 ? vel : _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.actions = new _Actions_ActionsComponent__WEBPACK_IMPORTED_MODULE_10__.ActionsComponent();
        this.addComponent(this.actions);
        this.body = new _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_11__.BodyComponent();
        this.addComponent(this.body);
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_12__.CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (color) {
            this.color = color;
        }
        if (collider) {
            this.collider = new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent(collider);
            this.addComponent(this.collider);
        }
        else if (radius) {
            this.collider = new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent(_Collision_Colliders_Shape__WEBPACK_IMPORTED_MODULE_14__.Shape.Circle(radius));
            this.addComponent(this.collider);
            if (color) {
                this.graphics.add(new _Graphics_Circle__WEBPACK_IMPORTED_MODULE_15__.Circle({
                    color: color,
                    radius
                }));
            }
        }
        else {
            if (width > 0 && height > 0) {
                this.collider = new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent(_Collision_Colliders_Shape__WEBPACK_IMPORTED_MODULE_14__.Shape.Box(width, height, this.anchor));
                this.addComponent(this.collider);
                if (color && width && height) {
                    this.graphics.add(new _Graphics_Rectangle__WEBPACK_IMPORTED_MODULE_16__.Rectangle({
                        color: color,
                        width,
                        height
                    }));
                }
            }
            else {
                this.collider = new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent();
                this.addComponent(this.collider); // no collider
            }
        }
        this.graphics.isVisible = visible !== null && visible !== void 0 ? visible : true;
    }
    clone() {
        const clone = new Actor({
            silenceWarnings: this._silenceWarnings,
            color: this.color.clone(),
            anchor: this.anchor.clone(),
            offset: this.offset.clone()
        });
        clone.clearComponents();
        clone.processComponentRemoval();
        // Clone builtins, order is important, same as ctor
        clone.addComponent((clone.transform = this.transform.clone()), true);
        clone.addComponent((clone.pointer = this.pointer.clone()), true);
        clone.addComponent((clone.graphics = this.graphics.clone()), true);
        clone.addComponent((clone.motion = this.motion.clone()), true);
        clone.addComponent((clone.actions = this.actions.clone()), true);
        clone.addComponent((clone.body = this.body.clone()), true);
        clone.addComponent((clone.collider = this.collider.clone()), true);
        const builtInComponents = [
            this.transform,
            this.pointer,
            this.graphics,
            this.motion,
            this.actions,
            this.body,
            this.collider
        ];
        // Clone non-builtin the current actors components
        const components = this.getComponents();
        for (const c of components) {
            if (!builtInComponents.includes(c)) {
                clone.addComponent(c.clone(), true);
            }
        }
        return clone;
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for {@apilink onPreKill} lifecycle event
     * @internal
     */
    _prekill(scene) {
        this.events.emit('prekill', new _Events__WEBPACK_IMPORTED_MODULE_17__.PreKillEvent(this));
        this.onPreKill(scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current {@apilink Scene}.
     */
    onPreKill(scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for {@apilink onPostKill} lifecycle event
     * @internal
     */
    _postkill(scene) {
        this.events.emit('postkill', new _Events__WEBPACK_IMPORTED_MODULE_17__.PostKillEvent(this));
        this.onPostKill(scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current {@apilink Scene}.
     */
    onPostKill(scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.events.emit('kill', new _Events__WEBPACK_IMPORTED_MODULE_17__.KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn(`Cannot kill actor named "${this.name}", it was never added to the Scene`);
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.isActive = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.isActive;
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).z = newZ;
    }
    /**
     * Get the center point of an actor (global position)
     */
    get center() {
        const globalPos = this.getGlobalPos();
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);
    }
    /**
     * Get the local center point of an actor
     */
    get localCenter() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     * @returns Rotation angle in radians
     * @deprecated Use {@apilink globalRotation} instead
     */
    getGlobalRotation() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalRotation;
    }
    /**
     * The actor's rotation (in radians) taking into account any parent relationships
     */
    get globalRotation() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     * @returns Position in world coordinates
     * @deprecated Use {@apilink globalPos} instead
     */
    getGlobalPos() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalPos;
    }
    /**
     * The actor's world position taking into account parent relationships, scaling, rotation, and translation
     */
    get globalPos() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     * @deprecated Use {@apilink globalScale} instead
     */
    getGlobalScale() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalScale;
    }
    /**
     * The global scale of the Actor
     */
    get globalScale() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalScale;
    }
    /**
     * The global z-index of the actor
     */
    get globalZ() {
        return this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).globalZ;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(x, y);
        const collider = this.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent);
        const otherCollider = actor.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_13__.ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    update(engine, elapsed) {
        this._initialize(engine);
        this._add(engine);
        this._preupdate(engine, elapsed);
        this._postupdate(engine, elapsed);
        this._remove(engine);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPreUpdate(engine, elapsed) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPostUpdate(engine, elapsed) {
        // Override me
    }
    /**
     * Fires before every collision resolution for a confirmed contact
     * @param self
     * @param other
     * @param side
     * @param contact
     */
    onPreCollisionResolve(self, other, side, contact) {
        // Override me
    }
    /**
     * Fires after every resolution for a confirmed contact.
     * @param self
     * @param other
     * @param side
     * @param contact
     */
    onPostCollisionResolve(self, other, side, contact) {
        // Override me
    }
    /**
     * Fires once when 2 entities with a ColliderComponent first start colliding or touching, if the Colliders stay in contact this
     * does not continue firing until they separate and re-collide.
     * @param self
     * @param other
     * @param side
     * @param contact
     */
    onCollisionStart(self, other, side, contact) {
        // Override me
    }
    /**
     * Fires once when 2 entities with a ColliderComponent separate after having been in contact.
     * @param self
     * @param other
     * @param side
     * @param lastContact
     */
    onCollisionEnd(self, other, side, lastContact) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     * @internal
     */
    _preupdate(engine, elapsed) {
        this.events.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_17__.PreUpdateEvent(engine, elapsed, this));
        this.onPreUpdate(engine, elapsed);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     * @internal
     */
    _postupdate(engine, elapsed) {
        this.events.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_17__.PostUpdateEvent(engine, elapsed, this));
        this.onPostUpdate(engine, elapsed);
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Half
};


/***/ }),

/***/ "./Camera.ts":
/*!*******************!*\
  !*** ./Camera.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_201707__) => {

__nested_webpack_require_201707__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_201707__.d(__nested_webpack_exports__, {
/* harmony export */   Axis: () => (/* binding */ Axis),
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   CameraEvents: () => (/* binding */ CameraEvents),
/* harmony export */   ElasticToActorStrategy: () => (/* binding */ ElasticToActorStrategy),
/* harmony export */   LimitCameraBoundsStrategy: () => (/* binding */ LimitCameraBoundsStrategy),
/* harmony export */   LockCameraToActorAxisStrategy: () => (/* binding */ LockCameraToActorAxisStrategy),
/* harmony export */   LockCameraToActorStrategy: () => (/* binding */ LockCameraToActorStrategy),
/* harmony export */   RadiusAroundActorStrategy: () => (/* binding */ RadiusAroundActorStrategy),
/* harmony export */   StrategyContainer: () => (/* binding */ StrategyContainer)
/* harmony export */ });
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_201707__(/*! ./Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_201707__(/*! ./Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_201707__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_201707__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_201707__(/*! ./Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_201707__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_201707__(/*! ./Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_201707__(/*! ./EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_201707__(/*! ./Graphics */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_201707__(/*! ./Math/util */ "./Math/util.ts");
/* harmony import */ var _Math_watch_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_201707__(/*! ./Math/watch-vector */ "./Math/watch-vector.ts");











/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the {@apilink LockCameraToActorStrategy} on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the {@apilink LockCameraToActorAxisStrategy} on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the {@apilink ElasticToActorStrategy} on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the {@apilink RadiusAroundActorStrategy} on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the {@apilink LimitCameraBoundsStrategy} on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, camera, engine, elapsed) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, elapsed) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(center.x, currentFocus.y);
            }
            else {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, elapsed) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, elapsed) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.magnitude;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a {@apilink TileMap}'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, elapsed) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(focusX, focusY);
        };
    }
}
const CameraEvents = {
    Initialize: 'initialize',
    PreUpdate: 'preupdate',
    PostUpdate: 'postupdate'
};
/**
 * Cameras
 *
 * {@apilink Camera} is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera {
    constructor() {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();
        this.transform = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
        this.inverse = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        this._angularVelocity = 0;
        this._posChanged = false;
        this._pos = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_4__.WatchVector(_Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero, () => {
            this._posChanged = true;
        });
        /**
         * Interpolated camera position if more draws are running than updates
         *
         * Enabled when `Engine.fixedUpdateFps` is enabled, in all other cases this will be the same as pos
         */
        this.drawPos = this.pos.clone();
        this._oldPos = this.pos.clone();
        /**
         * Get or set the camera's velocity
         */
        this.vel = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero;
        /**
         * Get or set the camera's acceleration
         */
        this.acc = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.EaseInOutCubic;
        this._easing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
        this._snapPos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this._angularVelocity;
    }
    set angularVelocity(value) {
        this._angularVelocity = value;
    }
    /**
     * Get or set the camera's position
     */
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._posChanged = true;
        this._pos = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_4__.WatchVector(vec, () => {
            this._posChanged = true;
        });
    }
    /**
     * Has the position changed since the last update
     */
    hasChanged() {
        return this._posChanged;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an {@apilink Actor} or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an {@apilink Actor} or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ({@apilink EasingFunctions.EaseInOutCubic} by default)
     * @returns A {@apilink Promise} that resolves when movement is finished, including if it's interrupted.
     *          The {@apilink Promise} value is the {@apilink Vector} of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an {@apilink CameraStrategy}
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an {@apilink CameraStrategy}
     */
    removeStrategy(cameraStrategy) {
        (0,_Util_Util__WEBPACK_IMPORTED_MODULE_7__.removeItemFromArray)(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     * @internal
     */
    _preupdate(engine, elapsed) {
        this.events.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_8__.PreUpdateEvent(engine, elapsed, this));
        this.onPreUpdate(engine, elapsed);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPreUpdate(engine, elapsed) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     * @internal
     */
    _postupdate(engine, elapsed) {
        this.events.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_8__.PostUpdateEvent(engine, elapsed, this));
        this.onPostUpdate(engine, elapsed);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPostUpdate(engine, elapsed) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(engine) {
        if (!this.isInitialized) {
            this._engine = engine;
            this._screen = engine.screen;
            const currentRes = this._screen.contentArea;
            let center = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._screen.peekResolution();
                if (res) {
                    center = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.y;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            this.pos.clone(this.drawPos);
            // First frame bootstrap
            // Ensure camera tx is correct
            // Run update twice to ensure properties are init'd
            this.updateTransform(this.pos);
            // Run strategies for first frame
            this.runStrategies(engine, engine.clock.elapsed());
            // Setup the first frame viewport
            this.updateViewport();
            // It's important to update the camera after strategies
            // This prevents jitter
            this.updateTransform(this.pos);
            this.pos.clone(this._oldPos);
            this.onInitialize(engine);
            this.events.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_8__.InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(engine) {
        // Overridable
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    runStrategies(engine, elapsed) {
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, engine, elapsed);
        }
    }
    updateViewport() {
        // recalculate viewport
        this._viewport = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
    }
    update(engine, elapsed) {
        this._initialize(engine);
        this._preupdate(engine, elapsed);
        this.pos.clone(this._oldPos);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(elapsed / 1000));
        this.zoom += (this.dz * elapsed) / 1000;
        this.vel = this.vel.add(this.acc.scale(elapsed / 1000));
        this.dz += (this.az * elapsed) / 1000;
        this.rotation += (this.angularVelocity * elapsed) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += elapsed;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += elapsed;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += elapsed;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        this.runStrategies(engine, elapsed);
        this.updateViewport();
        // It's important to update the camera after strategies
        // This prevents jitter
        this.updateTransform(this.pos);
        this._postupdate(engine, elapsed);
        this._posChanged = false;
    }
    /**
     * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
     * @param ctx Canvas context to apply transformations
     */
    draw(ctx) {
        // default to the current position
        this.pos.clone(this.drawPos);
        // interpolation if fixed update is on
        // must happen on the draw, because more draws are potentially happening than updates
        if (this._engine.fixedUpdateTimestep) {
            const blend = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep;
            const interpolatedPos = this.pos.scale(blend).add(this._oldPos.scale(1.0 - blend));
            interpolatedPos.clone(this.drawPos);
            this.updateTransform(interpolatedPos);
        }
        // Snap camera to pixel
        if (ctx.snapToPixel) {
            const snapPos = this.drawPos.clone(this._snapPos);
            snapPos.x = ~~(snapPos.x + _Graphics__WEBPACK_IMPORTED_MODULE_9__.pixelSnapEpsilon * (0,_Math_util__WEBPACK_IMPORTED_MODULE_10__.sign)(snapPos.x));
            snapPos.y = ~~(snapPos.y + _Graphics__WEBPACK_IMPORTED_MODULE_9__.pixelSnapEpsilon * (0,_Math_util__WEBPACK_IMPORTED_MODULE_10__.sign)(snapPos.y));
            snapPos.clone(this.drawPos);
            this.updateTransform(snapPos);
        }
        ctx.multiply(this.transform);
    }
    updateTransform(pos) {
        // center the camera
        const newCanvasWidth = this._screen.resolution.width / this.zoom;
        const newCanvasHeight = this._screen.resolution.height / this.zoom;
        const cameraPos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(-pos.x + newCanvasWidth / 2 + this._xShake, -pos.y + newCanvasHeight / 2 + this._yShake);
        // Calculate camera transform
        this.transform.reset();
        this.transform.scale(this.zoom, this.zoom);
        // rotate about the focus
        this.transform.translate(newCanvasWidth / 2, newCanvasHeight / 2);
        this.transform.rotate(this.rotation);
        this.transform.translate(-newCanvasWidth / 2, -newCanvasHeight / 2);
        this.transform.translate(cameraPos.x, cameraPos.y);
        this.transform.inverse(this.inverse);
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}


/***/ }),

/***/ "./Collision/BodyComponent.ts":
/*!************************************!*\
  !*** ./Collision/BodyComponent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_232073__) => {

__nested_webpack_require_232073__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_232073__.d(__nested_webpack_exports__, {
/* harmony export */   BodyComponent: () => (/* binding */ BodyComponent),
/* harmony export */   DegreeOfFreedom: () => (/* binding */ DegreeOfFreedom)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_232073__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_232073__(/*! ./CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_232073__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_232073__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_232073__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_232073__(/*! ./Group/CollisionGroup */ "./Collision/Group/CollisionGroup.ts");
/* harmony import */ var _Id__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_232073__(/*! ../Id */ "./Id.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_232073__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _ColliderComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_232073__(/*! ./ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _Math_transform__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_232073__(/*! ../Math/transform */ "./Math/transform.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_232073__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _PhysicsConfig__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_232073__(/*! ./PhysicsConfig */ "./Collision/PhysicsConfig.ts");












var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.dependencies = [_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent, _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent];
        this.id = (0,_Id__WEBPACK_IMPORTED_MODULE_3__.createId)('body', BodyComponent._ID++);
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_4__.EventEmitter();
        this.oldTransform = new _Math_transform__WEBPACK_IMPORTED_MODULE_5__.Transform();
        /**
         * Indicates whether the old transform has been captured at least once for interpolation
         * @internal
         */
        this.__oldTransformCaptured = false;
        /**
         * Enable or disabled the fixed update interpolation, by default interpolation is on.
         */
        this.enableFixedUpdateInterpolate = true;
        /**
         * Collision type for the rigidbody physics simulation, by default {@apilink CollisionType.PreventCollision}
         */
        this.collisionType = _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_7__.CollisionGroup.All;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor.
         *
         * The {@apilink SolverStrategy.Arcade} does not support this property.
         *
         */
        this.friction = 0.99;
        /**
         * Should use global gravity {@apilink Physics.gravity} in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         *
         * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond
         */
        this.limitDegreeOfFreedom = [];
        this._oldGlobalPos = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero;
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
         */
        this.oldAcc = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero;
        this._impulseScratch = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_8__.vec)(0, 0);
        this._distanceFromCenterScratch = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_8__.vec)(0, 0);
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
            this._bodyConfig = {
                ...(0,_PhysicsConfig__WEBPACK_IMPORTED_MODULE_9__.getDefaultPhysicsConfig)().bodies,
                ...options.config
            };
        }
        else {
            this._bodyConfig = {
                ...(0,_PhysicsConfig__WEBPACK_IMPORTED_MODULE_9__.getDefaultPhysicsConfig)().bodies
            };
        }
        this.updatePhysicsConfig(this._bodyConfig);
        this._mass = BodyComponent._DEFAULT_CONFIG.defaultMass;
    }
    get matrix() {
        return this.transform.get().matrix;
    }
    /**
     * Called by excalibur to update physics config defaults if they change
     * @param config
     */
    updatePhysicsConfig(config) {
        this._bodyConfig = {
            ...(0,_PhysicsConfig__WEBPACK_IMPORTED_MODULE_9__.getDefaultPhysicsConfig)().bodies,
            ...config
        };
        this.canSleep = this._bodyConfig.canSleepByDefault;
        this.sleepMotion = this._bodyConfig.sleepEpsilon * 5;
        this.wakeThreshold = this._bodyConfig.wakeThreshold;
    }
    /**
     * Called by excalibur to update defaults
     * @param config
     */
    static updateDefaultPhysicsConfig(config) {
        BodyComponent._DEFAULT_CONFIG = config;
    }
    get mass() {
        return this._mass;
    }
    set mass(newMass) {
        this._mass = newMass;
        this._cachedInertia = undefined;
        this._cachedInverseInertia = undefined;
    }
    /**
     * The inverse mass (1/mass) of the body. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     * @deprecated use isSleeping
     */
    get sleeping() {
        return this.isSleeping;
    }
    /**
     * Whether this body is sleeping or not
     */
    get isSleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     * @deprecated use isSleeping
     */
    setSleeping(sleeping) {
        this.isSleeping = sleeping;
    }
    set isSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = this._bodyConfig.sleepEpsilon * 5;
        }
        else {
            this.vel = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero;
            this.acc = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's {@apilink BodyComponent.sleepMotion} for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.isSleeping = true;
        }
        const currentMotion = this.vel.magnitude * this.vel.magnitude + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = this._bodyConfig.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = (0,_Math_util__WEBPACK_IMPORTED_MODULE_10__.clamp)(this.sleepMotion, 0, 10 * this._bodyConfig.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < this._bodyConfig.sleepEpsilon) {
            this.isSleeping = true;
        }
    }
    /**
     * Get the moment of inertia from the {@apilink ColliderComponent}
     */
    get inertia() {
        if (this._cachedInertia) {
            return this._cachedInertia;
        }
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(_ColliderComponent__WEBPACK_IMPORTED_MODULE_11__.ColliderComponent);
        if (collider) {
            collider.$colliderAdded.subscribe(() => {
                this._cachedInertia = null;
            });
            collider.$colliderRemoved.subscribe(() => {
                this._cachedInertia = null;
            });
            const maybeCollider = collider.get();
            if (maybeCollider) {
                return (this._cachedInertia = maybeCollider.getInertia(this.mass));
            }
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the {@apilink ColliderComponent}. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        if (this._cachedInverseInertia) {
            return this._cachedInverseInertia;
        }
        return (this._cachedInverseInertia = this.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.Fixed ? 0 : 1 / this.inertia);
    }
    /**
     * Returns if the owner is active
     * @deprecated use isActive
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.isActive);
    }
    /**
     * Returns if the owner is active
     */
    get isActive() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.isActive);
    }
    /**
     * @deprecated Use globalPos
     */
    get center() {
        return this.globalPos;
    }
    onAdd(owner) {
        var _a, _b;
        this.transform = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this.motion = (_b = this.owner) === null || _b === void 0 ? void 0 : _b.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
    }
    get pos() {
        return this.transform.pos;
    }
    set pos(val) {
        this.transform.pos = val;
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * {@apilink Actor.anchor} is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get globalPos() {
        return this.transform.globalPos;
    }
    set globalPos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The position of the actor last frame (x, y) in pixels
     */
    get oldPos() {
        return this.oldTransform.pos;
    }
    /**
     * The global position of the actor last frame (x, y) in pixels
     */
    get oldGlobalPos() {
        return this._oldGlobalPos;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * Gets/sets the rotation of the body from the last frame.
     */
    get oldRotation() {
        return this.oldTransform.rotation;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The scale of the actor last frame
     */
    get oldScale() {
        return this.oldTransform.scale;
    }
    /**
     * The scale rate of change of the actor in scale/second
     */
    get scaleFactor() {
        return this.motion.scaleFactor;
    }
    set scaleFactor(scaleFactor) {
        this.motion.scaleFactor = scaleFactor;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass, this._impulseScratch);
        if (this.limitDegreeOfFreedom.indexOf(DegreeOfFreedom.X) > -1) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.indexOf(DegreeOfFreedom.Y) > -1) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos, this._distanceFromCenterScratch);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impulse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_6__.CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.__oldTransformCaptured = true;
        const tx = this.transform.get();
        tx.clone(this.oldTransform);
        this.oldTransform.parent = tx.parent; // also grab parent
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
        this.oldGlobalPos.setTo(this.globalPos.x, this.globalPos.y);
    }
    clone() {
        const component = super.clone();
        return component;
    }
}
BodyComponent._ID = 0;
BodyComponent._DEFAULT_CONFIG = {
    ...(0,_PhysicsConfig__WEBPACK_IMPORTED_MODULE_9__.getDefaultPhysicsConfig)().bodies
};


/***/ }),

/***/ "./Collision/BoundingBox.ts":
/*!**********************************!*\
  !*** ./Collision/BoundingBox.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_249659__) => {

__nested_webpack_require_249659__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_249659__.d(__nested_webpack_exports__, {
/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_249659__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_249659__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_249659__(/*! ./Side */ "./Collision/Side.ts");



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        // Cache bounding box point returns
        this._points = [];
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Returns a new instance of {@apilink BoundingBox} that is a copy of the current instance
     */
    clone(dest) {
        const result = dest || new BoundingBox(0, 0, 0, 0);
        result.left = this.left;
        result.right = this.right;
        result.top = this.top;
        result.bottom = this.bottom;
        return result;
    }
    /**
     * Resets the bounds to a zero width/height box
     */
    reset() {
        this.left = 0;
        this.top = 0;
        this.bottom = 0;
        this.right = 0;
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.Right;
                }
                return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.Bottom;
                }
                return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.Top;
            }
        }
        return _Side__WEBPACK_IMPORTED_MODULE_0__.Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    /**
     * Creates a bounding box from a width and height
     * @param width
     * @param height
     * @param anchor Default Vector.Half
     * @param pos Default Vector.Zero
     */
    static fromDimension(width, height, anchor = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Half, pos = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    get topLeft() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.top);
    }
    get bottomRight() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.bottom);
    }
    get topRight() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.top);
    }
    get bottomLeft() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.bottom);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Scale a bounding box by a scale factor, optionally provide a point
     * @param scale
     * @param point
     */
    scale(scale, point = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    /**
     * Transform the axis aligned bounding box by a {@apilink Matrix}, producing a new axis aligned bounding box
     * @param matrix
     */
    transform(matrix) {
        // inlined these calculations to not use vectors would speed it up slightly
        // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);
        // const xa = matFirstColumn.scale(this.left);
        const xa1 = matrix.data[0] * this.left;
        const xa2 = matrix.data[1] * this.left;
        // const xb = matFirstColumn.scale(this.right);
        const xb1 = matrix.data[0] * this.right;
        const xb2 = matrix.data[1] * this.right;
        // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);
        // const ya = matSecondColumn.scale(this.top);
        const ya1 = matrix.data[2] * this.top;
        const ya2 = matrix.data[3] * this.top;
        // const yb = matSecondColumn.scale(this.bottom);
        const yb1 = matrix.data[2] * this.bottom;
        const yb2 = matrix.data[3] * this.bottom;
        const matrixPos = matrix.getPosition();
        // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);
        // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);
        const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;
        const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;
        const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;
        const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;
        return new BoundingBox({
            left, //: topLeft.x,
            top, //: topLeft.y,
            right, //: bottomRight.x,
            bottom //: bottomRight.y
        });
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    /**
     * Returns the world space points that make up the corners of the bounding box as a polygon
     */
    getPoints() {
        if (this._left !== this.left || this._right !== this.right || this._top !== this.top || this._bottom !== this.bottom) {
            this._points.length = 0;
            this._points.push(new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.top));
            this._points.push(new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.top));
            this._points.push(new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.bottom));
            this._points.push(new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.bottom));
            this._left = this.left;
            this._right = this.right;
            this._top = this.top;
            this._bottom = this.bottom;
        }
        return this._points;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tMin = -Infinity;
        let tMax = +Infinity;
        const xInv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yInv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xInv;
        const tx2 = (this.right - ray.pos.x) * xInv;
        tMin = Math.min(tx1, tx2);
        tMax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yInv;
        const ty2 = (this.bottom - ray.pos.y) * yInv;
        tMin = Math.max(tMin, Math.min(ty1, ty2));
        tMax = Math.min(tMax, Math.max(ty1, ty2));
        return tMax >= Math.max(0, tMin) && tMin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tMin = -Infinity;
        let tMax = +Infinity;
        const xInv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yInv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xInv;
        const tx2 = (this.right - ray.pos.x) * xInv;
        tMin = Math.min(tx1, tx2);
        tMax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yInv;
        const ty2 = (this.bottom - ray.pos.y) * yInv;
        tMin = Math.max(tMin, Math.min(ty1, ty2));
        tMax = Math.min(tMax, Math.max(ty1, ty2));
        if (tMax >= Math.max(0, tMin) && tMin < farClipDistance) {
            return tMin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector) {
            return this.left <= val.x && this.top <= val.y && val.y <= this.bottom && val.x <= this.right;
        }
        else if (val instanceof BoundingBox) {
            return this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other, dest) {
        const compositeBB = dest || new BoundingBox(0, 0, 0, 0);
        const left = Math.min(this.left, other.left);
        const top = Math.min(this.top, other.top);
        const right = Math.max(this.right, other.right);
        const bottom = Math.max(this.bottom, other.bottom);
        compositeBB.left = left;
        compositeBB.top = top;
        compositeBB.right = right;
        compositeBB.bottom = bottom;
        return compositeBB;
    }
    get dimensions() {
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(this.width, this.height);
    }
    /**
     * Returns true if the bounding boxes overlap.
     * @param other
     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
     * This epsilon is useful in stable collision simulations.
     */
    overlaps(other, epsilon) {
        const e = epsilon || 0;
        if (other.hasZeroDimensions()) {
            return this.contains(other);
        }
        if (this.hasZeroDimensions()) {
            return other.contains(this);
        }
        const totalBoundingBox = this.combine(other);
        return totalBoundingBox.width + e < other.width + this.width && totalBoundingBox.height + e < other.height + this.height;
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     * @param other  Other {@apilink BoundingBox} to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(overlapX, 0);
            }
            else {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(overlapX, 0);
            }
            else {
                return new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}


/***/ }),

/***/ "./Collision/ColliderComponent.ts":
/*!****************************************!*\
  !*** ./Collision/ColliderComponent.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_268935__) => {

__nested_webpack_require_268935__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_268935__.d(__nested_webpack_exports__, {
/* harmony export */   ColliderComponent: () => (/* binding */ ColliderComponent)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_268935__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_268935__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_268935__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_268935__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_268935__(/*! ../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_268935__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_268935__(/*! ./Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Colliders_Shape__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_268935__(/*! ./Colliders/Shape */ "./Collision/Colliders/Shape.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_268935__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_268935__(/*! ../Actor */ "./Actor.ts");










class ColliderComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(collider) {
        super();
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new _Util_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new _Util_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable();
        this._collidersToRemove = [];
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            collider.events.pipe(this.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this._collidersToRemove.push(this._collider);
            this._collider = null;
        }
    }
    processColliderRemoval() {
        for (const collider of this._collidersToRemove) {
            collider.events.unpipe(this.events);
            this.$colliderRemoved.notifyAll(collider);
            collider.owner = null;
        }
    }
    clone() {
        const clone = new ColliderComponent(this._collider.clone());
        return clone;
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new _BoundingBox__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new _BoundingBox__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx.get());
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite left hand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_5__.CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_6__.PreCollisionEvent(precollision.self, precollision.other, precollision.side, precollision.intersection, precollision.contact));
            if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_7__.Actor) {
                entity.onPreCollisionResolve(precollision.self, precollision.other, precollision.side, precollision.contact);
            }
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_6__.PostCollisionEvent(postcollision.self, postcollision.other, postcollision.side, postcollision.intersection, postcollision.contact));
            if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_7__.Actor) {
                entity.onPostCollisionResolve(postcollision.self, postcollision.other, postcollision.side, postcollision.contact);
            }
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_6__.CollisionStartEvent(start.self, start.other, start.side, start.contact));
            if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_7__.Actor) {
                entity.onCollisionStart(start.self, start.other, start.side, start.contact);
            }
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_6__.CollisionEndEvent(end.self, end.other, end.side, end.lastContact));
            if (entity instanceof _Actor__WEBPACK_IMPORTED_MODULE_7__.Actor) {
                entity.onCollisionEnd(end.self, end.other, end.side, end.lastContact);
            }
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Half, center = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero) {
        const collider = _Colliders_Shape__WEBPACK_IMPORTED_MODULE_9__.Shape.Box(width, height, anchor, center);
        return this.set(collider);
    }
    /**
     * Sets up a {@apilink PolygonCollider | `polygon`} collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero) {
        const poly = _Colliders_Shape__WEBPACK_IMPORTED_MODULE_9__.Shape.Polygon(points, center);
        return this.set(poly);
    }
    /**
     * Sets up a {@apilink Circle | `circle collision geometry`} as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero) {
        const collider = _Colliders_Shape__WEBPACK_IMPORTED_MODULE_9__.Shape.Circle(radius, center);
        return this.set(collider);
    }
    /**
     * Sets up an {@apilink Edge | `edge collision geometry`} with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = _Colliders_Shape__WEBPACK_IMPORTED_MODULE_9__.Shape.Edge(begin, end);
        return this.set(collider);
    }
    /**
     * Setups up a {@apilink CompositeCollider} which can define any arbitrary set of excalibur colliders
     * @param colliders
     */
    useCompositeCollider(colliders) {
        return this.set(new _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_5__.CompositeCollider(colliders));
    }
}


/***/ }),

/***/ "./Collision/Colliders/CircleCollider.ts":
/*!***********************************************!*\
  !*** ./Collision/Colliders/CircleCollider.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_279896__) => {

__nested_webpack_require_279896__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_279896__.d(__nested_webpack_exports__, {
/* harmony export */   CircleCollider: () => (/* binding */ CircleCollider)
/* harmony export */ });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_279896__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_279896__(/*! ./CollisionJumpTable */ "./Collision/Colliders/CollisionJumpTable.ts");
/* harmony import */ var _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_279896__(/*! ./PolygonCollider */ "./Collision/Colliders/PolygonCollider.ts");
/* harmony import */ var _EdgeCollider__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_279896__(/*! ./EdgeCollider */ "./Collision/Colliders/EdgeCollider.ts");
/* harmony import */ var _Math_projection__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_279896__(/*! ../../Math/projection */ "./Math/projection.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_279896__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_279896__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_279896__(/*! ./Collider */ "./Collision/Colliders/Collider.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_279896__(/*! ./ClosestLineJumpTable */ "./Collision/Colliders/ClosestLineJumpTable.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_279896__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _Index__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_279896__(/*! ../Index */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_279896__(/*! ../../Math/util */ "./Math/util.ts");












/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider {
    get worldPos() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Get the radius of the circle
     */
    get radius() {
        var _a;
        if (this._radius) {
            return this._radius;
        }
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        return (this._radius = this._naturalRadius * Math.min(scale.x, scale.y));
    }
    /**
     * Set the radius of the circle
     */
    set radius(val) {
        var _a;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        this._naturalRadius = val / Math.min(scale.x, scale.y);
        this._localBoundsDirty = true;
        this._radius = val;
    }
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        this._globalMatrix = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_2__.AffineMatrix.identity();
        this._localBoundsDirty = true;
        this.offset = options.offset || _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        this.radius = options.radius || 0;
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        var _a, _b;
        // https://en.wikipedia.org/wiki/Intersection_(geometry)#A_line_and_a_circle
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const u = c.sub(orig);
        const u1 = dir.scale(u.dot(dir));
        const u2 = u.sub(u1);
        const d = u2.magnitude;
        if (d > this.radius) {
            return null;
        }
        else {
            // tangent case
            let toi = 0;
            if ((0,_Math_util__WEBPACK_IMPORTED_MODULE_3__.approximatelyEqual)(d, this.radius, 0.0001)) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    const point = ray.getPoint(toi);
                    return {
                        point,
                        normal: point.sub(c).normalize(),
                        collider: this,
                        body: (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_Index__WEBPACK_IMPORTED_MODULE_4__.BodyComponent),
                        distance: toi
                    };
                }
                return null;
            }
            else {
                // two point
                const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const minToi = Math.min(...positiveToi);
                if (minToi <= max) {
                    const point = ray.getPoint(minToi);
                    return {
                        point,
                        normal: point.sub(c).normalize(),
                        collider: this,
                        body: (_b = this.owner) === null || _b === void 0 ? void 0 : _b.get(_Index__WEBPACK_IMPORTED_MODULE_4__.BodyComponent),
                        distance: minToi
                    };
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__.PolygonCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_7__.EdgeCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_8__.CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__.PolygonCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_8__.CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_7__.EdgeCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_8__.CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        return this.localBounds.transform(this._globalMatrix);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        if (this._localBoundsDirty) {
            this._localBounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_9__.BoundingBox(-this._naturalRadius, -this._naturalRadius, +this._naturalRadius, +this._naturalRadius);
            this._localBoundsDirty = false;
        }
        return this._localBounds;
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
        this._radius = undefined;
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new _Math_projection__WEBPACK_IMPORTED_MODULE_10__.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color, options) {
        var _a, _b, _c, _d;
        const { lineWidth } = { ...{ lineWidth: 1 }, ...options };
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = (_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        ex.save();
        ex.translate(pos.x, pos.y);
        ex.rotate(rotation);
        ex.scale(scale.x, scale.y);
        ex.drawCircle((_d = this.offset) !== null && _d !== void 0 ? _d : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero, this._naturalRadius, _Color__WEBPACK_IMPORTED_MODULE_11__.Color.Transparent, color, lineWidth);
        ex.restore();
    }
}


/***/ }),

/***/ "./Collision/Colliders/ClosestLineJumpTable.ts":
/*!*****************************************************!*\
  !*** ./Collision/Colliders/ClosestLineJumpTable.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_292290__) => {

__nested_webpack_require_292290__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_292290__.d(__nested_webpack_exports__, {
/* harmony export */   ClosestLineJumpTable: () => (/* binding */ ClosestLineJumpTable)
/* harmony export */ });
/* harmony import */ var _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_292290__(/*! ../../Math/line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_292290__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_ray__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_292290__(/*! ../../Math/ray */ "./Math/ray.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_292290__(/*! ../../Math/util */ "./Math/util.ts");




/**
 * Finds the closest line segment between two given line segments.
 */
function ClosestLine(line1, line2) {
    // https://math.stackexchange.com/questions/1993953/closest-points-between-2-lines-in-2d
    const EPSILON = 1e-9;
    const line1Dir = line1.dir();
    const line2Dir = line2.dir();
    const d1Squared = line1Dir.dot(line1Dir);
    const d2Squared = line2Dir.dot(line2Dir);
    if (d1Squared < EPSILON && d2Squared < EPSILON) {
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(line1.begin, line2.begin);
    }
    if (d1Squared < EPSILON) {
        const t = (0,_Math_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(line2Dir.dot(line1.begin.sub(line2.begin)) / d2Squared, 0, 1);
        const closestPoint = line2.begin.add(line2Dir.scale(t));
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(line1.begin, closestPoint);
    }
    if (d2Squared < EPSILON) {
        const t = (0,_Math_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(line1Dir.dot(line2.begin.sub(line1.begin)) / d1Squared, 0, 1);
        const closestPoint = line1.begin.add(line1Dir.scale(t));
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(closestPoint, line2.begin);
    }
    const r = line1.begin.sub(line2.begin);
    const a = d1Squared;
    const e = d2Squared;
    const f = line2Dir.dot(r);
    const denom = a * e - Math.pow(line1Dir.dot(line2Dir), 2);
    let s = 0;
    let t = 0;
    if (Math.abs(denom) > EPSILON) {
        s = (0,_Math_util__WEBPACK_IMPORTED_MODULE_1__.clamp)((line1Dir.dot(line2Dir) * f - e * line1Dir.dot(r)) / denom, 0, 1);
    }
    else {
        // lines are parallel
        s = (0,_Math_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(line1Dir.dot(r) / a, 0, 1);
    }
    if (Math.abs(e) > EPSILON) {
        t = (0,_Math_util__WEBPACK_IMPORTED_MODULE_1__.clamp)((line1Dir.dot(line2Dir) * s + f) / e, 0, 1);
    }
    else {
        // line2 is a degenerate point
        t = 0;
    }
    const closestPointOnLine1 = line1.begin.add(line1Dir.scale(s));
    const closestPointOnLine2 = line2.begin.add(line2Dir.scale(t));
    return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(closestPointOnLine1, closestPointOnLine2);
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        const aSides = polygonA.getSides();
        const bSides = polygonB.getSides();
        let minDistance = Number.MAX_VALUE;
        let closestLine = null;
        for (let i = 0; i < aSides.length; i++) {
            for (let j = 0; j < bSides.length; j++) {
                const line = ClosestLine(aSides[i], bSides[j]);
                const distance = line.getLength();
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLine = line;
                }
            }
        }
        return closestLine;
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new _Math_ray__WEBPACK_IMPORTED_MODULE_2__.Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).point.add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        return ClosestLine(thisFace.face, edgeLine);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new _Math_ray__WEBPACK_IMPORTED_MODULE_2__.Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).point.add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(u.scale(t).add(p0), new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new _Math_ray__WEBPACK_IMPORTED_MODULE_2__.Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new _Math_ray__WEBPACK_IMPORTED_MODULE_2__.Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(thisPoint.point, otherPoint.point);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorldPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorldPos.x - p0.x) + u.y * (circleWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorldPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorldPos.y) * circle.radius) / (circle.radius + d);
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_0__.LineSegment(u.scale(t).add(p0), new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(circleWorldPos.x + circlex, circleWorldPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        return ClosestLine(edgeLineA, edgeLineB);
    }
};


/***/ }),

/***/ "./Collision/Colliders/Collider.ts":
/*!*****************************************!*\
  !*** ./Collision/Colliders/Collider.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_301171__) => {

__nested_webpack_require_301171__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_301171__.d(__nested_webpack_exports__, {
/* harmony export */   Collider: () => (/* binding */ Collider)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_301171__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Id__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_301171__(/*! ../../Id */ "./Id.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_301171__(/*! ../../EventEmitter */ "./EventEmitter.ts");



/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = (0,_Id__WEBPACK_IMPORTED_MODULE_0__.createId)('collider', Collider._ID++);
        /**
         * Composite collider if any this collider is attached to
         *
         * **WARNING** do not tamper with this property
         */
        this.composite = null;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        /**
         * Pixel offset of the collision collider relative to the collider, by default (0, 0) meaning the collider is positioned
         * on top of the collider.
         */
        this.offset = _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other {@apilink Collider}
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;


/***/ }),

/***/ "./Collision/Colliders/CollisionJumpTable.ts":
/*!***************************************************!*\
  !*** ./Collision/Colliders/CollisionJumpTable.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_303261__) => {

__nested_webpack_require_303261__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_303261__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionJumpTable: () => (/* binding */ CollisionJumpTable)
/* harmony export */ });
/* harmony import */ var _CircleCollider__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_303261__(/*! ./CircleCollider */ "./Collision/Colliders/CircleCollider.ts");
/* harmony import */ var _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_303261__(/*! ../Detection/CollisionContact */ "./Collision/Detection/CollisionContact.ts");
/* harmony import */ var _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_303261__(/*! ./PolygonCollider */ "./Collision/Colliders/PolygonCollider.ts");
/* harmony import */ var _EdgeCollider__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_303261__(/*! ./EdgeCollider */ "./Collision/Colliders/EdgeCollider.ts");
/* harmony import */ var _SeparatingAxis__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_303261__(/*! ./SeparatingAxis */ "./Collision/Colliders/SeparatingAxis.ts");
/* harmony import */ var _Math_line_segment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_303261__(/*! ../../Math/line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_303261__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_303261__(/*! ../../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Detection_Pair__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_303261__(/*! ../Detection/Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_303261__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");










const ScratchZero = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero; // TODO constant vector
const ScratchNormal = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero; // TODO constant vector
const ScratchMatrix = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__.AffineMatrix.identity();
const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = _SeparatingAxis__WEBPACK_IMPORTED_MODULE_3__.SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const sameDir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent)) !== null && _b !== void 0 ? _b : new _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.magnitude,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent).get());
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = _Detection_Pair__WEBPACK_IMPORTED_MODULE_6__.Pair.calculatePairHash(polygon.id, edge.id);
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = _SeparatingAxis__WEBPACK_IMPORTED_MODULE_3__.SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = _SeparatingAxis__WEBPACK_IMPORTED_MODULE_3__.SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const main = separation.collider === polyA ? polyA : polyB;
        const toIncidentFrame = other.transform.inverse.multiply(main.transform.matrix, ScratchMatrix);
        const toIncidentFrameRotation = toIncidentFrame.getRotation();
        const referenceEdgeNormal = main.normals[separation.sideId].rotate(toIncidentFrameRotation, ScratchZero, ScratchNormal);
        let minEdge = Number.MAX_VALUE;
        let incidentEdgeIndex = 0;
        for (let i = 0; i < other.normals.length; i++) {
            const value = referenceEdgeNormal.dot(other.normals[i]);
            if (value < minEdge) {
                minEdge = value;
                incidentEdgeIndex = i;
            }
        }
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const referenceSide = separation.localSide.transform(toIncidentFrame);
        const referenceDirection = separation.localAxis.perpendicular().negate().rotate(toIncidentFrameRotation);
        const incidentSide = new _Math_line_segment__WEBPACK_IMPORTED_MODULE_7__.LineSegment(other.points[incidentEdgeIndex], other.points[(incidentEdgeIndex + 1) % other.points.length]);
        const clipRight = incidentSide.clip(referenceDirection.negate(), -referenceDirection.dot(referenceSide.begin), false);
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(referenceDirection, referenceDirection.dot(referenceSide.end), false);
        }
        if (clipLeft) {
            const localPoints = [];
            const points = [];
            const clipPoints = clipLeft.getPoints();
            for (let i = 0; i < clipPoints.length; i++) {
                const p = clipPoints[i];
                if (referenceSide.below(p)) {
                    localPoints.push(p);
                    points.push(other.transform.apply(p));
                }
            }
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.center.sub(polyA.center).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            return [new _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_2__.CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.bodyA) === null || _a === void 0 ? void 0 : _a.transform) !== null && _b !== void 0 ? _b : new _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.bodyB) === null || _c === void 0 ? void 0 : _c.transform) !== null && _d !== void 0 ? _d : new _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_4__.TransformComponent();
        // both are circles
        if (shapeA instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider && shapeB instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider && shapeB instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new _Math_line_segment__WEBPACK_IMPORTED_MODULE_7__.LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new _Math_line_segment__WEBPACK_IMPORTED_MODULE_7__.LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider && shapeB instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider) ||
            (shapeB instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider && shapeA instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_9__.EdgeCollider && shapeB instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider) ||
            (shapeB instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_9__.EdgeCollider && shapeA instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_5__.PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider && shapeB instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_9__.EdgeCollider) ||
            (shapeB instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider && shapeA instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_9__.EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};


/***/ }),

/***/ "./Collision/Colliders/CompositeCollider.ts":
/*!**************************************************!*\
  !*** ./Collision/Colliders/CompositeCollider.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_321176__) => {

__nested_webpack_require_321176__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_321176__.d(__nested_webpack_exports__, {
/* harmony export */   CompositeCollider: () => (/* binding */ CompositeCollider)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_321176__(/*! ../.. */ "./Util/Util.ts");
/* harmony import */ var _Detection_Pair__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_321176__(/*! ../Detection/Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _Math_projection__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_321176__(/*! ../../Math/projection */ "./Math/projection.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_321176__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_321176__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Detection_DynamicTree__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_321176__(/*! ../Detection/DynamicTree */ "./Collision/Detection/DynamicTree.ts");
/* harmony import */ var _Detection_DynamicTreeCollisionProcessor__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_321176__(/*! ../Detection/DynamicTreeCollisionProcessor */ "./Collision/Detection/DynamicTreeCollisionProcessor.ts");
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_321176__(/*! ./Collider */ "./Collision/Colliders/Collider.ts");
/* harmony import */ var _PhysicsConfig__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_321176__(/*! ../PhysicsConfig */ "./Collision/PhysicsConfig.ts");









class CompositeCollider extends _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider {
    /**
     * Treat composite collider's member colliders as either separate colliders for the purposes of onCollisionStart/onCollision
     * or as a single collider together.
     *
     * This property can be overridden on individual {@apilink CompositeColliders}.
     *
     * For composites without gaps or small groups of colliders, you probably want 'together'
     *
     * For composites with deliberate gaps, like a platforming level layout, you probably want 'separate'
     *
     * Default is 'together' if unset
     */
    set compositeStrategy(value) {
        this._compositeStrategy = value;
    }
    get compositeStrategy() {
        return this._compositeStrategy;
    }
    constructor(colliders) {
        super();
        this._collisionProcessor = new _Detection_DynamicTreeCollisionProcessor__WEBPACK_IMPORTED_MODULE_1__.DynamicTreeCollisionProcessor({
            ...(0,_PhysicsConfig__WEBPACK_IMPORTED_MODULE_2__.getDefaultPhysicsConfig)()
        });
        this._dynamicAABBTree = new _Detection_DynamicTree__WEBPACK_IMPORTED_MODULE_3__.DynamicTree({
            boundsPadding: 5,
            velocityMultiplier: 2
        });
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        let colliders;
        if (collider instanceof CompositeCollider) {
            colliders = collider.getColliders();
            colliders.forEach((c) => c.offset.addEqual(collider.offset));
        }
        else {
            colliders = [collider];
        }
        // Flatten composites
        for (const c of colliders) {
            c.events.pipe(this.events);
            c.composite = this;
            this._colliders.push(c);
            this._collisionProcessor.track(c);
            this._dynamicAABBTree.trackCollider(c);
        }
    }
    removeCollider(collider) {
        collider.events.pipe(this.events);
        collider.composite = null;
        ___WEBPACK_IMPORTED_MODULE_4__.removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        return ((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : _Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Zero).add(this.offset);
    }
    get center() {
        var _a, _b;
        return ((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : _Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Zero).add(this.offset);
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new _BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox().translate(this.worldPos));
        return results.translate(this.offset);
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new _BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new _Detection_Pair__WEBPACK_IMPORTED_MODULE_7__.Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const hits = [];
        for (const collider of colliders) {
            const hit = collider.rayCast(ray, max);
            if (hit) {
                hits.push(hit);
            }
        }
        if (hits.length) {
            let minHit = hits[0];
            let minDistance = minHit.point.dot(ray.dir);
            for (const hit of hits) {
                const distance = ray.dir.dot(hit.point);
                if (distance < minDistance) {
                    minHit = hit;
                    minDistance = distance;
                }
            }
            return minHit;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projections = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projections.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projections.length) {
            const newProjection = new _Math_projection__WEBPACK_IMPORTED_MODULE_8__.Projection(projections[0].min, projections[0].max);
            for (const proj of projections) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    debug(ex, color, options) {
        const colliders = this.getColliders();
        ex.save();
        ex.translate(this.offset.x, this.offset.y);
        for (const collider of colliders) {
            collider.debug(ex, color, options);
        }
        ex.restore();
    }
    clone() {
        const result = new CompositeCollider(this._colliders.map((c) => c.clone()));
        result.offset = this.offset.clone();
        return result;
    }
}


/***/ }),

/***/ "./Collision/Colliders/EdgeCollider.ts":
/*!*********************************************!*\
  !*** ./Collision/Colliders/EdgeCollider.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_332211__) => {

__nested_webpack_require_332211__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_332211__.d(__nested_webpack_exports__, {
/* harmony export */   EdgeCollider: () => (/* binding */ EdgeCollider)
/* harmony export */ });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_332211__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_332211__(/*! ./CollisionJumpTable */ "./Collision/Colliders/CollisionJumpTable.ts");
/* harmony import */ var _CircleCollider__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_332211__(/*! ./CircleCollider */ "./Collision/Colliders/CircleCollider.ts");
/* harmony import */ var _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_332211__(/*! ./PolygonCollider */ "./Collision/Colliders/PolygonCollider.ts");
/* harmony import */ var _Math_projection__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_332211__(/*! ../../Math/projection */ "./Math/projection.ts");
/* harmony import */ var _Math_line_segment__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_332211__(/*! ../../Math/line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_332211__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_332211__(/*! ./Collider */ "./Collision/Colliders/Collider.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_332211__(/*! ./ClosestLineJumpTable */ "./Collision/Colliders/ClosestLineJumpTable.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_332211__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _Index__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_332211__(/*! ../Index */ "./Collision/BodyComponent.ts");











/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider {
    constructor(options) {
        var _a;
        super();
        this._globalMatrix = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__.AffineMatrix.identity();
        this.begin = options.begin || _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
        this.end = options.end || _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const pos = begin.average(end);
        return pos;
    }
    _getTransformedBegin() {
        return this._globalMatrix.multiply(this.begin);
    }
    _getTransformedEnd() {
        return this._globalMatrix.multiply(this.end);
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        var _a;
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return {
                    distance: t,
                    normal: this.asLine().normal(),
                    collider: this,
                    body: (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_Index__WEBPACK_IMPORTED_MODULE_3__.BodyComponent),
                    point: ray.getPoint(t)
                };
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_4__.CircleCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__.PolygonCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_5__.ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_4__.CircleCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_7__.CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof _PolygonCollider__WEBPACK_IMPORTED_MODULE_6__.PolygonCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_7__.CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_7__.CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new _BoundingBox__WEBPACK_IMPORTED_MODULE_8__.BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_9__.LineSegment(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new _Math_line_segment__WEBPACK_IMPORTED_MODULE_9__.LineSegment(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new _Math_projection__WEBPACK_IMPORTED_MODULE_10__.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
}


/***/ }),

/***/ "./Collision/Colliders/PolygonCollider.ts":
/*!************************************************!*\
  !*** ./Collision/Colliders/PolygonCollider.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_343024__) => {

__nested_webpack_require_343024__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_343024__.d(__nested_webpack_exports__, {
/* harmony export */   PolygonCollider: () => (/* binding */ PolygonCollider)
/* harmony export */ });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_343024__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _EdgeCollider__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_343024__(/*! ./EdgeCollider */ "./Collision/Colliders/EdgeCollider.ts");
/* harmony import */ var _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_343024__(/*! ./CollisionJumpTable */ "./Collision/Colliders/CollisionJumpTable.ts");
/* harmony import */ var _CircleCollider__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_343024__(/*! ./CircleCollider */ "./Collision/Colliders/CircleCollider.ts");
/* harmony import */ var _Math_projection__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_343024__(/*! ../../Math/projection */ "./Math/projection.ts");
/* harmony import */ var _Math_line_segment__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_343024__(/*! ../../Math/line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_343024__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_ray__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_343024__(/*! ../../Math/ray */ "./Math/ray.ts");
/* harmony import */ var _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_343024__(/*! ./ClosestLineJumpTable */ "./Collision/Colliders/ClosestLineJumpTable.ts");
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_343024__(/*! ./Collider */ "./Collision/Colliders/Collider.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_343024__(/*! ../.. */ "./Util/Log.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_343024__(/*! ../.. */ "./Math/util.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_343024__(/*! ../.. */ "./Collision/BodyComponent.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_343024__(/*! ../.. */ "./Graphics/Debug.ts");
/* harmony import */ var _CompositeCollider__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_343024__(/*! ./CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_343024__(/*! ./Shape */ "./Collision/Colliders/Shape.ts");
/* harmony import */ var _Math_transform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_343024__(/*! ../../Math/transform */ "./Math/transform.ts");














/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider {
    flagDirty() {
        this._localBoundsDirty = true;
        this._localSidesDirty = true;
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
    }
    get normals() {
        return this._normals;
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    set points(points) {
        if (points.length < 3) {
            throw new Error('PolygonCollider cannot be created with less that 3 points');
        }
        this._points = points;
        this._checkAndUpdateWinding(this._points);
        this._calculateNormals();
        this.flagDirty();
    }
    _calculateNormals() {
        const normals = [];
        for (let i = 0; i < this._points.length; i++) {
            normals.push(this._points[(i + 1) % this._points.length].sub(this._points[i]).normal());
        }
        this._normals = normals;
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    get points() {
        return this._points;
    }
    get transform() {
        return this._transform;
    }
    constructor(options) {
        var _a;
        super();
        this._logger = ___WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._transform = new _Math_transform__WEBPACK_IMPORTED_MODULE_2__.Transform();
        this._transformedPoints = [];
        this._sides = [];
        this._localSides = [];
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        this._localSidesDirty = true;
        this._localBoundsDirty = true;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero;
        this._transform.pos.x += this.offset.x;
        this._transform.pos.y += this.offset.y;
        this.points = options.points;
        if (!this.isConvex()) {
            if (!options.suppressConvexWarning) {
                this._logger.warn('Excalibur only supports convex polygon colliders and will not behave properly.' +
                    'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');
            }
        }
        // calculate initial transformation
        this._calculateTransformation();
    }
    _checkAndUpdateWinding(points) {
        const counterClockwise = this._isCounterClockwiseWinding(points);
        if (!counterClockwise) {
            points.reverse();
        }
    }
    _isCounterClockwiseWinding(points) {
        // https://stackoverflow.com/a/1165943
        let sum = 0;
        for (let i = 0; i < points.length; i++) {
            sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);
        }
        return sum < 0;
    }
    /**
     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
     * Call {@apilink Polygon.triangulate} to generate a {@apilink CompositeCollider} from this non-convex shape
     */
    isConvex() {
        // From SO: https://stackoverflow.com/a/45372025
        if (this.points.length < 3) {
            return false;
        }
        let oldPoint = this.points[this.points.length - 2];
        let newPoint = this.points[this.points.length - 1];
        let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
        let oldDirection = 0;
        let orientation = 0;
        let angleSum = 0;
        for (const [i, point] of this.points.entries()) {
            oldPoint = newPoint;
            oldDirection = direction;
            newPoint = point;
            direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
            if (oldPoint.equals(newPoint)) {
                return false; // repeat point
            }
            let angle = direction - oldDirection;
            if (angle <= -Math.PI) {
                angle += Math.PI * 2;
            }
            else if (angle > Math.PI) {
                angle -= Math.PI * 2;
            }
            if (i === 0) {
                if (angle === 0.0) {
                    return false;
                }
                orientation = angle > 0 ? 1 : -1;
            }
            else {
                if (orientation * angle <= 0) {
                    return false;
                }
            }
            angleSum += angle;
        }
        return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;
    }
    /**
     * Tessellates the polygon into a triangle fan as a {@apilink CompositeCollider} of triangle polygons
     */
    tessellate() {
        const polygons = [];
        for (let i = 1; i < this.points.length - 2; i++) {
            polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);
        }
        polygons.push([this.points[0], this.points[1], this.points[2]]);
        return new _CompositeCollider__WEBPACK_IMPORTED_MODULE_4__.CompositeCollider(polygons.map((points) => _Shape__WEBPACK_IMPORTED_MODULE_5__.Shape.Polygon(points)));
    }
    /**
     * Triangulate the polygon collider using the "Ear Clipping" algorithm.
     * Returns a new {@apilink CompositeCollider} made up of smaller triangles.
     */
    triangulate() {
        // https://www.youtube.com/watch?v=hTJFcHutls8
        if (this.points.length < 3) {
            throw Error('Invalid polygon');
        }
        const triangles = [];
        // algorithm likes clockwise
        const vertices = [...this.points].reverse();
        let vertexCount = vertices.length;
        /**
         * Returns the previous index based on the current vertex
         */
        function getPrevIndex(index) {
            return index === 0 ? vertexCount - 1 : index - 1;
        }
        /**
         * Retrieves the next index based on the current vertex
         */
        function getNextIndex(index) {
            return index === vertexCount - 1 ? 0 : index + 1;
        }
        /**
         * Whether or not the angle at this vertex index is convex
         */
        function isConvex(index) {
            const prev = getPrevIndex(index);
            const next = getNextIndex(index);
            const va = vertices[prev];
            const vb = vertices[index];
            const vc = vertices[next];
            // Check convexity
            const leftArm = va.sub(vb);
            const rightArm = vc.sub(vb);
            // Positive cross product is convex
            if (leftArm.cross(rightArm) < 0) {
                return false;
            }
            return true;
        }
        const convexVertices = vertices.map((_, i) => isConvex(i));
        /**
         * Quick test for point in triangle
         */
        function isPointInTriangle(point, a, b, c) {
            const ab = b.sub(a);
            const bc = c.sub(b);
            const ca = a.sub(c);
            const ap = point.sub(a);
            const bp = point.sub(b);
            const cp = point.sub(c);
            const cross1 = ab.cross(ap);
            const cross2 = bc.cross(bp);
            const cross3 = ca.cross(cp);
            if (cross1 > 0 || cross2 > 0 || cross3 > 0) {
                return false;
            }
            return true;
        }
        /**
         * Calculate the area of the triangle
         */
        // function triangleArea(a: Vector, b: Vector, c: Vector) {
        //   return Math.abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - c.y))/2;
        // }
        /**
         * Find the next suitable ear tip
         */
        function findEarTip() {
            for (let i = 0; i < vertexCount; i++) {
                if (convexVertices[i]) {
                    const prev = getPrevIndex(i);
                    const next = getNextIndex(i);
                    const va = vertices[prev];
                    const vb = vertices[i];
                    const vc = vertices[next];
                    let isEar = true;
                    // Check that if any vertices are in the triangle a, b, c
                    for (let j = 0; j < vertexCount; j++) {
                        // We can skip these verts because they are the triangle we are testing
                        if (j === i || j === prev || j === next) {
                            continue;
                        }
                        const point = vertices[j];
                        if (isPointInTriangle(point, va, vb, vc)) {
                            isEar = false;
                            break;
                        }
                    }
                    // Add ear to polygon list and remove from list
                    if (isEar) {
                        return i;
                    }
                }
            }
            // Fall back to any convex vertex
            for (let i = 0; i < vertexCount; i++) {
                if (convexVertices[i]) {
                    return i;
                }
            }
            // bail and return the first one?
            return 0;
        }
        /**
         * Cut the ear and produce a triangle, update internal state
         */
        function cutEarTip(index) {
            const prev = getPrevIndex(index);
            const next = getNextIndex(index);
            const va = vertices[prev];
            const vb = vertices[index];
            const vc = vertices[next];
            // Clockwise winding
            // if (triangleArea(va, vb, vc) > 0) {
            triangles.push([va, vb, vc]);
            // }
            vertices.splice(index, 1);
            convexVertices.splice(index, 1);
            vertexCount--;
        }
        // Loop over all the vertices finding ears
        while (vertexCount > 3) {
            const earIndex = findEarTip();
            cutEarTip(earIndex);
            // reclassify vertices
            for (let i = 0; i < vertexCount; i++) {
                convexVertices[i] = isConvex(i);
            }
        }
        // Last triangle after the loop
        triangles.push([vertices[0], vertices[1], vertices[2]]);
        // FIXME: there is a colinear triangle that sneaks in here sometimes
        return new _CompositeCollider__WEBPACK_IMPORTED_MODULE_4__.CompositeCollider(triangles.map((points) => _Shape__WEBPACK_IMPORTED_MODULE_5__.Shape.Polygon(points, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero, true)));
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        return this._transform.pos;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const points = this.points;
        const len = points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this._transform.apply(points[i].clone());
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        if (this._transformedPointsDirty) {
            this._calculateTransformation();
            this._transformedPointsDirty = false;
        }
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sidesDirty) {
            const lines = [];
            const points = this.getTransformedPoints();
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new _Math_line_segment__WEBPACK_IMPORTED_MODULE_6__.LineSegment(points[i], points[(i + 1) % len]));
            }
            this._sides = lines;
            this._sidesDirty = false;
        }
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSidesDirty) {
            const lines = [];
            const points = this.points;
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new _Math_line_segment__WEBPACK_IMPORTED_MODULE_6__.LineSegment(points[i], points[(i + 1) % len]));
            }
            this._localSides = lines;
            this._localSidesDirty = false;
        }
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        const axes = [];
        const sides = this.getSides();
        for (let i = 0; i < sides.length; i++) {
            axes.push(sides[i].normal());
        }
        return axes;
    }
    /**
     * Updates the transform for the collision geometry
     *
     * Collision geometry (points/bounds) will not change until this is called.
     * @param transform
     */
    update(transform) {
        if (transform) {
            // This change means an update must be performed in order for geometry to update
            transform.cloneWithParent(this._transform);
            this._transformedPointsDirty = true;
            this._sidesDirty = true;
            if (this.offset.x !== 0 || this.offset.y !== 0) {
                this._transform.pos.x += this.offset.x;
                this._transform.pos.y += this.offset.y;
            }
            if (this._transform.isMirrored()) {
                // negative transforms really mess with things in collision local space
                // flatten out the negatives by applying to geometry
                this.points = this.points.map((p) => (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(p.x * (0,___WEBPACK_IMPORTED_MODULE_7__.sign)(this._transform.scale.x), p.y * (0,___WEBPACK_IMPORTED_MODULE_7__.sign)(this._transform.scale.y)));
                this._transform.scale.x = Math.abs(this._transform.scale.x);
                this._transform.scale.y = Math.abs(this._transform.scale.y);
            }
        }
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const localPoint = this._transform.applyInverse(point);
        const testRay = new _Math_ray__WEBPACK_IMPORTED_MODULE_8__.Ray(localPoint, new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(1, 0));
        let intersectCount = 0;
        const sides = this.getLocalSides();
        for (let sideIndex = 0; sideIndex < sides.length; sideIndex++) {
            const side = sides[sideIndex];
            if (testRay.intersect(side) >= 0) {
                intersectCount++;
            }
        }
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_9__.CircleCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_10__.ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_10__.ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_11__.EdgeCollider) {
            return _ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_10__.ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof _CircleCollider__WEBPACK_IMPORTED_MODULE_9__.CircleCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_12__.CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_12__.CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof _EdgeCollider__WEBPACK_IMPORTED_MODULE_11__.EdgeCollider) {
            return _CollisionJumpTable__WEBPACK_IMPORTED_MODULE_12__.CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        return this.localBounds.transform(this._transform.matrix);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        if (this._localBoundsDirty) {
            this._localBounds = _BoundingBox__WEBPACK_IMPORTED_MODULE_13__.BoundingBox.fromPoints(this.points);
            this._localBoundsDirty = false;
        }
        return this._localBounds;
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        if (this._cachedMass === mass && this._cachedInertia) {
            return this._cachedInertia;
        }
        let numerator = 0;
        let denominator = 0;
        const points = this.points;
        for (let i = 0; i < points.length; i++) {
            const iplusone = (i + 1) % points.length;
            const crossTerm = points[iplusone].cross(points[i]);
            numerator += crossTerm * (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));
            denominator += crossTerm;
        }
        this._cachedMass = mass;
        return (this._cachedInertia = (mass / 6) * (numerator / denominator));
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        var _a;
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactSide;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactSide = sides[i];
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return {
                collider: this,
                distance: minContactTime,
                body: (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(___WEBPACK_IMPORTED_MODULE_14__.BodyComponent),
                point: ray.getPoint(minContactTime),
                normal: contactSide.normal()
            };
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new _Math_projection__WEBPACK_IMPORTED_MODULE_15__.Projection(min, max);
    }
    debug(ex, color, options) {
        const points = this.getTransformedPoints();
        ___WEBPACK_IMPORTED_MODULE_16__.Debug.drawPolygon(points, { color });
    }
}


/***/ }),

/***/ "./Collision/Colliders/SeparatingAxis.ts":
/*!***********************************************!*\
  !*** ./Collision/Colliders/SeparatingAxis.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_370077__) => {

__nested_webpack_require_370077__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_370077__.d(__nested_webpack_exports__, {
/* harmony export */   SeparatingAxis: () => (/* binding */ SeparatingAxis),
/* harmony export */   SeparationInfo: () => (/* binding */ SeparationInfo)
/* harmony export */ });
/* harmony import */ var _Math_line_segment__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_370077__(/*! ../../Math/line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_370077__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_370077__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _Util_Pool__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_370077__(/*! ../../Util/Pool */ "./Util/Pool.ts");




/**
 * Specific information about a contact and it's separation
 */
class SeparationInfo {
    constructor() {
        /**
         * Axis of separation from the collider's perspective
         */
        this.axis = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        /**
         * Local axis of separation from the collider's perspective
         */
        this.localAxis = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        /**
         * Side of separation (reference) from the collider's perspective
         */
        this.side = new _Math_line_segment__WEBPACK_IMPORTED_MODULE_1__.LineSegment((0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0));
        /**
         * Local side of separation (reference) from the collider's perspective
         */
        this.localSide = new _Math_line_segment__WEBPACK_IMPORTED_MODULE_1__.LineSegment((0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0));
        /**
         * Point on collider B (incident point)
         */
        this.point = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        /**
         * Local point on collider B (incident point)
         */
        this.localPoint = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
    }
}
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        // if polyB has 0 scale we need to hop back to degenerate separation
        if (polyB.transform.matrix.determinant() === 0) {
            return SeparatingAxis.findPolygonPolygonSeparationDegenerate(polyA, polyB);
        }
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        let bestSeparation = -Number.MAX_VALUE;
        let bestSideIndex = -1;
        let localPoint;
        // Work inside polyB reference frame
        // inv polyB converts to local space from polyA world space
        const toPolyBSpace = polyB.transform.inverse.multiply(polyA.transform.matrix, SeparatingAxis._SCRATCH_MATRIX);
        const toPolyBSpaceRotation = toPolyBSpace.getRotation();
        const normalsA = polyA.normals;
        const pointsA = polyA.points;
        const pointsB = polyB.points;
        for (let pointsAIndex = 0; pointsAIndex < pointsA.length; pointsAIndex++) {
            const normal = normalsA[pointsAIndex].rotate(toPolyBSpaceRotation, SeparatingAxis._ZERO, SeparatingAxis._SCRATCH_NORMAL);
            const point = toPolyBSpace.multiply(pointsA[pointsAIndex], SeparatingAxis._SCRATCH_POINT);
            // For every point in polyB
            // We want to see how much overlap there is on the axis provided by the normal
            // We want to find the minimum overlap among all points
            let smallestPointDistance = Number.MAX_VALUE;
            let smallestLocalPoint;
            for (let pointsBIndex = 0; pointsBIndex < pointsB.length; pointsBIndex++) {
                const distance = normal.dot(pointsB[pointsBIndex].sub(point, SeparatingAxis._SCRATCH_SUB_POINT));
                if (distance < smallestPointDistance) {
                    smallestPointDistance = distance;
                    smallestLocalPoint = pointsB[pointsBIndex];
                }
            }
            // We take the maximum overlap as the separation between the
            // A negative separation means there were no gaps between the two shapes
            if (smallestPointDistance > bestSeparation) {
                bestSeparation = smallestPointDistance;
                bestSideIndex = pointsAIndex;
                localPoint = smallestLocalPoint;
            }
        }
        // TODO can we avoid applying world space transforms?
        const bestSide2 = (bestSideIndex + 1) % pointsA.length;
        const separationInfo = SeparatingAxis.SeparationPool.get();
        separationInfo.collider = polyA;
        separationInfo.separation = bestSeparation;
        if (bestSeparation > 0) {
            // early out because if separation is > 0 then no local point
            return separationInfo;
        }
        normalsA[bestSideIndex].clone(separationInfo.localAxis);
        normalsA[bestSideIndex].rotate(polyA.transform.rotation, SeparatingAxis._ZERO, separationInfo.axis);
        polyA.transform.matrix.multiply(pointsA[bestSideIndex], separationInfo.side.begin);
        polyA.transform.matrix.multiply(pointsA[bestSide2], separationInfo.side.end);
        polyB.transform.matrix.multiply(localPoint, separationInfo.point);
        separationInfo.sideId = bestSideIndex;
        localPoint.clone(separationInfo.localPoint);
        pointsA[bestSideIndex].clone(separationInfo.localSide.begin);
        pointsA[bestSide2].clone(separationInfo.localSide.end);
        return separationInfo;
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
    static findPolygonPolygonSeparationDegenerate(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
}
SeparatingAxis.SeparationPool = new _Util_Pool__WEBPACK_IMPORTED_MODULE_2__.Pool(() => new SeparationInfo(), (i) => i, // no recycle
500);
SeparatingAxis._ZERO = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
SeparatingAxis._SCRATCH_POINT = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
SeparatingAxis._SCRATCH_SUB_POINT = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
SeparatingAxis._SCRATCH_NORMAL = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
SeparatingAxis._SCRATCH_MATRIX = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
SeparatingAxis.SeparationPool.disableWarnings = true;


/***/ }),

/***/ "./Collision/Colliders/Shape.ts":
/*!**************************************!*\
  !*** ./Collision/Colliders/Shape.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_379256__) => {

__nested_webpack_require_379256__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_379256__.d(__nested_webpack_exports__, {
/* harmony export */   Shape: () => (/* binding */ Shape)
/* harmony export */ });
/* harmony import */ var _PolygonCollider__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_379256__(/*! ./PolygonCollider */ "./Collision/Colliders/PolygonCollider.ts");
/* harmony import */ var _CircleCollider__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_379256__(/*! ./CircleCollider */ "./Collision/Colliders/CircleCollider.ts");
/* harmony import */ var _EdgeCollider__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_379256__(/*! ./EdgeCollider */ "./Collision/Colliders/EdgeCollider.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_379256__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_379256__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _CompositeCollider__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_379256__(/*! ./CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_379256__(/*! ../.. */ "./Util/Log.ts");







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a {@apilink PolygonCollider} collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Half, offset = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero) {
        return new _PolygonCollider__WEBPACK_IMPORTED_MODULE_1__.PolygonCollider({
            points: new _BoundingBox__WEBPACK_IMPORTED_MODULE_2__.BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new {@apilink PolygonCollider | `arbitrary polygon`} collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, offset = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero, suppressConvexWarning = false) {
        return new _PolygonCollider__WEBPACK_IMPORTED_MODULE_1__.PolygonCollider({
            points: points,
            offset: offset,
            suppressConvexWarning
        });
    }
    /**
     * Creates a new {@apilink CircleCollider | `circle`} collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero) {
        return new _CircleCollider__WEBPACK_IMPORTED_MODULE_3__.CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new {@apilink EdgeCollider | `edge`} collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new _EdgeCollider__WEBPACK_IMPORTED_MODULE_4__.EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped {@apilink CompositeCollider} using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero) {
        const logger = ___WEBPACK_IMPORTED_MODULE_5__.Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new _CompositeCollider__WEBPACK_IMPORTED_MODULE_6__.CompositeCollider([
                Shape.Circle(width / 2, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Half, offset),
                Shape.Circle(width / 2, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new _CompositeCollider__WEBPACK_IMPORTED_MODULE_6__.CompositeCollider([
                Shape.Circle(height / 2, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Half, offset),
                Shape.Circle(height / 2, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}


/***/ }),

/***/ "./Collision/CollisionSystem.ts":
/*!**************************************!*\
  !*** ./Collision/CollisionSystem.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_385322__) => {

__nested_webpack_require_385322__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_385322__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionSystem: () => (/* binding */ CollisionSystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_385322__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_385322__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_385322__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_385322__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_385322__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _SolverStrategy__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_385322__(/*! ./SolverStrategy */ "./Collision/SolverStrategy.ts");
/* harmony import */ var _Solver_ArcadeSolver__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_385322__(/*! ./Solver/ArcadeSolver */ "./Collision/Solver/ArcadeSolver.ts");
/* harmony import */ var _Solver_RealisticSolver__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_385322__(/*! ./Solver/RealisticSolver */ "./Collision/Solver/RealisticSolver.ts");
/* harmony import */ var _ColliderComponent__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_385322__(/*! ./ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_385322__(/*! ./Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Collision_Side__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_385322__(/*! ../Collision/Side */ "./Collision/Side.ts");
/* harmony import */ var _Colliders_SeparatingAxis__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_385322__(/*! ./Colliders/SeparatingAxis */ "./Collision/Colliders/SeparatingAxis.ts");
/* harmony import */ var _MotionSystem__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_385322__(/*! ./MotionSystem */ "./Collision/MotionSystem.ts");
/* harmony import */ var _Detection_Pair__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_385322__(/*! ./Detection/Pair */ "./Collision/Detection/Pair.ts");














class CollisionSystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    get _processor() {
        return this._physics.collisionProcessor;
    }
    constructor(world, _physics) {
        super();
        this._physics = _physics;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Update;
        this._configDirty = false;
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._arcadeSolver = new _Solver_ArcadeSolver__WEBPACK_IMPORTED_MODULE_1__.ArcadeSolver(_physics.config.arcade);
        this._realisticSolver = new _Solver_RealisticSolver__WEBPACK_IMPORTED_MODULE_2__.RealisticSolver(_physics.config.realistic);
        this._physics.$configUpdate.subscribe(() => (this._configDirty = true));
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
        this.query = world.query([_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__.TransformComponent, _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_4__.MotionComponent, _ColliderComponent__WEBPACK_IMPORTED_MODULE_5__.ColliderComponent]);
        this.query.entityAdded$.subscribe((e) => {
            const colliderComponent = e.get(_ColliderComponent__WEBPACK_IMPORTED_MODULE_5__.ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        });
        this.query.entityRemoved$.subscribe((e) => {
            const colliderComponent = e.get(_ColliderComponent__WEBPACK_IMPORTED_MODULE_5__.ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        });
        this._motionSystem = world.get(_MotionSystem__WEBPACK_IMPORTED_MODULE_6__.MotionSystem);
    }
    initialize(world, scene) {
        this._engine = scene.engine;
    }
    update(elapsed) {
        var _a, _b, _c, _d;
        if (!this._physics.config.enabled) {
            return;
        }
        // TODO do we need to do this every frame?
        // Collect up all the colliders and update them
        let colliders = [];
        for (let entityIndex = 0; entityIndex < this.query.entities.length; entityIndex++) {
            const entity = this.query.entities[entityIndex];
            const colliderComp = entity.get(_ColliderComponent__WEBPACK_IMPORTED_MODULE_5__.ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.isActive) && collider) {
                colliderComp.update();
                // Flatten composite colliders
                if (collider instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_7__.CompositeCollider) {
                    const compositeColliders = collider.getColliders();
                    if (!collider.compositeStrategy) {
                        collider.compositeStrategy = this._physics.config.colliders.compositeStrategy;
                    }
                    colliders = colliders.concat(compositeColliders);
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders, elapsed);
        // Run broadphase on all colliders and locates potential collisions
        let pairs = this._processor.broadphase(colliders, elapsed);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = []; // = this._processor.narrowphase(pairs, this._engine?.debug?.stats?.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities aren't overlapping
        const substep = this._physics.config.substep;
        for (let step = 0; step < substep; step++) {
            if (step > 0) {
                // first step is run by the MotionSystem when configured, so skip
                this._motionSystem.update(elapsed);
            }
            // Re-use pairs from previous collision
            if (contacts.length) {
                pairs = contacts.map((c) => new _Detection_Pair__WEBPACK_IMPORTED_MODULE_8__.Pair(c.colliderA, c.colliderB));
            }
            if (pairs.length) {
                contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);
                contacts = solver.solve(contacts);
                // Record contacts for start/end
                for (const contact of contacts) {
                    if (contact.isCanceled()) {
                        continue;
                    }
                    // Process composite ids, things with the same composite id are treated as the same collider for start/end
                    const index = contact.id.indexOf('|');
                    if (index > 0) {
                        const compositeId = contact.id.substring(index + 1);
                        this._currentFrameContacts.set(compositeId, contact);
                    }
                    else {
                        this._currentFrameContacts.set(contact.id, contact);
                    }
                }
            }
        }
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
        // Process deferred collider removals
        for (const entity of this.query.entities) {
            const collider = entity.get(_ColliderComponent__WEBPACK_IMPORTED_MODULE_5__.ColliderComponent);
            if (collider) {
                collider.processColliderRemoval();
            }
        }
    }
    postupdate() {
        _Colliders_SeparatingAxis__WEBPACK_IMPORTED_MODULE_9__.SeparatingAxis.SeparationPool.done();
    }
    getSolver() {
        if (this._configDirty) {
            this._configDirty = false;
            this._arcadeSolver = new _Solver_ArcadeSolver__WEBPACK_IMPORTED_MODULE_1__.ArcadeSolver(this._physics.config.arcade);
            this._realisticSolver = new _Solver_RealisticSolver__WEBPACK_IMPORTED_MODULE_2__.RealisticSolver(this._physics.config.realistic);
        }
        return this._physics.config.solver === _SolverStrategy__WEBPACK_IMPORTED_MODULE_10__.SolverStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex, 0);
    }
    runContactStartEnd() {
        // If composite colliders are 'together' collisions may have a duplicate id because we want to treat those as a singular start/end
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                const side = _Collision_Side__WEBPACK_IMPORTED_MODULE_11__.Side.fromDirection(c.mtv);
                const opposite = _Collision_Side__WEBPACK_IMPORTED_MODULE_11__.Side.getOpposite(side);
                colliderA.events.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionStartEvent(colliderA, colliderB, side, c));
                colliderA.events.emit('contactstart', new _Events__WEBPACK_IMPORTED_MODULE_12__.ContactStartEvent(colliderA, colliderB, side, c));
                colliderB.events.emit('collisionstart', new _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionStartEvent(colliderB, colliderA, opposite, c));
                colliderB.events.emit('contactstart', new _Events__WEBPACK_IMPORTED_MODULE_12__.ContactStartEvent(colliderB, colliderA, opposite, c));
            }
        }
        // find all contacts that have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                const side = _Collision_Side__WEBPACK_IMPORTED_MODULE_11__.Side.fromDirection(c.mtv);
                const opposite = _Collision_Side__WEBPACK_IMPORTED_MODULE_11__.Side.getOpposite(side);
                colliderA.events.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionEndEvent(colliderA, colliderB, side, c));
                colliderA.events.emit('contactend', new _Events__WEBPACK_IMPORTED_MODULE_12__.ContactEndEvent(colliderA, colliderB, side, c));
                colliderB.events.emit('collisionend', new _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionEndEvent(colliderB, colliderA, opposite, c));
                colliderB.events.emit('contactend', new _Events__WEBPACK_IMPORTED_MODULE_12__.ContactEndEvent(colliderB, colliderA, opposite, c));
            }
        }
    }
}
CollisionSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_13__.SystemPriority.Higher;


/***/ }),

/***/ "./Collision/CollisionType.ts":
/*!************************************!*\
  !*** ./Collision/CollisionType.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_397978__) => {

__nested_webpack_require_397978__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_397978__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionType: () => (/* binding */ CollisionType)
/* harmony export */ });
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));


/***/ }),

/***/ "./Collision/Detection/CollisionContact.ts":
/*!*************************************************!*\
  !*** ./Collision/Detection/CollisionContact.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_399902__) => {

__nested_webpack_require_399902__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_399902__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionContact: () => (/* binding */ CollisionContact)
/* harmony export */ });
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_399902__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_399902__(/*! ./Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_399902__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");



/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        var _a, _b, _c, _d, _e, _f;
        this._canceled = false;
        this.bodyA = null;
        this.bodyB = null;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = _Pair__WEBPACK_IMPORTED_MODULE_0__.Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (colliderA.composite || colliderB.composite) {
            // Add on the parent composite pair for start/end contact if 'together
            const colliderAId = ((_a = colliderA.composite) === null || _a === void 0 ? void 0 : _a.compositeStrategy) === 'separate' ? colliderA.id : (_c = (_b = colliderA.composite) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : colliderA.id;
            const colliderBId = ((_d = colliderB.composite) === null || _d === void 0 ? void 0 : _d.compositeStrategy) === 'separate' ? colliderB.id : (_f = (_e = colliderB.composite) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : colliderB.id;
            this.id += '|' + _Pair__WEBPACK_IMPORTED_MODULE_0__.Pair.calculatePairHash(colliderAId, colliderBId);
        }
        if (this.colliderA.owner) {
            this.bodyA = this.colliderA.owner.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_1__.BodyComponent);
        }
        if (this.colliderB.owner) {
            this.bodyB = this.colliderB.owner.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_1__.BodyComponent);
        }
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.bodyA;
        const bodyB = this.bodyB;
        if (bodyA && bodyB) {
            if (bodyA.isSleeping !== bodyB.isSleeping) {
                if (bodyA.isSleeping && bodyA.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Fixed && bodyB.sleepMotion >= bodyA.wakeThreshold) {
                    bodyA.isSleeping = false;
                }
                if (bodyB.isSleeping && bodyB.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Fixed && bodyA.sleepMotion >= bodyB.wakeThreshold) {
                    bodyB.isSleeping = false;
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
    /**
     * Biases the contact so that the given collider is colliderA
     */
    bias(collider) {
        if (collider !== this.colliderA && collider !== this.colliderB) {
            throw new Error('Collider must be either colliderA or colliderB from this contact');
        }
        if (collider === this.colliderA) {
            return this;
        }
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        this.colliderB = colliderA;
        this.colliderA = colliderB;
        this.mtv = this.mtv.negate();
        this.normal = this.normal.negate();
        this.tangent = this.tangent.negate();
        return this;
    }
}


/***/ }),

/***/ "./Collision/Detection/DynamicTree.ts":
/*!********************************************!*\
  !*** ./Collision/Detection/DynamicTree.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_404281__) => {

__nested_webpack_require_404281__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_404281__.d(__nested_webpack_exports__, {
/* harmony export */   DynamicTree: () => (/* binding */ DynamicTree),
/* harmony export */   TreeNode: () => (/* binding */ TreeNode)
/* harmony export */ });
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_404281__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_404281__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_404281__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_404281__(/*! ../.. */ "./Color.ts");




/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(_config, worldBounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this._config = _config;
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= this._config.boundsPadding;
        b.top -= this._config.boundsPadding;
        b.right += this._config.boundsPadding;
        b.bottom += this._config.boundsPadding;
        // THIS IS CAUSING UNNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_2__.BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * this._config.velocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * this._config.velocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.overlaps(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, ___WEBPACK_IMPORTED_MODULE_3__.Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, ___WEBPACK_IMPORTED_MODULE_3__.Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}


/***/ }),

/***/ "./Collision/Detection/DynamicTreeCollisionProcessor.ts":
/*!**************************************************************!*\
  !*** ./Collision/Detection/DynamicTreeCollisionProcessor.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_421315__) => {

__nested_webpack_require_421315__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_421315__.d(__nested_webpack_exports__, {
/* harmony export */   DynamicTreeCollisionProcessor: () => (/* binding */ DynamicTreeCollisionProcessor)
/* harmony export */ });
/* harmony import */ var _DynamicTree__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_421315__(/*! ./DynamicTree */ "./Collision/Detection/DynamicTree.ts");
/* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_421315__(/*! ./Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_421315__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_ray__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_421315__(/*! ../../Math/ray */ "./Math/ray.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_421315__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_421315__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_421315__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_421315__(/*! ../Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_421315__(/*! ../Group/CollisionGroup */ "./Collision/Group/CollisionGroup.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_421315__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Id__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_421315__(/*! ../../Id */ "./Id.ts");











/**
 * Responsible for performing the collision broadphase (locating potential collisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor(_config) {
        this._config = _config;
        this._pairs = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
        this._dynamicCollisionTree = new _DynamicTree__WEBPACK_IMPORTED_MODULE_0__.DynamicTree(_config.dynamicTree);
    }
    getColliders() {
        return this._colliders;
    }
    query(pointOrBounds) {
        const results = [];
        if (pointOrBounds instanceof _BoundingBox__WEBPACK_IMPORTED_MODULE_1__.BoundingBox) {
            this._dynamicCollisionTree.query({
                id: (0,_Id__WEBPACK_IMPORTED_MODULE_2__.createId)('collider', -1),
                owner: null,
                bounds: pointOrBounds
            }, (other) => {
                results.push(other);
                return false;
            });
        }
        else {
            this._dynamicCollisionTree.query({
                id: (0,_Id__WEBPACK_IMPORTED_MODULE_2__.createId)('collider', -1),
                owner: null,
                bounds: new _BoundingBox__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(pointOrBounds.x, pointOrBounds.y, pointOrBounds.x, pointOrBounds.y)
            }, (other) => {
                results.push(other);
                return false;
            });
        }
        return results;
    }
    rayCast(ray, options) {
        var _a, _b, _c;
        const results = [];
        const maxDistance = (_a = options === null || options === void 0 ? void 0 : options.maxDistance) !== null && _a !== void 0 ? _a : Infinity;
        const collisionGroup = options === null || options === void 0 ? void 0 : options.collisionGroup;
        const collisionMask = !collisionGroup ? (_b = options === null || options === void 0 ? void 0 : options.collisionMask) !== null && _b !== void 0 ? _b : _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_3__.CollisionGroup.All.category : collisionGroup.category;
        const searchAllColliders = (_c = options === null || options === void 0 ? void 0 : options.searchAllColliders) !== null && _c !== void 0 ? _c : false;
        this._dynamicCollisionTree.rayCastQuery(ray, maxDistance, (collider) => {
            const owner = collider.owner;
            const maybeBody = owner.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_4__.BodyComponent);
            if ((options === null || options === void 0 ? void 0 : options.ignoreCollisionGroupAll) && maybeBody.group === _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_3__.CollisionGroup.All) {
                return false;
            }
            const canCollide = (collisionMask & maybeBody.group.category) !== 0;
            // Early exit if not the right group
            if ((maybeBody === null || maybeBody === void 0 ? void 0 : maybeBody.group) && !canCollide) {
                return false;
            }
            const hit = collider.rayCast(ray, maxDistance);
            if (hit) {
                if (options === null || options === void 0 ? void 0 : options.filter) {
                    if (options.filter(hit)) {
                        results.push(hit);
                        if (!searchAllColliders) {
                            // returning true exits the search
                            return true;
                        }
                    }
                }
                else {
                    results.push(hit);
                    if (!searchAllColliders) {
                        // returning true exits the search
                        return true;
                    }
                }
            }
            return false;
        });
        return results;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_5__.Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_6__.CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_5__.Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_6__.CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _pairExists(colliderA, colliderB) {
        // if the collision pair has been calculated already short circuit
        const hash = _Pair__WEBPACK_IMPORTED_MODULE_7__.Pair.calculatePairHash(colliderA.id, colliderB.id);
        return this._pairs.has(hash);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
     */
    broadphase(targets, elapsed, stats) {
        const seconds = elapsed / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_4__.BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.isActive) && body.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_8__.CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._pairs.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (!this._pairExists(collider, other) && _Pair__WEBPACK_IMPORTED_MODULE_7__.Pair.canCollide(collider, other)) {
                    const pair = new _Pair__WEBPACK_IMPORTED_MODULE_7__.Pair(collider, other);
                    this._pairs.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (this._config.continuous.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_4__.BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== _CollisionType__WEBPACK_IMPORTED_MODULE_8__.CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.magnitude * seconds + // velocity term
                    body.acc.magnitude * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (this._config.continuous.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.globalPos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new _Math_ray__WEBPACK_IMPORTED_MODULE_9__.Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * this._config.continuous.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new _Math_vector__WEBPACK_IMPORTED_MODULE_10__.Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + this._config.continuous.surfaceEpsilon * 2, (other) => {
                        if (!this._pairExists(collider, other) && _Pair__WEBPACK_IMPORTED_MODULE_7__.Pair.canCollide(collider, other)) {
                            const hit = other.rayCast(ray, updateDistance + this._config.continuous.surfaceEpsilon * 10);
                            if (hit) {
                                const translate = hit.point.sub(origin);
                                if (translate.magnitude < minTranslate.magnitude) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && _Math_vector__WEBPACK_IMPORTED_MODULE_10__.Vector.isValid(minTranslate)) {
                        const pair = new _Pair__WEBPACK_IMPORTED_MODULE_7__.Pair(collider, minCollider);
                        if (!this._pairs.has(pair.id)) {
                            this._pairs.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.globalPos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * this._config.continuous.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform.get());
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}


/***/ }),

/***/ "./Collision/Detection/Pair.ts":
/*!*************************************!*\
  !*** ./Collision/Detection/Pair.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_436246__) => {

__nested_webpack_require_436246__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_436246__.d(__nested_webpack_exports__, {
/* harmony export */   Pair: () => (/* binding */ Pair)
/* harmony export */ });
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_436246__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_436246__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Returns whether a it is allowed for 2 colliders in a Pair to collide
     * @param colliderA
     * @param colliderB
     */
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        // Prevent self collision
        if (colliderA.id === colliderB.id) {
            return false;
        }
        // Colliders with the same owner do not collide (composite colliders)
        if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) {
            return false;
        }
        // if the pair has a member with zero dimension don't collide
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_0__.BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_0__.BodyComponent);
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_1__.CollisionType.Fixed && bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_1__.CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_1__.CollisionType.PreventCollision || bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_1__.CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.isActive || !bodyB.isActive) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}


/***/ }),

/***/ "./Collision/Detection/QuadTree.ts":
/*!*****************************************!*\
  !*** ./Collision/Detection/QuadTree.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_440439__) => {

__nested_webpack_require_440439__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_440439__.d(__nested_webpack_exports__, {
/* harmony export */   QuadTree: () => (/* binding */ QuadTree)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_440439__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_440439__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");


/**
 * QuadTree spatial data structure. Useful for quickly retrieving all objects that might
 * be in a specific location.
 */
class QuadTree {
    constructor(bounds, options) {
        this.bounds = bounds;
        this.options = options;
        this._defaultOptions = {
            maxDepth: 10,
            capacity: 10,
            level: 0
        };
        this.items = [];
        this._isDivided = false;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
        this.options = { ...this._defaultOptions, ...options };
        this.halfWidth = bounds.width / 2;
        this.halfHeight = bounds.height / 2;
    }
    /**
     * Splits the quad tree one level deeper
     */
    _split() {
        this._isDivided = true;
        const newLevelOptions = {
            maxDepth: this.options.maxDepth,
            capacity: this.options.capacity,
            level: this.options.level + 1
        };
        this.topLeft = new QuadTree(new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({
            left: this.bounds.left,
            top: this.bounds.top,
            right: this.bounds.left + this.halfWidth,
            bottom: this.bounds.top + this.halfHeight
        }), newLevelOptions);
        this.topRight = new QuadTree(new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({
            left: this.bounds.left + this.halfWidth,
            top: this.bounds.top,
            right: this.bounds.right,
            bottom: this.bounds.top + this.halfHeight
        }), newLevelOptions);
        this.bottomLeft = new QuadTree(new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({
            left: this.bounds.left,
            top: this.bounds.top + this.halfHeight,
            right: this.bounds.left + this.halfWidth,
            bottom: this.bounds.bottom
        }), newLevelOptions);
        this.bottomRight = new QuadTree(new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({
            left: this.bounds.left + this.halfWidth,
            top: this.bounds.top + this.halfHeight,
            right: this.bounds.right,
            bottom: this.bounds.bottom
        }), newLevelOptions);
    }
    _insertIntoSubNodes(item) {
        var _a, _b, _c, _d;
        if ((_a = this.topLeft) === null || _a === void 0 ? void 0 : _a.bounds.overlaps(item.bounds)) {
            this.topLeft.insert(item);
        }
        if ((_b = this.topRight) === null || _b === void 0 ? void 0 : _b.bounds.overlaps(item.bounds)) {
            this.topRight.insert(item);
        }
        if ((_c = this.bottomLeft) === null || _c === void 0 ? void 0 : _c.bounds.overlaps(item.bounds)) {
            this.bottomLeft.insert(item);
        }
        if ((_d = this.bottomRight) === null || _d === void 0 ? void 0 : _d.bounds.overlaps(item.bounds)) {
            this.bottomRight.insert(item);
        }
    }
    /**
     * Insert an item to be tracked in the QuadTree
     * @param item
     */
    insert(item) {
        // add to subnodes if it matches
        if (this._isDivided) {
            this._insertIntoSubNodes(item);
            return;
        }
        // leaf case
        this.items.push(item);
        // capacity
        if (this.items.length > this.options.capacity && this.options.level < this.options.maxDepth) {
            if (!this._isDivided) {
                this._split();
            }
            // divide this level's items into it's subnodes
            for (const item of this.items) {
                this._insertIntoSubNodes(item);
            }
            // clear this level
            this.items.length = 0;
        }
    }
    /**
     * Remove a tracked item in the QuadTree
     * @param item
     */
    remove(item) {
        var _a, _b, _c, _d;
        if (!this.bounds.overlaps(item.bounds)) {
            return;
        }
        if (!this._isDivided) {
            const index = this.items.indexOf(item);
            if (index > -1) {
                this.items.splice(index, 1);
            }
            return;
        }
        if ((_a = this.topLeft) === null || _a === void 0 ? void 0 : _a.bounds.overlaps(item.bounds)) {
            this.topLeft.remove(item);
        }
        if ((_b = this.topRight) === null || _b === void 0 ? void 0 : _b.bounds.overlaps(item.bounds)) {
            this.topRight.remove(item);
        }
        if ((_c = this.bottomLeft) === null || _c === void 0 ? void 0 : _c.bounds.overlaps(item.bounds)) {
            this.bottomLeft.remove(item);
        }
        if ((_d = this.bottomRight) === null || _d === void 0 ? void 0 : _d.bounds.overlaps(item.bounds)) {
            this.bottomRight.remove(item);
        }
    }
    /**
     * Query the structure for all objects that intersect the bounding box
     * @param boundingBox
     * @returns items
     */
    query(boundingBox) {
        let results = this.items;
        if (this._isDivided) {
            if (this.topLeft.bounds.overlaps(boundingBox)) {
                results = results.concat(this.topLeft.query(boundingBox));
            }
            if (this.topRight.bounds.overlaps(boundingBox)) {
                results = results.concat(this.topRight.query(boundingBox));
            }
            if (this.bottomLeft.bounds.overlaps(boundingBox)) {
                results = results.concat(this.bottomLeft.query(boundingBox));
            }
            if (this.bottomRight.bounds.overlaps(boundingBox)) {
                results = results.concat(this.bottomRight.query(boundingBox));
            }
        }
        results = results.filter((item, index) => {
            return results.indexOf(item) >= index;
        });
        return results;
    }
    clear() {
        this.items = [];
        this._isDivided = false;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }
    getAllItems() {
        let results = this.items;
        if (this._isDivided) {
            results = results.concat(this.topLeft.getAllItems());
            results = results.concat(this.topRight.getAllItems());
            results = results.concat(this.bottomLeft.getAllItems());
            results = results.concat(this.bottomRight.getAllItems());
        }
        results = results.filter((item, index) => {
            return results.indexOf(item) >= index;
        });
        return results;
    }
    getTreeDepth() {
        if (!this._isDivided) {
            return 0;
        }
        return (1 +
            Math.max(this.topLeft.getTreeDepth(), this.topRight.getTreeDepth(), this.bottomLeft.getTreeDepth(), this.bottomRight.getTreeDepth()));
    }
    debug(ctx) {
        this.bounds.draw(ctx, _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Yellow);
        if (this._isDivided) {
            this.topLeft.bounds.draw(ctx, _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Yellow);
            this.topRight.bounds.draw(ctx, _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Yellow);
            this.bottomLeft.bounds.draw(ctx, _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Yellow);
            this.bottomRight.bounds.draw(ctx, _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Yellow);
        }
    }
}


/***/ }),

/***/ "./Collision/Detection/SparseHashGrid.ts":
/*!***********************************************!*\
  !*** ./Collision/Detection/SparseHashGrid.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_448416__) => {

__nested_webpack_require_448416__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_448416__.d(__nested_webpack_exports__, {
/* harmony export */   HashGridCell: () => (/* binding */ HashGridCell),
/* harmony export */   HashGridProxy: () => (/* binding */ HashGridProxy),
/* harmony export */   SparseHashGrid: () => (/* binding */ SparseHashGrid)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_448416__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_448416__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_448416__(/*! ../../Util/RentalPool */ "./Util/RentalPool.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_448416__(/*! ../BoundingBox */ "./Collision/BoundingBox.ts");




class HashGridProxy {
    constructor(object, gridSize) {
        this.object = object;
        this.id = -1;
        this.cells = [];
        this.hasZeroBounds = false;
        this.gridSize = gridSize;
        this.bounds = object.bounds;
        this.hasZeroBounds = this.bounds.hasZeroDimensions();
        this.leftX = Math.floor(this.bounds.left / this.gridSize);
        this.rightX = Math.floor(this.bounds.right / this.gridSize);
        this.bottomY = Math.floor(this.bounds.bottom / this.gridSize);
        this.topY = Math.floor(this.bounds.top / this.gridSize);
    }
    /**
     * Has the hashed bounds changed
     */
    hasChanged() {
        const bounds = this.object.bounds;
        const leftX = Math.floor(bounds.left / this.gridSize);
        const rightX = Math.floor(bounds.right / this.gridSize);
        const bottomY = Math.floor(bounds.bottom / this.gridSize);
        const topY = Math.floor(bounds.top / this.gridSize);
        if (this.leftX !== leftX || this.rightX !== rightX || this.bottomY !== bottomY || this.topY !== topY) {
            return true;
        }
        return false;
    }
    /**
     * Clears all collider references
     */
    clear() {
        for (const cell of this.cells) {
            const index = cell.proxies.indexOf(this);
            if (index > -1) {
                cell.proxies.splice(index, 1);
            }
            // TODO reclaim cell in pool if empty?
        }
    }
    /**
     * Update bounds of the proxy
     */
    updateBounds() {
        this.bounds = this.object.bounds;
    }
    /**
     * Updates the hashed bounds coordinates
     */
    update() {
        this.bounds = this.object.bounds;
        this.leftX = Math.floor(this.bounds.left / this.gridSize);
        this.rightX = Math.floor(this.bounds.right / this.gridSize);
        this.bottomY = Math.floor(this.bounds.bottom / this.gridSize);
        this.topY = Math.floor(this.bounds.top / this.gridSize);
        this.hasZeroBounds = this.object.bounds.hasZeroDimensions();
    }
}
class HashGridCell {
    constructor() {
        this.proxies = [];
    }
    configure(x, y) {
        this.x = x;
        this.y = y;
        this.key = HashGridCell.calculateHashKey(x, y);
    }
    static calculateHashKey(x, y) {
        return `${x}+${y}`;
    }
}
class SparseHashGrid {
    constructor(options) {
        this.bounds = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();
        this._hashGridCellPool = new _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__.RentalPool(() => new HashGridCell(), (instance) => {
            instance.configure(0, 0);
            instance.proxies.length = 0;
            return instance;
        }, 1000);
        this.gridSize = options.size;
        this.sparseHashGrid = new Map();
        this.objectToProxy = new Map();
        if (options.proxyFactory) {
            this._buildProxy = (object) => options.proxyFactory(object, this.gridSize);
        }
        else {
            this._buildProxy = (object) => new HashGridProxy(object, this.gridSize);
        }
        // TODO dynamic grid size potentially larger than the largest collider
        // TODO Re-hash the objects if the median proves to be different
    }
    query(boundsOrPoint) {
        const results = new Set();
        if (boundsOrPoint instanceof _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox) {
            const bounds = boundsOrPoint;
            const leftX = Math.floor(bounds.left / this.gridSize);
            const rightX = Math.floor(bounds.right / this.gridSize);
            const bottomY = Math.floor(bounds.bottom / this.gridSize);
            const topY = Math.floor(bounds.top / this.gridSize);
            for (let x = leftX; x <= rightX; x++) {
                for (let y = topY; y <= bottomY; y++) {
                    const key = HashGridCell.calculateHashKey(x, y);
                    // Hash bounds into appropriate cell
                    const cell = this.sparseHashGrid.get(key);
                    if (cell) {
                        for (let i = 0; i < cell.proxies.length; i++) {
                            cell.proxies[i].updateBounds();
                            if (cell.proxies[i].bounds.intersect(bounds)) {
                                results.add(cell.proxies[i].object);
                            }
                        }
                    }
                }
            }
        }
        else {
            const point = boundsOrPoint;
            const key = HashGridCell.calculateHashKey(Math.floor(point.x / this.gridSize), Math.floor(point.y / this.gridSize));
            // Hash points into appropriate cell
            const cell = this.sparseHashGrid.get(key);
            if (cell) {
                for (let i = 0; i < cell.proxies.length; i++) {
                    cell.proxies[i].updateBounds();
                    if (cell.proxies[i].bounds.contains(point)) {
                        results.add(cell.proxies[i].object);
                    }
                }
            }
        }
        return Array.from(results);
    }
    get(xCoord, yCoord) {
        const key = HashGridCell.calculateHashKey(xCoord, yCoord);
        const cell = this.sparseHashGrid.get(key);
        return cell;
    }
    _insert(x, y, proxy) {
        const key = HashGridCell.calculateHashKey(x, y);
        // Hash collider into appropriate cell
        let cell = this.sparseHashGrid.get(key);
        if (!cell) {
            cell = this._hashGridCellPool.rent();
            cell.configure(x, y);
            this.sparseHashGrid.set(cell.key, cell);
        }
        cell.proxies.push(proxy);
        proxy.cells.push(cell); // TODO dupes, doesn't seem to be a problem
        this.bounds.combine(proxy.bounds, this.bounds);
    }
    _remove(x, y, proxy) {
        const key = HashGridCell.calculateHashKey(x, y);
        // Hash collider into appropriate cell
        const cell = this.sparseHashGrid.get(key);
        if (cell) {
            const proxyIndex = cell.proxies.indexOf(proxy);
            if (proxyIndex > -1) {
                cell.proxies.splice(proxyIndex, 1);
            }
            const cellIndex = proxy.cells.indexOf(cell);
            if (cellIndex > -1) {
                proxy.cells.splice(cellIndex, 1);
            }
            if (cell.proxies.length === 0) {
                this._hashGridCellPool.return(cell);
                this.sparseHashGrid.delete(key);
            }
        }
    }
    track(target) {
        const proxy = this._buildProxy(target);
        this.objectToProxy.set(target, proxy);
        for (let x = proxy.leftX; x <= proxy.rightX; x++) {
            for (let y = proxy.topY; y <= proxy.bottomY; y++) {
                this._insert(x, y, proxy);
            }
        }
    }
    untrack(target) {
        const proxy = this.objectToProxy.get(target);
        if (proxy) {
            proxy.clear();
            this.objectToProxy.delete(target);
        }
    }
    update(targets) {
        let updated = 0;
        // FIXME resetting bounds is wrong, if nothing has updated then
        // the bounds stay 0
        // this.bounds.reset();
        for (const target of targets) {
            const proxy = this.objectToProxy.get(target);
            if (!proxy) {
                continue;
            }
            if (proxy.hasChanged()) {
                // TODO slightly wasteful only remove from changed
                for (let x = proxy.leftX; x <= proxy.rightX; x++) {
                    for (let y = proxy.topY; y <= proxy.bottomY; y++) {
                        this._remove(x, y, proxy);
                    }
                }
                proxy.update();
                // TODO slightly wasteful only add new
                for (let x = proxy.leftX; x <= proxy.rightX; x++) {
                    for (let y = proxy.topY; y <= proxy.bottomY; y++) {
                        this._insert(x, y, proxy);
                    }
                }
                updated++;
            }
        }
        return updated;
    }
    debug(ex, elapsed) {
        const transparent = _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Transparent;
        const color = _Color__WEBPACK_IMPORTED_MODULE_2__.Color.White;
        for (const cell of this.sparseHashGrid.values()) {
            ex.drawRectangle((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(cell.x * this.gridSize, cell.y * this.gridSize), this.gridSize, this.gridSize, transparent, color, 2);
        }
    }
}


/***/ }),

/***/ "./Collision/Detection/SparseHashGridCollisionProcessor.ts":
/*!*****************************************************************!*\
  !*** ./Collision/Detection/SparseHashGridCollisionProcessor.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_458174__) => {

__nested_webpack_require_458174__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_458174__.d(__nested_webpack_exports__, {
/* harmony export */   HashColliderProxy: () => (/* binding */ HashColliderProxy),
/* harmony export */   SparseHashGridCollisionProcessor: () => (/* binding */ SparseHashGridCollisionProcessor)
/* harmony export */ });
/* harmony import */ var _Id__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_458174__(/*! ../../Id */ "./Id.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_458174__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_Pool__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_458174__(/*! ../../Util/Pool */ "./Util/Pool.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_458174__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_458174__(/*! ../Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_458174__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_458174__(/*! ../Group/CollisionGroup */ "./Collision/Group/CollisionGroup.ts");
/* harmony import */ var _Pair__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_458174__(/*! ./Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _SparseHashGrid__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_458174__(/*! ./SparseHashGrid */ "./Collision/Detection/SparseHashGrid.ts");









/**
 * Proxy type to stash collision info
 */
class HashColliderProxy extends _SparseHashGrid__WEBPACK_IMPORTED_MODULE_0__.HashGridProxy {
    constructor(collider, gridSize) {
        var _a, _b;
        super(collider, gridSize);
        this.collider = collider;
        this.id = -1;
        this.hasZeroBounds = false;
        /**
         * References to the hash cell the collider is a current member of
         */
        this.cells = [];
        this.gridSize = gridSize;
        const bounds = collider.bounds;
        this.hasZeroBounds = bounds.hasZeroDimensions();
        this.leftX = Math.floor(bounds.left / this.gridSize);
        this.rightX = Math.floor(bounds.right / this.gridSize);
        this.bottomY = Math.floor(bounds.bottom / this.gridSize);
        this.topY = Math.floor(bounds.top / this.gridSize);
        this.owner = collider.owner;
        this.body = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_1__.BodyComponent);
        this.collisionType = (_b = this.body.collisionType) !== null && _b !== void 0 ? _b : _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.PreventCollision;
    }
    /**
     * Updates the hashed bounds coordinates
     */
    update() {
        var _a, _b;
        super.update();
        this.body = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_1__.BodyComponent);
        this.collisionType = (_b = this.body.collisionType) !== null && _b !== void 0 ? _b : _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.PreventCollision;
        this.hasZeroBounds = this.collider.localBounds.hasZeroDimensions();
    }
}
/**
 * This collision processor uses a sparsely populated grid of uniform cells to bucket potential
 * colliders together for the purpose of detecting collision pairs and collisions.
 */
class SparseHashGridCollisionProcessor {
    constructor(options) {
        this._pairs = new Set();
        this._nonPairs = new Set();
        this._pairPool = new _Util_Pool__WEBPACK_IMPORTED_MODULE_3__.Pool(() => new _Pair__WEBPACK_IMPORTED_MODULE_4__.Pair({ id: (0,_Id__WEBPACK_IMPORTED_MODULE_5__.createId)('collider', 0) }, { id: (0,_Id__WEBPACK_IMPORTED_MODULE_5__.createId)('collider', 0) }), (instance) => {
            instance.colliderA = null;
            instance.colliderB = null;
            return instance;
        }, 200);
        this.gridSize = options.size;
        this.hashGrid = new _SparseHashGrid__WEBPACK_IMPORTED_MODULE_0__.SparseHashGrid({
            size: this.gridSize,
            proxyFactory: (collider, size) => new HashColliderProxy(collider, size)
        });
        this._pairPool.disableWarnings = true;
        // TODO dynamic grid size potentially larger than the largest collider
        // TODO Re-hash the objects if the median proves to be different
    }
    getColliders() {
        return Array.from(this.hashGrid.objectToProxy.keys());
    }
    query(boundsOrPoint) {
        // FIXME workaround TS: https://github.com/microsoft/TypeScript/issues/14107
        return this.hashGrid.query(boundsOrPoint);
    }
    rayCast(ray, options) {
        var _a, _b, _c;
        // DDA raycast algo
        const results = [];
        const maxDistance = (_a = options === null || options === void 0 ? void 0 : options.maxDistance) !== null && _a !== void 0 ? _a : Infinity;
        const collisionGroup = options === null || options === void 0 ? void 0 : options.collisionGroup;
        const collisionMask = !collisionGroup ? (_b = options === null || options === void 0 ? void 0 : options.collisionMask) !== null && _b !== void 0 ? _b : _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_6__.CollisionGroup.All.category : collisionGroup.category;
        const searchAllColliders = (_c = options === null || options === void 0 ? void 0 : options.searchAllColliders) !== null && _c !== void 0 ? _c : false;
        const unitRay = ray.dir.normalize();
        const dydx = unitRay.y / unitRay.x;
        const dxdy = unitRay.x / unitRay.y;
        const unitStepX = Math.sqrt(1 + dydx * dydx) * this.gridSize;
        const unitStepY = Math.sqrt(1 + dxdy * dxdy) * this.gridSize;
        const startXCoord = ray.pos.x / this.gridSize;
        const startYCoord = ray.pos.y / this.gridSize;
        const stepDir = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(1, 1);
        let currentXCoord = ~~startXCoord;
        let currentYCoord = ~~startYCoord;
        let currentRayLengthX = 0;
        let currentRayLengthY = 0;
        if (unitRay.x < 0) {
            stepDir.x = -1;
            currentRayLengthX = (startXCoord - currentXCoord) * unitStepX;
        }
        else {
            stepDir.x = 1;
            currentRayLengthX = (currentXCoord + 1 - startXCoord) * unitStepX;
        }
        if (unitRay.y < 0) {
            stepDir.y = -1;
            currentRayLengthY = (startYCoord - currentYCoord) * unitStepY;
        }
        else {
            stepDir.y = 1;
            currentRayLengthY = (currentYCoord + 1 - startYCoord) * unitStepY;
        }
        const collidersVisited = new Set();
        let done = false;
        let maxIterations = 9999;
        while (!done && maxIterations > 0) {
            maxIterations--; // safety exit
            // exit if exhausted max hash grid coordinate, bounds of the sparse grid
            if (!this.hashGrid.bounds.contains((0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(currentXCoord * this.gridSize, currentYCoord * this.gridSize))) {
                break;
            }
            // Test colliders at cell
            const key = _SparseHashGrid__WEBPACK_IMPORTED_MODULE_0__.HashGridCell.calculateHashKey(currentXCoord, currentYCoord);
            const cell = this.hashGrid.sparseHashGrid.get(key);
            if (cell) {
                const cellHits = [];
                for (let colliderIndex = 0; colliderIndex < cell.proxies.length; colliderIndex++) {
                    const collider = cell.proxies[colliderIndex];
                    if (!collidersVisited.has(collider.collider.id.value)) {
                        collidersVisited.add(collider.collider.id.value);
                        if ((options === null || options === void 0 ? void 0 : options.ignoreCollisionGroupAll) && collider.body.group === _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_6__.CollisionGroup.All) {
                            continue;
                        }
                        const canCollide = (collisionMask & collider.body.group.category) !== 0;
                        // Early exit if not the right group
                        if (collider.body.group && !canCollide) {
                            continue;
                        }
                        const hit = collider.collider.rayCast(ray, maxDistance);
                        // Collect up all the colliders that hit inside a cell
                        // they can be in any order so we need to sort them next
                        if (hit) {
                            cellHits.push(hit);
                        }
                    }
                }
                cellHits.sort((hit1, hit2) => hit1.distance - hit2.distance);
                for (let i = 0; i < cellHits.length; i++) {
                    const hit = cellHits[i];
                    if (options === null || options === void 0 ? void 0 : options.filter) {
                        if (options.filter(hit)) {
                            results.push(hit);
                            if (!searchAllColliders) {
                                done = true;
                                break;
                            }
                        }
                    }
                    else {
                        results.push(hit);
                        if (!searchAllColliders) {
                            done = true;
                            break;
                        }
                    }
                }
            }
            if (currentRayLengthX < currentRayLengthY) {
                currentXCoord += stepDir.x;
                currentRayLengthX += unitStepX;
            }
            else {
                currentYCoord += stepDir.y;
                currentRayLengthY += unitStepY;
            }
        }
        // Sort by distance
        results.sort((hit1, hit2) => hit1.distance - hit2.distance);
        if (!searchAllColliders && results.length) {
            return [results[0]];
        }
        return results;
    }
    /**
     * Adds the collider to the internal data structure for collision tracking
     * @param target
     */
    track(target) {
        let colliders = [target];
        if (target instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_8__.CompositeCollider) {
            const compColliders = target.getColliders();
            for (const c of compColliders) {
                c.owner = target.owner;
            }
            colliders = compColliders;
        }
        for (const target of colliders) {
            this.hashGrid.track(target);
        }
    }
    /**
     * Removes a collider from the internal data structure for tracking collisions
     * @param target
     */
    untrack(target) {
        let colliders = [target];
        if (target instanceof _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_8__.CompositeCollider) {
            colliders = target.getColliders();
        }
        for (const target of colliders) {
            this.hashGrid.untrack(target);
        }
    }
    _canCollide(colliderA, colliderB) {
        // Prevent self collision
        if (colliderA.collider.id === colliderB.collider.id) {
            return false;
        }
        // Colliders with the same owner do not collide (composite colliders)
        if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) {
            return false;
        }
        // if the pair has a member with zero dimension don't collide
        if (colliderA.hasZeroBounds || colliderB.hasZeroBounds) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!colliderA.body.group.canCollide(colliderB.body.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (colliderA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Fixed && colliderB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (colliderA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.PreventCollision || colliderB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!colliderA.owner.isActive || !colliderB.owner.isActive) {
            return false;
        }
        return true;
    }
    /**
     * Runs the broadphase sweep over tracked colliders and returns possible collision pairs
     * @param targets
     * @param elapsed
     */
    broadphase(targets, elapsed) {
        const pairs = [];
        this._pairs.clear();
        this._nonPairs.clear();
        let proxyId = 0;
        for (const proxy of this.hashGrid.objectToProxy.values()) {
            proxy.id = proxyId++; // track proxies we've already processed
            if (!proxy.owner.isActive || proxy.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.PreventCollision) {
                continue;
            }
            // for every cell proxy collider is member of
            for (let cellIndex = 0; cellIndex < proxy.cells.length; cellIndex++) {
                const cell = proxy.cells[cellIndex];
                // TODO Can we skip any cells or make this iteration faster?
                // maybe a linked list here
                for (let otherIndex = 0; otherIndex < cell.proxies.length; otherIndex++) {
                    const other = cell.proxies[otherIndex];
                    if (other.id === proxy.id) {
                        // skip duplicates
                        continue;
                    }
                    const id = _Pair__WEBPACK_IMPORTED_MODULE_4__.Pair.calculatePairHash(proxy.collider.id, other.collider.id);
                    if (this._nonPairs.has(id)) {
                        continue; // Is there a way we can re-use the non-pair cache
                    }
                    if (!this._pairs.has(id) && this._canCollide(proxy, other) && proxy.object.bounds.overlaps(other.object.bounds)) {
                        const pair = this._pairPool.get();
                        pair.colliderA = proxy.collider;
                        pair.colliderB = other.collider;
                        pair.id = id;
                        this._pairs.add(id);
                        pairs.push(pair);
                    }
                    else {
                        this._nonPairs.add(id);
                    }
                }
            }
        }
        return pairs;
    }
    /**
     * Runs a fine grain pass on collision pairs and does geometry intersection tests producing any contacts
     * @param pairs
     * @param stats
     */
    narrowphase(pairs, stats) {
        const contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            for (let j = 0; j < newContacts.length; j++) {
                const c = newContacts[j];
                contacts.push(c);
                if (stats) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        this._pairPool.done();
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts; // TODO maybe we can re-use contacts as likely pairs next frame
    }
    /**
     * Perform data structure maintenance, returns number of colliders updated
     */
    update(targets, elapsed) {
        return this.hashGrid.update(targets);
    }
    /**
     * Draws the internal data structure
     * @param ex
     * @param elapsed
     */
    debug(ex, elapsed) {
        this.hashGrid.debug(ex, elapsed);
    }
}


/***/ }),

/***/ "./Collision/Detection/SpatialPartitionStrategy.ts":
/*!*********************************************************!*\
  !*** ./Collision/Detection/SpatialPartitionStrategy.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_474531__) => {

__nested_webpack_require_474531__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_474531__.d(__nested_webpack_exports__, {
/* harmony export */   SpatialPartitionStrategy: () => (/* binding */ SpatialPartitionStrategy)
/* harmony export */ });
/**
 * Possible collision resolution strategies
 *
 * The default is {@apilink SolverStrategy.Arcade} which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting {@apilink SolverStrategy.Realistic} which allows for complicated
 * simulated physical interactions.
 */
var SpatialPartitionStrategy;
(function (SpatialPartitionStrategy) {
    SpatialPartitionStrategy["DynamicTree"] = "dynamic-tree";
    SpatialPartitionStrategy["SparseHashGrid"] = "sparse-hash-grid";
})(SpatialPartitionStrategy || (SpatialPartitionStrategy = {}));


/***/ }),

/***/ "./Collision/Group/CollisionGroup.ts":
/*!*******************************************!*\
  !*** ./Collision/Group/CollisionGroup.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_475703__) => {

__nested_webpack_require_475703__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_475703__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionGroup: () => (/* binding */ CollisionGroup)
/* harmony export */ });
/* harmony import */ var _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_475703__(/*! ./CollisionGroupManager */ "./Collision/Group/CollisionGroupManager.ts");

/**
 * CollisionGroups indicate like members that do not collide with each other. Use {@apilink CollisionGroupManager} to create {@apilink CollisionGroup}s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that {@apilink CollisionGroupManager.create} is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     *
     * This means the mask has the same bit set the other category and vice versa
     * @param other  CollisionGroup
     */
    canCollide(other) {
        const overlap1 = this.category & other.mask;
        const overlap2 = this.mask & other.category;
        return overlap1 !== 0 && overlap2 !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        const group = _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_0__.CollisionGroupManager.create('~(' + this.name + ')', ~this.mask | 0);
        group._category = ~this.category;
        return group;
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     * @param collisionGroups
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_0__.CollisionGroupManager.create(combinedName, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        const combinedName = `collidesWith(${collisionGroups.map((c) => c.name).join('+')})`;
        const combinedMask = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        return _CollisionGroupManager__WEBPACK_IMPORTED_MODULE_0__.CollisionGroupManager.create(combinedName, combinedMask);
    }
    toString() {
        return `
category: ${this.category.toString(2).padStart(32, '0')}
mask:     ${(this.mask >>> 0).toString(2).padStart(32, '0')}
    `;
    }
}
/**
 * The `All` {@apilink CollisionGroup} is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);


/***/ }),

/***/ "./Collision/Group/CollisionGroupManager.ts":
/*!**************************************************!*\
  !*** ./Collision/Group/CollisionGroupManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_481123__) => {

__nested_webpack_require_481123__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_481123__.d(__nested_webpack_exports__, {
/* harmony export */   CollisionGroupManager: () => (/* binding */ CollisionGroupManager)
/* harmony export */ });
/* harmony import */ var _CollisionGroup__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_481123__(/*! ./CollisionGroup */ "./Collision/Group/CollisionGroup.ts");

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            const existingGroup = this._GROUPS.get(name);
            if (existingGroup.mask === mask) {
                return existingGroup;
            }
            throw new Error(`Collision group ${name} already exists with a different mask!`);
        }
        const group = new _CollisionGroup__WEBPACK_IMPORTED_MODULE_0__.CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();


/***/ }),

/***/ "./Collision/Index.ts":
/*!****************************!*\
  !*** ./Collision/Index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_483826__) => {

__nested_webpack_require_483826__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_483826__.d(__nested_webpack_exports__, {
/* harmony export */   ArcadeSolver: () => (/* reexport safe */ _Solver_ArcadeSolver__WEBPACK_IMPORTED_MODULE_24__.ArcadeSolver),
/* harmony export */   BodyComponent: () => (/* reexport safe */ _BodyComponent__WEBPACK_IMPORTED_MODULE_0__.BodyComponent),
/* harmony export */   BoundingBox: () => (/* reexport safe */ _BoundingBox__WEBPACK_IMPORTED_MODULE_5__.BoundingBox),
/* harmony export */   CircleCollider: () => (/* reexport safe */ _Colliders_CircleCollider__WEBPACK_IMPORTED_MODULE_8__.CircleCollider),
/* harmony export */   ClosestLineJumpTable: () => (/* reexport safe */ _Colliders_ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_12__.ClosestLineJumpTable),
/* harmony export */   Collider: () => (/* reexport safe */ _Colliders_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider),
/* harmony export */   ColliderComponent: () => (/* reexport safe */ _ColliderComponent__WEBPACK_IMPORTED_MODULE_1__.ColliderComponent),
/* harmony export */   CollisionContact: () => (/* reexport safe */ _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_17__.CollisionContact),
/* harmony export */   CollisionGroup: () => (/* reexport safe */ _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_14__.CollisionGroup),
/* harmony export */   CollisionGroupManager: () => (/* reexport safe */ _Group_CollisionGroupManager__WEBPACK_IMPORTED_MODULE_15__.CollisionGroupManager),
/* harmony export */   CollisionJumpTable: () => (/* reexport safe */ _Colliders_CollisionJumpTable__WEBPACK_IMPORTED_MODULE_11__.CollisionJumpTable),
/* harmony export */   CollisionSystem: () => (/* reexport safe */ _CollisionSystem__WEBPACK_IMPORTED_MODULE_28__.CollisionSystem),
/* harmony export */   CollisionType: () => (/* reexport safe */ _CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType),
/* harmony export */   CompositeCollider: () => (/* reexport safe */ _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_7__.CompositeCollider),
/* harmony export */   ContactConstraintPoint: () => (/* reexport safe */ _Solver_ContactConstraintPoint__WEBPACK_IMPORTED_MODULE_26__.ContactConstraintPoint),
/* harmony export */   ContactSolveBias: () => (/* reexport safe */ _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_25__.ContactSolveBias),
/* harmony export */   DegreeOfFreedom: () => (/* reexport safe */ _BodyComponent__WEBPACK_IMPORTED_MODULE_0__.DegreeOfFreedom),
/* harmony export */   DynamicTree: () => (/* reexport safe */ _Detection_DynamicTree__WEBPACK_IMPORTED_MODULE_18__.DynamicTree),
/* harmony export */   DynamicTreeCollisionProcessor: () => (/* reexport safe */ _Detection_DynamicTreeCollisionProcessor__WEBPACK_IMPORTED_MODULE_19__.DynamicTreeCollisionProcessor),
/* harmony export */   EdgeCollider: () => (/* reexport safe */ _Colliders_EdgeCollider__WEBPACK_IMPORTED_MODULE_9__.EdgeCollider),
/* harmony export */   HashColliderProxy: () => (/* reexport safe */ _Detection_SparseHashGridCollisionProcessor__WEBPACK_IMPORTED_MODULE_20__.HashColliderProxy),
/* harmony export */   HashGridCell: () => (/* reexport safe */ _Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_21__.HashGridCell),
/* harmony export */   HashGridProxy: () => (/* reexport safe */ _Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_21__.HashGridProxy),
/* harmony export */   HorizontalFirst: () => (/* reexport safe */ _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_25__.HorizontalFirst),
/* harmony export */   MotionSystem: () => (/* reexport safe */ _MotionSystem__WEBPACK_IMPORTED_MODULE_29__.MotionSystem),
/* harmony export */   None: () => (/* reexport safe */ _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_25__.None),
/* harmony export */   Pair: () => (/* reexport safe */ _Detection_Pair__WEBPACK_IMPORTED_MODULE_16__.Pair),
/* harmony export */   PhysicsWorld: () => (/* reexport safe */ _PhysicsWorld__WEBPACK_IMPORTED_MODULE_30__.PhysicsWorld),
/* harmony export */   PolygonCollider: () => (/* reexport safe */ _Colliders_PolygonCollider__WEBPACK_IMPORTED_MODULE_10__.PolygonCollider),
/* harmony export */   QuadTree: () => (/* reexport safe */ _Detection_QuadTree__WEBPACK_IMPORTED_MODULE_23__.QuadTree),
/* harmony export */   RealisticSolver: () => (/* reexport safe */ _Solver_RealisticSolver__WEBPACK_IMPORTED_MODULE_27__.RealisticSolver),
/* harmony export */   SeparatingAxis: () => (/* reexport safe */ _Colliders_SeparatingAxis__WEBPACK_IMPORTED_MODULE_13__.SeparatingAxis),
/* harmony export */   SeparationInfo: () => (/* reexport safe */ _Colliders_SeparatingAxis__WEBPACK_IMPORTED_MODULE_13__.SeparationInfo),
/* harmony export */   Shape: () => (/* reexport safe */ _Colliders_Shape__WEBPACK_IMPORTED_MODULE_6__.Shape),
/* harmony export */   Side: () => (/* reexport safe */ _Side__WEBPACK_IMPORTED_MODULE_32__.Side),
/* harmony export */   SolverStrategy: () => (/* reexport safe */ _SolverStrategy__WEBPACK_IMPORTED_MODULE_3__.SolverStrategy),
/* harmony export */   SparseHashGrid: () => (/* reexport safe */ _Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_21__.SparseHashGrid),
/* harmony export */   SparseHashGridCollisionProcessor: () => (/* reexport safe */ _Detection_SparseHashGridCollisionProcessor__WEBPACK_IMPORTED_MODULE_20__.SparseHashGridCollisionProcessor),
/* harmony export */   SpatialPartitionStrategy: () => (/* reexport safe */ _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_22__.SpatialPartitionStrategy),
/* harmony export */   TreeNode: () => (/* reexport safe */ _Detection_DynamicTree__WEBPACK_IMPORTED_MODULE_18__.TreeNode),
/* harmony export */   VerticalFirst: () => (/* reexport safe */ _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_25__.VerticalFirst),
/* harmony export */   getDefaultPhysicsConfig: () => (/* reexport safe */ _PhysicsConfig__WEBPACK_IMPORTED_MODULE_31__.getDefaultPhysicsConfig)
/* harmony export */ });
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_483826__(/*! ./BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _ColliderComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_483826__(/*! ./ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_483826__(/*! ./CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _SolverStrategy__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_483826__(/*! ./SolverStrategy */ "./Collision/SolverStrategy.ts");
/* harmony import */ var _Colliders_Collider__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_483826__(/*! ./Colliders/Collider */ "./Collision/Colliders/Collider.ts");
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_483826__(/*! ./BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Colliders_Shape__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_483826__(/*! ./Colliders/Shape */ "./Collision/Colliders/Shape.ts");
/* harmony import */ var _Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_483826__(/*! ./Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Colliders_CircleCollider__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_483826__(/*! ./Colliders/CircleCollider */ "./Collision/Colliders/CircleCollider.ts");
/* harmony import */ var _Colliders_EdgeCollider__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_483826__(/*! ./Colliders/EdgeCollider */ "./Collision/Colliders/EdgeCollider.ts");
/* harmony import */ var _Colliders_PolygonCollider__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_483826__(/*! ./Colliders/PolygonCollider */ "./Collision/Colliders/PolygonCollider.ts");
/* harmony import */ var _Colliders_CollisionJumpTable__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_483826__(/*! ./Colliders/CollisionJumpTable */ "./Collision/Colliders/CollisionJumpTable.ts");
/* harmony import */ var _Colliders_ClosestLineJumpTable__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_483826__(/*! ./Colliders/ClosestLineJumpTable */ "./Collision/Colliders/ClosestLineJumpTable.ts");
/* harmony import */ var _Colliders_SeparatingAxis__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_483826__(/*! ./Colliders/SeparatingAxis */ "./Collision/Colliders/SeparatingAxis.ts");
/* harmony import */ var _Group_CollisionGroup__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_483826__(/*! ./Group/CollisionGroup */ "./Collision/Group/CollisionGroup.ts");
/* harmony import */ var _Group_CollisionGroupManager__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_483826__(/*! ./Group/CollisionGroupManager */ "./Collision/Group/CollisionGroupManager.ts");
/* harmony import */ var _Detection_Pair__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_483826__(/*! ./Detection/Pair */ "./Collision/Detection/Pair.ts");
/* harmony import */ var _Detection_CollisionContact__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_483826__(/*! ./Detection/CollisionContact */ "./Collision/Detection/CollisionContact.ts");
/* harmony import */ var _Detection_DynamicTree__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_483826__(/*! ./Detection/DynamicTree */ "./Collision/Detection/DynamicTree.ts");
/* harmony import */ var _Detection_DynamicTreeCollisionProcessor__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_483826__(/*! ./Detection/DynamicTreeCollisionProcessor */ "./Collision/Detection/DynamicTreeCollisionProcessor.ts");
/* harmony import */ var _Detection_SparseHashGridCollisionProcessor__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_483826__(/*! ./Detection/SparseHashGridCollisionProcessor */ "./Collision/Detection/SparseHashGridCollisionProcessor.ts");
/* harmony import */ var _Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_483826__(/*! ./Detection/SparseHashGrid */ "./Collision/Detection/SparseHashGrid.ts");
/* harmony import */ var _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_483826__(/*! ./Detection/SpatialPartitionStrategy */ "./Collision/Detection/SpatialPartitionStrategy.ts");
/* harmony import */ var _Detection_QuadTree__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_483826__(/*! ./Detection/QuadTree */ "./Collision/Detection/QuadTree.ts");
/* harmony import */ var _Solver_ArcadeSolver__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_483826__(/*! ./Solver/ArcadeSolver */ "./Collision/Solver/ArcadeSolver.ts");
/* harmony import */ var _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_483826__(/*! ./Solver/ContactBias */ "./Collision/Solver/ContactBias.ts");
/* harmony import */ var _Solver_ContactConstraintPoint__WEBPACK_IMPORTED_MODULE_26__ = __nested_webpack_require_483826__(/*! ./Solver/ContactConstraintPoint */ "./Collision/Solver/ContactConstraintPoint.ts");
/* harmony import */ var _Solver_RealisticSolver__WEBPACK_IMPORTED_MODULE_27__ = __nested_webpack_require_483826__(/*! ./Solver/RealisticSolver */ "./Collision/Solver/RealisticSolver.ts");
/* harmony import */ var _CollisionSystem__WEBPACK_IMPORTED_MODULE_28__ = __nested_webpack_require_483826__(/*! ./CollisionSystem */ "./Collision/CollisionSystem.ts");
/* harmony import */ var _MotionSystem__WEBPACK_IMPORTED_MODULE_29__ = __nested_webpack_require_483826__(/*! ./MotionSystem */ "./Collision/MotionSystem.ts");
/* harmony import */ var _PhysicsWorld__WEBPACK_IMPORTED_MODULE_30__ = __nested_webpack_require_483826__(/*! ./PhysicsWorld */ "./Collision/PhysicsWorld.ts");
/* harmony import */ var _PhysicsConfig__WEBPACK_IMPORTED_MODULE_31__ = __nested_webpack_require_483826__(/*! ./PhysicsConfig */ "./Collision/PhysicsConfig.ts");
/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_32__ = __nested_webpack_require_483826__(/*! ./Side */ "./Collision/Side.ts");








































/***/ }),

/***/ "./Collision/Integrator.ts":
/*!*********************************!*\
  !*** ./Collision/Integrator.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_495647__) => {

__nested_webpack_require_495647__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_495647__.d(__nested_webpack_exports__, {
/* harmony export */   EulerIntegrator: () => (/* binding */ EulerIntegrator)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_495647__(/*! ../Math/vector */ "./Math/vector.ts");

class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsed) {
        const seconds = elapsed / 1000;
        // This code looks a little wild, but it's to avoid creating any new Vector instances
        // integration is done in a tight loop so this is key to avoid GC'ing
        motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));
        transform.pos
            .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)
            .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        const rotation = transform.rotation + motion.angularVelocity * seconds;
        transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);
        const tx = transform.get();
        tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);
    }
}
// Scratch vectors to avoid allocation
EulerIntegrator._POS = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
EulerIntegrator._SCALE = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(1, 1);
EulerIntegrator._ACC = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
EulerIntegrator._VEL = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
EulerIntegrator._VEL_ACC = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
EulerIntegrator._SCALE_FACTOR = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);


/***/ }),

/***/ "./Collision/MotionSystem.ts":
/*!***********************************!*\
  !*** ./Collision/MotionSystem.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_497768__) => {

__nested_webpack_require_497768__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_497768__.d(__nested_webpack_exports__, {
/* harmony export */   MotionSystem: () => (/* binding */ MotionSystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_497768__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_497768__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_497768__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_497768__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_497768__(/*! ./BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_497768__(/*! ./CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Integrator__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_497768__(/*! ./Integrator */ "./Collision/Integrator.ts");







class MotionSystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world, physics) {
        super();
        this.world = world;
        this.physics = physics;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Update;
        this._physicsConfigDirty = false;
        physics.$configUpdate.subscribe(() => (this._physicsConfigDirty = true));
        this.query = this.world.query([_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent, _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent]);
    }
    update(elapsed) {
        let transform;
        let motion;
        const entities = this.query.entities;
        const substep = this.physics.config.substep;
        for (let i = 0; i < entities.length; i++) {
            transform = entities[i].get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
            motion = entities[i].get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_2__.MotionComponent);
            const optionalBody = entities[i].get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
            if (this._physicsConfigDirty && optionalBody) {
                optionalBody.updatePhysicsConfig(this.physics.config.bodies);
            }
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.isSleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(this.physics.config.gravity);
            }
            // capture old transform of this entity and all of its children so that
            // any transform properties that derived from their parents are properly captured
            if (!entities[i].parent) {
                this.captureOldTransformWithChildren(entities[i]);
            }
            // Update transform and motion based on Euler linear algebra
            _Integrator__WEBPACK_IMPORTED_MODULE_5__.EulerIntegrator.integrate(transform, motion, totalAcc, elapsed / substep);
        }
        this._physicsConfigDirty = false;
    }
    captureOldTransformWithChildren(entity) {
        var _a;
        (_a = entity.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent)) === null || _a === void 0 ? void 0 : _a.captureOldTransform();
        for (let i = 0; i < entity.children.length; i++) {
            this.captureOldTransformWithChildren(entity.children[i]);
        }
    }
}
MotionSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_6__.SystemPriority.Higher;


/***/ }),

/***/ "./Collision/PhysicsConfig.ts":
/*!************************************!*\
  !*** ./Collision/PhysicsConfig.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_502502__) => {

__nested_webpack_require_502502__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_502502__.d(__nested_webpack_exports__, {
/* harmony export */   getDefaultPhysicsConfig: () => (/* binding */ getDefaultPhysicsConfig)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_502502__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _SolverStrategy__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_502502__(/*! ./SolverStrategy */ "./Collision/SolverStrategy.ts");
/* harmony import */ var _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_502502__(/*! ./Solver/ContactBias */ "./Collision/Solver/ContactBias.ts");
/* harmony import */ var _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_502502__(/*! ./Detection/SpatialPartitionStrategy */ "./Collision/Detection/SpatialPartitionStrategy.ts");




const getDefaultPhysicsConfig = () => ({
    enabled: true,
    gravity: (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0).clone(),
    solver: _SolverStrategy__WEBPACK_IMPORTED_MODULE_1__.SolverStrategy.Arcade,
    substep: 1,
    colliders: {
        compositeStrategy: 'together'
    },
    continuous: {
        checkForFastBodies: true,
        disableMinimumSpeedForFastBody: false,
        surfaceEpsilon: 0.1
    },
    bodies: {
        canSleepByDefault: false,
        sleepEpsilon: 0.07,
        wakeThreshold: 0.07 * 3,
        sleepBias: 0.9,
        defaultMass: 10
    },
    spatialPartition: _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_2__.SpatialPartitionStrategy.SparseHashGrid,
    sparseHashGrid: {
        size: 100
    },
    dynamicTree: {
        boundsPadding: 5,
        velocityMultiplier: 2
    },
    arcade: {
        contactSolveBias: _Solver_ContactBias__WEBPACK_IMPORTED_MODULE_3__.ContactSolveBias.None
    },
    realistic: {
        positionIterations: 3,
        velocityIterations: 8,
        slop: 1,
        steeringFactor: 0.2,
        warmStart: true
    }
});


/***/ }),

/***/ "./Collision/PhysicsWorld.ts":
/*!***********************************!*\
  !*** ./Collision/PhysicsWorld.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_504770__) => {

__nested_webpack_require_504770__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_504770__.d(__nested_webpack_exports__, {
/* harmony export */   PhysicsWorld: () => (/* binding */ PhysicsWorld)
/* harmony export */ });
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_504770__(/*! ../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _Index__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_504770__(/*! ./Index */ "./Collision/Detection/SparseHashGridCollisionProcessor.ts");
/* harmony import */ var _Index__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_504770__(/*! ./Index */ "./Collision/Detection/DynamicTreeCollisionProcessor.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_504770__(/*! ./BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Util_Watch__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_504770__(/*! ../Util/Watch */ "./Util/Watch.ts");
/* harmony import */ var _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_504770__(/*! ./Detection/SpatialPartitionStrategy */ "./Collision/Detection/SpatialPartitionStrategy.ts");





class PhysicsWorld {
    get config() {
        return (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_0__.watchDeep)(this._config, (change) => {
            this.$configUpdate.notifyAll(change);
        });
    }
    set config(newConfig) {
        this._config = newConfig;
        this.$configUpdate.notifyAll(newConfig);
    }
    /**
     * Spatial data structure for locating potential collision pairs and ray casts
     */
    get collisionProcessor() {
        if (this._configDirty) {
            this._configDirty = false;
            // preserve tracked colliders if config updates
            const colliders = this._collisionProcessor.getColliders();
            if (this._config.spatialPartition === _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_1__.SpatialPartitionStrategy.SparseHashGrid) {
                this._collisionProcessor = new _Index__WEBPACK_IMPORTED_MODULE_2__.SparseHashGridCollisionProcessor(this._config.sparseHashGrid);
            }
            else {
                this._collisionProcessor = new _Index__WEBPACK_IMPORTED_MODULE_3__.DynamicTreeCollisionProcessor(this._config);
            }
            for (const collider of colliders) {
                this._collisionProcessor.track(collider);
            }
        }
        return this._collisionProcessor;
    }
    constructor(config) {
        this.$configUpdate = new _Util_Observable__WEBPACK_IMPORTED_MODULE_4__.Observable();
        this._configDirty = false;
        this.config = config;
        this.$configUpdate.subscribe((config) => {
            this._configDirty = true;
            _BodyComponent__WEBPACK_IMPORTED_MODULE_5__.BodyComponent.updateDefaultPhysicsConfig(config.bodies);
        });
        if (this._config.spatialPartition === _Detection_SpatialPartitionStrategy__WEBPACK_IMPORTED_MODULE_1__.SpatialPartitionStrategy.SparseHashGrid) {
            this._collisionProcessor = new _Index__WEBPACK_IMPORTED_MODULE_2__.SparseHashGridCollisionProcessor(this._config.sparseHashGrid);
        }
        else {
            this._collisionProcessor = new _Index__WEBPACK_IMPORTED_MODULE_3__.DynamicTreeCollisionProcessor(this._config);
        }
    }
    /**
     * Raycast into the scene's physics world
     * @param ray
     * @param options
     */
    rayCast(ray, options) {
        return this.collisionProcessor.rayCast(ray, options);
    }
    query(pointOrBounds) {
        // FIXME workaround TS: https://github.com/microsoft/TypeScript/issues/14107
        return this._collisionProcessor.query(pointOrBounds);
    }
}


/***/ }),

/***/ "./Collision/Side.ts":
/*!***************************!*\
  !*** ./Collision/Side.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_508701__) => {

__nested_webpack_require_508701__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_508701__.d(__nested_webpack_exports__, {
/* harmony export */   Side: () => (/* binding */ Side)
/* harmony export */ });
/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction
     */
    function fromDirection(direction) {
        if (Math.abs(direction.x) >= Math.abs(direction.y)) {
            if (direction.x <= 0) {
                return Side.Left;
            }
            return Side.Right;
        }
        if (direction.y <= 0) {
            return Side.Top;
        }
        return Side.Bottom;
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));


/***/ }),

/***/ "./Collision/SolverStrategy.ts":
/*!*************************************!*\
  !*** ./Collision/SolverStrategy.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_510388__) => {

__nested_webpack_require_510388__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_510388__.d(__nested_webpack_exports__, {
/* harmony export */   SolverStrategy: () => (/* binding */ SolverStrategy)
/* harmony export */ });
/**
 * Possible collision resolution strategies
 *
 * The default is {@apilink SolverStrategy.Arcade} which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting {@apilink SolverStrategy.Realistic} which allows for complicated
 * simulated physical interactions.
 */
var SolverStrategy;
(function (SolverStrategy) {
    SolverStrategy["Arcade"] = "arcade";
    SolverStrategy["Realistic"] = "realistic";
})(SolverStrategy || (SolverStrategy = {}));


/***/ }),

/***/ "./Collision/Solver/ArcadeSolver.ts":
/*!******************************************!*\
  !*** ./Collision/Solver/ArcadeSolver.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_511453__) => {

__nested_webpack_require_511453__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_511453__.d(__nested_webpack_exports__, {
/* harmony export */   ArcadeSolver: () => (/* binding */ ArcadeSolver)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_511453__(/*! ../../Events */ "./Events.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_511453__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_511453__(/*! ../Side */ "./Collision/Side.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_511453__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _ContactBias__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_511453__(/*! ./ContactBias */ "./Collision/Solver/ContactBias.ts");





/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver {
    constructor(config) {
        this.config = config;
        this.directionMap = new Map();
        this.distanceMap = new Map();
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter((c) => !c.isCanceled());
        // Locate collision bias order
        let bias;
        switch (this.config.contactSolveBias) {
            case _ContactBias__WEBPACK_IMPORTED_MODULE_0__.ContactSolveBias.HorizontalFirst: {
                bias = _ContactBias__WEBPACK_IMPORTED_MODULE_0__.HorizontalFirst;
                break;
            }
            case _ContactBias__WEBPACK_IMPORTED_MODULE_0__.ContactSolveBias.VerticalFirst: {
                bias = _ContactBias__WEBPACK_IMPORTED_MODULE_0__.VerticalFirst;
                break;
            }
            default: {
                bias = _ContactBias__WEBPACK_IMPORTED_MODULE_0__.None;
            }
        }
        // Sort by bias (None, VerticalFirst, HorizontalFirst) to avoid artifacts with seams
        // Sort contacts by distance to avoid artifacts with seams
        // It's important to solve in a specific order
        contacts.sort((a, b) => {
            const aDir = this.directionMap.get(a.id);
            const bDir = this.directionMap.get(b.id);
            const aDist = this.distanceMap.get(a.id);
            const bDist = this.distanceMap.get(b.id);
            return bias[aDir] - bias[bDir] || aDist - bDist;
        });
        for (const contact of contacts) {
            // Solve position first in arcade
            this.solvePosition(contact);
            // Solve velocity second in arcade
            this.solveVelocity(contact);
        }
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        const epsilon = 0.0001;
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
                // Cancel near 0 mtv collisions
                contact.cancel();
                continue;
            }
            const side = _Side__WEBPACK_IMPORTED_MODULE_1__.Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            const distance = Math.abs(contact.info.separation);
            this.distanceMap.set(contact.id, distance);
            this.directionMap.set(contact.id, side === _Side__WEBPACK_IMPORTED_MODULE_1__.Side.Left || side === _Side__WEBPACK_IMPORTED_MODULE_1__.Side.Right ? 'horizontal' : 'vertical');
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__.PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv, contact));
            contact.colliderB.events.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_2__.PreCollisionEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_1__.Side.getOpposite(side), mtv.negate(), contact));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            if (contact.isCanceled()) {
                continue;
            }
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive) {
                    continue;
                }
            }
            const side = _Side__WEBPACK_IMPORTED_MODULE_1__.Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_2__.PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv, contact));
            contact.colliderB.events.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_2__.PostCollisionEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_1__.Side.getOpposite(side), mtv.negate(), contact));
        }
    }
    solvePosition(contact) {
        var _a, _b;
        const epsilon = 0.0001;
        // if bounds no longer intersect skip to the next
        // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles
        if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {
            // Cancel the contact to prevent and solving
            contact.cancel();
            return;
        }
        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
            // Cancel near 0 mtv collisions
            contact.cancel();
            return;
        }
        let mtv = contact.mtv;
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive) {
                return;
            }
            if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active && bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active) {
                // split overlaps if both are Active
                mtv = mtv.scale(0.5);
            }
            // Resolve overlaps
            if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active) {
                bodyA.globalPos.x -= mtv.x;
                bodyA.globalPos.y -= mtv.y;
                colliderA.update(bodyA.transform.get());
            }
            if (bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active) {
                bodyB.globalPos.x += mtv.x;
                bodyB.globalPos.y += mtv.y;
                colliderB.update(bodyB.transform.get());
            }
        }
    }
    solveVelocity(contact) {
        var _a, _b;
        if (contact.isCanceled()) {
            return;
        }
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(_BodyComponent__WEBPACK_IMPORTED_MODULE_3__.BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Passive) {
                return;
            }
            const normal = contact.normal;
            const opposite = normal.negate();
            if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform when sliding off
                if (bodyA.vel.normalize().dot(opposite) < 0) {
                    // Cancel out velocity opposite direction of collision normal
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
            }
            if (bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform
                if (bodyB.vel.normalize().dot(normal) < 0) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}


/***/ }),

/***/ "./Collision/Solver/ContactBias.ts":
/*!*****************************************!*\
  !*** ./Collision/Solver/ContactBias.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_521842__) => {

__nested_webpack_require_521842__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_521842__.d(__nested_webpack_exports__, {
/* harmony export */   ContactSolveBias: () => (/* binding */ ContactSolveBias),
/* harmony export */   HorizontalFirst: () => (/* binding */ HorizontalFirst),
/* harmony export */   None: () => (/* binding */ None),
/* harmony export */   VerticalFirst: () => (/* binding */ VerticalFirst)
/* harmony export */ });
/**
 * Tells the Arcade collision solver to prefer certain contacts over others
 */
var ContactSolveBias;
(function (ContactSolveBias) {
    ContactSolveBias["None"] = "none";
    ContactSolveBias["VerticalFirst"] = "vertical-first";
    ContactSolveBias["HorizontalFirst"] = "horizontal-first";
})(ContactSolveBias || (ContactSolveBias = {}));
/**
 * Vertical First contact solve bias Used by the {@apilink ArcadeSolver} to sort contacts
 */
const VerticalFirst = {
    vertical: 1,
    horizontal: 2
};
/**
 * Horizontal First contact solve bias Used by the {@apilink ArcadeSolver} to sort contacts
 */
const HorizontalFirst = {
    horizontal: 1,
    vertical: 2
};
/**
 * None value, {@apilink ArcadeSolver} sorts contacts using distance by default
 */
const None = {
    horizontal: 0,
    vertical: 0
};


/***/ }),

/***/ "./Collision/Solver/ContactConstraintPoint.ts":
/*!****************************************************!*\
  !*** ./Collision/Solver/ContactConstraintPoint.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_523399__) => {

__nested_webpack_require_523399__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_523399__.d(__nested_webpack_exports__, {
/* harmony export */   ContactConstraintPoint: () => (/* binding */ ContactConstraintPoint)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_523399__(/*! ../../Math/vector */ "./Math/vector.ts");

/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
        /**
         * Original contact velocity combined with bounciness
         */
        this.originalVelocityAndRestitution = 0;
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        const bodyA = this.contact.bodyA;
        const bodyB = this.contact.bodyB;
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.globalPos);
            this.bToContact = this.point.sub(bodyB.globalPos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity between bodyA and bodyB
     */
    getRelativeVelocity() {
        const bodyA = this.contact.bodyA;
        const bodyB = this.contact.bodyB;
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(_Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(_Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero;
    }
}


/***/ }),

/***/ "./Collision/Solver/RealisticSolver.ts":
/*!*********************************************!*\
  !*** ./Collision/Solver/RealisticSolver.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_527322__) => {

__nested_webpack_require_527322__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_527322__.d(__nested_webpack_exports__, {
/* harmony export */   RealisticSolver: () => (/* binding */ RealisticSolver)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_527322__(/*! ../../Events */ "./Events.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_527322__(/*! ../../Math/util */ "./Math/util.ts");
/* harmony import */ var _CollisionType__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_527322__(/*! ../CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _ContactConstraintPoint__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_527322__(/*! ./ContactConstraintPoint */ "./Collision/Solver/ContactConstraintPoint.ts");
/* harmony import */ var _Side__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_527322__(/*! ../Side */ "./Collision/Side.ts");
/* harmony import */ var _BodyComponent__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_527322__(/*! ../BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Colliders_CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_527322__(/*! ../Colliders/CollisionJumpTable */ "./Collision/Colliders/CollisionJumpTable.ts");







class RealisticSolver {
    constructor(config) {
        this.config = config;
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter((c) => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        var _a, _b, _c;
        const epsilon = 0.0001;
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
                // Cancel near 0 mtv collisions
                contact.cancel();
                continue;
            }
            // Publish collision events on both participants
            const side = _Side__WEBPACK_IMPORTED_MODULE_0__.Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_1__.PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderA.events.emit('beforecollisionresolve', new _Events__WEBPACK_IMPORTED_MODULE_1__.CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new _Events__WEBPACK_IMPORTED_MODULE_1__.PreCollisionEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_0__.Side.getOpposite(side), contact.mtv.negate(), contact));
            contact.colliderB.events.emit('beforecollisionresolve', new _Events__WEBPACK_IMPORTED_MODULE_1__.CollisionPreSolveEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_0__.Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.bodyA;
            const bodyB = contact.bodyB;
            if (bodyA && bodyB) {
                for (let j = 0; j < contact.points.length; j++) {
                    const point = contact.points[j];
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.globalPos);
                    const bToContact = point.sub(bodyB.globalPos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new _ContactConstraintPoint__WEBPACK_IMPORTED_MODULE_2__.ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = 1.0 / normalMass;
                    contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;
                    // Calculate relative velocity before solving to accurately do restitution
                    const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;
                    const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());
                    contactPoints[pointIndex].originalVelocityAndRestitution = 0;
                    if (relativeVelocity < -0.1) {
                        // TODO what's a good threshold here?
                        contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;
                    }
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (this.config.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (let i = 0; i < contacts.length; i++) {
                const contact = contacts[i];
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            const bodyA = contact.bodyA;
            const bodyB = contact.bodyB;
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = _Side__WEBPACK_IMPORTED_MODULE_0__.Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_1__.PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderA.events.emit('aftercollisionresolve', new _Events__WEBPACK_IMPORTED_MODULE_1__.CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new _Events__WEBPACK_IMPORTED_MODULE_1__.PostCollisionEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_0__.Side.getOpposite(side), contact.mtv.negate(), contact));
            contact.colliderB.events.emit('aftercollisionresolve', new _Events__WEBPACK_IMPORTED_MODULE_1__.CollisionPostSolveEvent(contact.colliderB, contact.colliderA, _Side__WEBPACK_IMPORTED_MODULE_0__.Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (let i = 0; i < contacts.length; i++) {
            const c = contacts[i];
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a;
        for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i];
            const bodyA = contact.bodyA;
            const bodyB = contact.bodyB;
            if (bodyA && bodyB) {
                const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
                for (const point of contactPoints) {
                    if (this.config.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a;
        for (let i = 0; i < this.config.positionIterations; i++) {
            for (let i = 0; i < contacts.length; i++) {
                const contact = contacts[i];
                const bodyA = contact.bodyA;
                const bodyB = contact.bodyB;
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = _Colliders_CollisionJumpTable__WEBPACK_IMPORTED_MODULE_4__.CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = this.config.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = this.config.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = (0,_Math_util__WEBPACK_IMPORTED_MODULE_5__.clamp)(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce * point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Active) {
                            // TODO make applyPseudoImpulse function?
                            const impulseForce = impulse.negate().scale(bodyA.inverseMass);
                            if (bodyA.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyA.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyA.globalPos = bodyA.globalPos.add(impulseForce);
                            if (!bodyA.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.Rotation)) {
                                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                            }
                        }
                        if (bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Active) {
                            const impulseForce = impulse.scale(bodyB.inverseMass);
                            if (bodyB.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyB.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyB.globalPos = bodyB.globalPos.add(impulseForce);
                            if (!bodyB.limitDegreeOfFreedom.includes(_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.DegreeOfFreedom.Rotation)) {
                                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                            }
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a;
        for (let i = 0; i < this.config.velocityIterations; i++) {
            for (let i = 0; i < contacts.length; i++) {
                const contact = contacts[i];
                const bodyA = contact.bodyA;
                const bodyB = contact.bodyB;
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive || bodyB.collisionType === _CollisionType__WEBPACK_IMPORTED_MODULE_3__.CollisionType.Passive) {
                        continue;
                    }
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
                    // Friction constraint
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity * point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = (0,_Math_util__WEBPACK_IMPORTED_MODULE_5__.clamp)(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    // Bounce constraint
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // Per Erin it is a mistake to apply the restitution inside the iteration
                        // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses
                        let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./Color.ts":
/*!******************!*\
  !*** ./Color.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_546790__) => {

__nested_webpack_require_546790__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_546790__.d(__nested_webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color)
/* harmony export */ });
/**
 * Provides standard colors (e.g. {@apilink Color.Black})
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like {@apilink Color.lighten}, {@apilink Color.darken}, and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Screens a color by another, results in a lighter color
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        // Handle negative and fractional numbers
        const hex = Math.max(Math.round(c), 0).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        let hexRepresentation = '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
        if (this.a !== 1) {
            hexRepresentation += this._componentToHex(this.a * 255);
        }
        return hexRepresentation;
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone(dest) {
        const result = dest || new Color(this.r, this.g, this.b, this.a);
        result.r = this.r;
        result.g = this.g;
        result.b = this.b;
        result.a = this.a;
        return result;
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Pink (#FFC0CB)
     */
    static get Pink() {
        return Color.fromHex('#FFC0CB');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Purple (#800080)
     */
    static get Purple() {
        return Color.fromHex('#800080');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Teal (#008080)
     */
    static get Teal() {
        return Color.fromHex('#008080');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
    /**
     * Brown (#964B00)
     */
    static get Brown() {
        return Color.fromHex('#964B00');
    }
}
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}


/***/ }),

/***/ "./Context.ts":
/*!********************!*\
  !*** ./Context.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_559597__) => {

__nested_webpack_require_559597__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_559597__.d(__nested_webpack_exports__, {
/* harmony export */   createContext: () => (/* binding */ createContext),
/* harmony export */   useContext: () => (/* binding */ useContext)
/* harmony export */ });
/**
 * Creates a injectable context that can be retrieved later with `useContext(context)`
 *
 * Example
 * ```typescript
 *
 * const AppContext = createContext({some: 'value'});
 * context.scope(val, () => {
 *    const value = useContext(AppContext);
 * })
 *
 * ```
 */
function createContext() {
    const ctx = {
        scope: (value, cb) => {
            const old = ctx.value;
            ctx.value = value;
            try {
                return cb();
            }
            catch (e) {
                throw e;
            }
            finally {
                ctx.value = old;
            }
        },
        value: undefined
    };
    return ctx;
}
/**
 * Retrieves the value from the current context
 */
function useContext(context) {
    return context.value;
}


/***/ }),

/***/ "./Debug/DebugConfig.ts":
/*!******************************!*\
  !*** ./Debug/DebugConfig.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_560893__) => {

__nested_webpack_require_560893__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_560893__.d(__nested_webpack_exports__, {
/* harmony export */   DebugConfig: () => (/* binding */ DebugConfig),
/* harmony export */   FrameStats: () => (/* binding */ FrameStats),
/* harmony export */   PhysicsStats: () => (/* binding */ PhysicsStats)
/* harmony export */ });
/* harmony import */ var _DebugFlags__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_560893__(/*! ./DebugFlags */ "./Debug/DebugFlags.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_560893__(/*! ../Color */ "./Color.ts");


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for {@apilink Engine}, after all values have been
 * updated during a frame.
 */
class DebugConfig {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
             * Best accessed on {@apilink postframe} event. See {@apilink FrameStats}
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
             * Best accessed on {@apilink preframe} event. Best inspected on engine event `preframe`. See {@apilink FrameStats}
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: false,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            debugZIndex: 10000000,
            showPosition: false,
            showPositionLabel: false,
            positionColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Yellow,
            showZIndex: false,
            showScale: false,
            scaleColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Green,
            showRotation: false,
            rotationColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: false,
            boundsColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: false,
            boundsColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Green,
            geometryLineWidth: 1,
            geometryPointSize: 0.5
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Cyan,
            showCollisionContacts: true,
            contactSize: 2,
            collisionContactColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Yellow,
            showAcceleration: false,
            accelerationColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red,
            showZoom: false
        };
        this.tilemap = {
            showAll: false,
            showGrid: false,
            gridColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red,
            gridWidth: 0.5,
            showSolidBounds: false,
            solidBoundsColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex('#8080807F'), // grayish
            showColliderGeometry: true
        };
        this.isometric = {
            showAll: false,
            showPosition: false,
            positionColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Yellow,
            positionSize: 1,
            showGrid: false,
            gridColor: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red,
            gridWidth: 1,
            showColliderGeometry: true
        };
        this._engine = engine;
        this.colorBlindMode = new _DebugFlags__WEBPACK_IMPORTED_MODULE_1__.ColorBlindFlags(this._engine);
    }
    /**
     * Switch the current excalibur clock with the {@apilink TestClock} and return
     * it in the same running state.
     *
     * This is useful when you need to debug frame by frame.
     */
    useTestClock() {
        const clock = this._engine.clock;
        const wasRunning = clock.isRunning();
        clock.stop();
        const testClock = clock.toTestClock();
        if (wasRunning) {
            testClock.start();
        }
        this._engine.clock = testClock;
        return testClock;
    }
    /**
     * Switch the current excalibur clock with the {@apilink StandardClock} and
     * return it in the same running state.
     *
     * This is useful when you need to switch back to normal mode after
     * debugging.
     */
    useStandardClock() {
        const currentClock = this._engine.clock;
        const wasRunning = currentClock.isRunning();
        currentClock.stop();
        const standardClock = currentClock.toStandardClock();
        if (wasRunning) {
            standardClock.start();
        }
        this._engine.clock = standardClock;
        return standardClock;
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via {@apilink FrameStats.reset}, avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._elapsedMs = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.elapsedMs = otherStats.elapsedMs;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.elapsedMs = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get elapsedMs() {
        return this._elapsedMs;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set elapsedMs(value) {
        this._elapsedMs = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}


/***/ }),

/***/ "./Debug/DebugFlags.ts":
/*!*****************************!*\
  !*** ./Debug/DebugFlags.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_573598__) => {

__nested_webpack_require_573598__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_573598__.d(__nested_webpack_exports__, {
/* harmony export */   ColorBlindFlags: () => (/* binding */ ColorBlindFlags)
/* harmony export */ });
/* harmony import */ var _Graphics_PostProcessor_ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_573598__(/*! ../Graphics/PostProcessor/ColorBlindnessMode */ "./Graphics/PostProcessor/ColorBlindnessMode.ts");
/* harmony import */ var _Graphics_PostProcessor_ColorBlindnessPostProcessor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_573598__(/*! ../Graphics/PostProcessor/ColorBlindnessPostProcessor */ "./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts");
/* harmony import */ var _Graphics_Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_573598__(/*! ../Graphics/Context/ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");



class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
        this._colorBlindPostProcessor = new _Graphics_PostProcessor_ColorBlindnessPostProcessor__WEBPACK_IMPORTED_MODULE_0__.ColorBlindnessPostProcessor(_Graphics_PostProcessor_ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_1__.ColorBlindnessMode.Protanope);
    }
    /**
     * Correct colors for a specified color blindness
     * @param colorBlindness
     */
    correct(colorBlindness) {
        if (this._engine.graphicsContext instanceof _Graphics_Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_2__.ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = false;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Simulate colors for a specified color blindness
     * @param colorBlindness
     */
    simulate(colorBlindness) {
        if (this._engine.graphicsContext instanceof _Graphics_Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_2__.ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = true;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Remove color blindness post processor
     */
    clear() {
        this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
    }
}


/***/ }),

/***/ "./Debug/DebugSystem.ts":
/*!******************************!*\
  !*** ./Debug/DebugSystem.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_576395__) => {

__nested_webpack_require_576395__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_576395__.d(__nested_webpack_exports__, {
/* harmony export */   DebugSystem: () => (/* binding */ DebugSystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_576395__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_576395__(/*! ../Collision/ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_576395__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_576395__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_576395__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_576395__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_576395__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_576395__(/*! ../Collision/BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Collision_CollisionSystem__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_576395__(/*! ../Collision/CollisionSystem */ "./Collision/CollisionSystem.ts");
/* harmony import */ var _Collision_Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_576395__(/*! ../Collision/Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_576395__(/*! ../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Particles_Particles__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_576395__(/*! ../Particles/Particles */ "./Particles/Particles.ts");
/* harmony import */ var _Graphics_DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_576395__(/*! ../Graphics/DebugGraphicsComponent */ "./Graphics/DebugGraphicsComponent.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_576395__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Graphics_Debug__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_576395__(/*! ../Graphics/Debug */ "./Graphics/Debug.ts");














class DebugSystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Draw;
        this.query = this.world.query([_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__.TransformComponent]);
    }
    initialize(world, scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = world.systemManager.get(_Collision_CollisionSystem__WEBPACK_IMPORTED_MODULE_2__.CollisionSystem);
    }
    update() {
        var _a;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let debugDraw;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (let i = 0; i < this.query.entities.length; i++) {
            const entity = this.query.entities[i];
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof _Particles_Particles__WEBPACK_IMPORTED_MODULE_3__.Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero;
            const lineHeight = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            if (tx.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane.Screen) {
                this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
            }
            this._graphicsContext.z = txSettings.debugZIndex;
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero, { size: 4, color: txSettings.positionColor });
                }
                if (txSettings.showAll || txSettings.showPositionLabel) {
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showZIndex) {
                    this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero, _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.fromAngle(tx.rotation).scale(50).add(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${(0,_Math_util__WEBPACK_IMPORTED_MODULE_6__.toDegrees)(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero, tx.scale.add(_Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_7__.GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            debugDraw = entity.get(_Graphics_DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_8__.DebugGraphicsComponent);
            if (debugDraw) {
                if (!debugDraw.useTransform) {
                    this._graphicsContext.restore();
                }
                debugDraw.draw(this._graphicsContext, this._engine.debug);
                if (!debugDraw.useTransform) {
                    this._graphicsContext.save();
                    this._applyTransform(entity);
                }
            }
            body = entity.get(_Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_9__.BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.isSleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            // World space
            this._graphicsContext.save();
            if (tx.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane.Screen) {
                this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
            }
            this._graphicsContext.z = txSettings.debugZIndex;
            motion = entity.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_10__.MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_11__.ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor, {
                        lineWidth: colliderSettings.geometryLineWidth,
                        pointSize: colliderSettings.geometryPointSize
                    });
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof _Collision_Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_12__.CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._graphicsContext.restore();
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, {
                            size: physicsSettings.contactSize,
                            color: physicsSettings.collisionContactColor
                        });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    postupdate(engine, elapsed) {
        if (this._engine.isDebug) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
            _Graphics_Debug__WEBPACK_IMPORTED_MODULE_13__.Debug.flush(this._graphicsContext);
            this._graphicsContext.restore();
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}
DebugSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_14__.SystemPriority.Lowest;


/***/ }),

/***/ "./Debug/index.ts":
/*!************************!*\
  !*** ./Debug/index.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_594731__) => {

__nested_webpack_require_594731__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_594731__.d(__nested_webpack_exports__, {
/* harmony export */   ColorBlindFlags: () => (/* reexport safe */ _DebugFlags__WEBPACK_IMPORTED_MODULE_1__.ColorBlindFlags),
/* harmony export */   DebugConfig: () => (/* reexport safe */ _DebugConfig__WEBPACK_IMPORTED_MODULE_0__.DebugConfig),
/* harmony export */   DebugSystem: () => (/* reexport safe */ _DebugSystem__WEBPACK_IMPORTED_MODULE_2__.DebugSystem),
/* harmony export */   FrameStats: () => (/* reexport safe */ _DebugConfig__WEBPACK_IMPORTED_MODULE_0__.FrameStats),
/* harmony export */   PhysicsStats: () => (/* reexport safe */ _DebugConfig__WEBPACK_IMPORTED_MODULE_0__.PhysicsStats)
/* harmony export */ });
/* harmony import */ var _DebugConfig__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_594731__(/*! ./DebugConfig */ "./Debug/DebugConfig.ts");
/* harmony import */ var _DebugFlags__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_594731__(/*! ./DebugFlags */ "./Debug/DebugFlags.ts");
/* harmony import */ var _DebugSystem__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_594731__(/*! ./DebugSystem */ "./Debug/DebugSystem.ts");





/***/ }),

/***/ "./Director/CrossFade.ts":
/*!*******************************!*\
  !*** ./Director/CrossFade.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_596115__) => {

__nested_webpack_require_596115__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_596115__.d(__nested_webpack_exports__, {
/* harmony export */   CrossFade: () => (/* binding */ CrossFade)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_596115__(/*! ../Graphics */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_596115__(/*! ./Transition */ "./Director/Transition.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_596115__(/*! ../Math/vector */ "./Math/vector.ts");



/**
 * CrossFades between the previous scene and the destination scene
 *
 * Note: CrossFade only works as an "in" transition
 */
class CrossFade extends _Transition__WEBPACK_IMPORTED_MODULE_0__.Transition {
    constructor(options) {
        super({ direction: 'in', ...options }); // default the correct direction
        this.name = `CrossFade#${this.id}`;
    }
    async onPreviousSceneDeactivate(scene) {
        this.image = await scene.engine.screenshot(true);
        // Firefox is particularly slow
        // needed in case the image isn't ready yet
        await this.image.decode();
    }
    onInitialize(engine) {
        this.engine = engine;
        this.transform.pos = engine.screen.unsafeArea.topLeft;
        this.screenCover = _Graphics__WEBPACK_IMPORTED_MODULE_1__.ImageSource.fromHtmlImageElement(this.image).toSprite();
        this.graphics.add(this.screenCover);
        // This is because we preserve hidpi res on the screen shot which COULD be bigger than the logical resolution
        this.transform.scale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(1 / engine.screen.pixelRatio, 1 / engine.screen.pixelRatio);
        this.graphics.opacity = this.progress;
    }
    onStart(_progress) {
        this.graphics.opacity = this.progress;
    }
    onReset() {
        this.graphics.opacity = this.progress;
    }
    onEnd(progress) {
        this.graphics.opacity = progress;
    }
    onUpdate(progress) {
        this.graphics.opacity = progress;
    }
}


/***/ }),

/***/ "./Director/DefaultLoader.ts":
/*!***********************************!*\
  !*** ./Director/DefaultLoader.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_598471__) => {

__nested_webpack_require_598471__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_598471__.d(__nested_webpack_exports__, {
/* harmony export */   DefaultLoader: () => (/* binding */ DefaultLoader),
/* harmony export */   LoaderEvents: () => (/* binding */ LoaderEvents),
/* harmony export */   isLoaderConstructor: () => (/* binding */ isLoaderConstructor)
/* harmony export */ });
/* harmony import */ var _Util_WebAudio__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_598471__(/*! ../Util/WebAudio */ "./Util/WebAudio.ts");
/* harmony import */ var _Graphics_Canvas__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_598471__(/*! ../Graphics/Canvas */ "./Graphics/Canvas.ts");
/* harmony import */ var _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_598471__(/*! ../Graphics/Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_598471__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _Resources_Sound_Sound__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_598471__(/*! ../Resources/Sound/Sound */ "./Resources/Sound/Sound.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_598471__(/*! ../Util/Future */ "./Util/Future.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_598471__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_598471__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_598471__(/*! ../Util/Util */ "./Util/Util.ts");









const LoaderEvents = {
    // Add event types here
    BeforeLoad: 'beforeload',
    AfterLoad: 'afterload',
    UserAction: 'useraction',
    LoadResourceStart: 'loadresourcestart',
    LoadResourceEnd: 'loadresourceend'
};
/**
 * Returns true if the constructor is for an Excalibur Loader
 */
function isLoaderConstructor(x) {
    var _a, _b;
    return !!(x === null || x === void 0 ? void 0 : x.prototype) && !!((_b = (_a = x === null || x === void 0 ? void 0 : x.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
}
class DefaultLoader {
    get resources() {
        return this._resources;
    }
    /**
     * @param options Optionally provide the list of resources you want to load at constructor time
     */
    constructor(options) {
        var _a;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.canvas = new _Graphics_Canvas__WEBPACK_IMPORTED_MODULE_1__.Canvas({
            filtering: _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_2__.ImageFiltering.Blended,
            smoothing: true,
            cache: false,
            draw: this.onDraw.bind(this)
        });
        this._resources = [];
        this._numLoaded = 0;
        this._totalTimeMs = 0;
        this._loadingFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_3__.Future();
        if (options && ((_a = options.loadables) === null || _a === void 0 ? void 0 : _a.length)) {
            this.addResources(options.loadables);
        }
    }
    /**
     * Called by the engine before loading
     * @param engine
     */
    onInitialize(engine) {
        this.engine = engine;
        this.canvas.width = this.engine.screen.resolution.width;
        this.canvas.height = this.engine.screen.resolution.height;
    }
    /**
     * Return a promise that resolves when the user interacts with the loading screen in some way, usually a click.
     *
     * It's important to implement this in order to unlock the audio context in the browser. Browsers automatically prevent
     * audio from playing until the user performs an action.
     *
     */
    async onUserAction() {
        return await Promise.resolve();
    }
    /**
     * Overridable lifecycle method, called directly before loading starts
     */
    async onBeforeLoad() {
        // override me
    }
    /**
     * Overridable lifecycle method, called after loading has completed
     */
    async onAfterLoad() {
        // override me
        await (0,_Util_Util__WEBPACK_IMPORTED_MODULE_4__.delay)(500, this.engine.clock); // avoid a flicker
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        this._resources.push(loadable);
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progress of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        const total = this._resources.length;
        return total > 0 ? (0,_Math_util__WEBPACK_IMPORTED_MODULE_5__.clamp)(this._numLoaded, 0, total) / total : 1;
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resources.length;
    }
    /**
     * Optionally override the onUpdate
     * @param engine
     * @param elapsed
     */
    onUpdate(engine, elapsed) {
        this._totalTimeMs += elapsed;
        // override me
    }
    /**
     * Optionally override the onDraw
     */
    onDraw(ctx) {
        const seconds = this._totalTimeMs / 1000;
        ctx.fillStyle = _Color__WEBPACK_IMPORTED_MODULE_6__.Color.Black.toRGBA();
        ctx.fillRect(0, 0, this.engine.screen.resolution.width, this.engine.screen.resolution.height);
        ctx.save();
        ctx.translate(this.engine.screen.resolution.width / 2, this.engine.screen.resolution.height / 2);
        const speed = seconds * 10;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.arc(0, 0, 40, speed, speed + (Math.PI * 3) / 2);
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '16px sans-serif';
        const text = (this.progress * 100).toFixed(0) + '%';
        const textbox = ctx.measureText(text);
        const width = Math.abs(textbox.actualBoundingBoxLeft) + Math.abs(textbox.actualBoundingBoxRight);
        const height = Math.abs(textbox.actualBoundingBoxAscent) + Math.abs(textbox.actualBoundingBoxDescent);
        ctx.fillText(text, -width / 2, height / 2); // center
        ctx.restore();
    }
    areResourcesLoaded() {
        if (this._resources.length === 0) {
            // special case no resources mean loaded;
            return Promise.resolve();
        }
        return this._loadingFuture.promise;
    }
    /**
     * Not meant to be overridden
     *
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete AND the user has interacted with the loading screen
     */
    async load() {
        await this.onBeforeLoad();
        this.events.emit('beforeload');
        this.canvas.flagDirty();
        await Promise.all(this._resources.map(async (r) => {
            this.events.emit('loadresourcestart', r);
            await r.load().finally(() => {
                // capture progress
                this._numLoaded++;
                this.canvas.flagDirty();
                this.events.emit('loadresourceend', r);
            });
        }));
        // Wire all sound to the engine
        for (const resource of this._resources) {
            if (resource instanceof _Resources_Sound_Sound__WEBPACK_IMPORTED_MODULE_7__.Sound) {
                resource.wireEngine(this.engine);
            }
        }
        this._loadingFuture.resolve();
        this.canvas.flagDirty();
        // Unlock browser AudioContext in after user gesture
        // See: https://github.com/excaliburjs/Excalibur/issues/262
        // See: https://github.com/excaliburjs/Excalibur/issues/1031
        await this.onUserAction();
        this.events.emit('useraction');
        await _Util_WebAudio__WEBPACK_IMPORTED_MODULE_8__.WebAudio.unlock();
        await this.onAfterLoad();
        this.events.emit('afterload');
        return (this.data = this._resources);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
}


/***/ }),

/***/ "./Director/Director.ts":
/*!******************************!*\
  !*** ./Director/Director.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_607332__) => {

__nested_webpack_require_607332__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_607332__.d(__nested_webpack_exports__, {
/* harmony export */   Director: () => (/* binding */ Director),
/* harmony export */   DirectorEvents: () => (/* binding */ DirectorEvents)
/* harmony export */ });
/* harmony import */ var _DefaultLoader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_607332__(/*! ./DefaultLoader */ "./Director/DefaultLoader.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_607332__(/*! ../Scene */ "./Scene.ts");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_607332__(/*! ./Loader */ "./Director/Loader.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_607332__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_607332__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_607332__(/*! ../EventEmitter */ "./EventEmitter.ts");






const DirectorEvents = {
    NavigationStart: 'navigationstart',
    Navigation: 'navigation',
    NavigationEnd: 'navigationend'
};
/**
 * The Director is responsible for managing scenes and changing scenes in Excalibur.
 *
 * It deals with transitions, scene loaders, switching scenes
 *
 * This is used internally by Excalibur, generally not mean to
 * be instantiated end users directly.
 */
class Director {
    /**
     * Gets whether the director currently transitioning between scenes
     *
     * Useful if you need to block behavior during transition
     */
    get isTransitioning() {
        return this._isTransitioning;
    }
    constructor(_engine, scenes) {
        this._engine = _engine;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._initialized = false;
        /**
         * All registered scenes in Excalibur
         */
        this.scenes = {};
        /**
         * Holds all instantiated scenes
         */
        this._sceneToInstance = new Map();
        this._sceneToLoader = new Map();
        this._sceneToTransition = new Map();
        /**
         * Used to keep track of scenes that have already been loaded so we don't load multiple times
         */
        this._loadedScenes = new Set();
        this._isTransitioning = false;
        this.rootScene = this.currentScene = new _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene();
        this.add('root', this.rootScene);
        this.currentScene = this.rootScene;
        this.currentSceneName = 'root';
        for (const sceneKey in scenes) {
            const sceneOrOptions = scenes[sceneKey];
            this.add(sceneKey, sceneOrOptions);
            if (sceneKey === 'root') {
                this.rootScene = this.getSceneInstance('root'); // always a root scene
                this.currentScene = this.rootScene;
            }
        }
    }
    /**
     * Initialize the director's internal state
     */
    async onInitialize() {
        if (!this._initialized) {
            this._initialized = true;
            if (this._deferredGoto) {
                const deferredScene = this._deferredGoto;
                this._deferredGoto = undefined;
                const deferredTransition = this._deferredTransition;
                this._deferredTransition = undefined;
                const deferredSceneInstance = this.getSceneInstance(deferredScene);
                if (deferredSceneInstance && deferredTransition) {
                    deferredTransition._addToTargetScene(this._engine, deferredSceneInstance);
                }
                await this.swapScene(deferredScene);
                if (deferredSceneInstance && deferredTransition) {
                    await this.playTransition(deferredTransition, deferredSceneInstance);
                }
            }
            else {
                await this.swapScene('root');
            }
        }
    }
    get isInitialized() {
        return this._initialized;
    }
    /**
     * Configures the start scene, and optionally the transition & loader for the director
     *
     * Typically this is called at the beginning of the game to the start scene and transition and never again.
     * @param startScene
     * @param options
     */
    configureStart(startScene, options) {
        const maybeLoaderOrCtor = options === null || options === void 0 ? void 0 : options.loader;
        if (maybeLoaderOrCtor instanceof _DefaultLoader__WEBPACK_IMPORTED_MODULE_3__.DefaultLoader) {
            this.mainLoader = maybeLoaderOrCtor;
        }
        else if ((0,_DefaultLoader__WEBPACK_IMPORTED_MODULE_3__.isLoaderConstructor)(maybeLoaderOrCtor)) {
            this.mainLoader = new maybeLoaderOrCtor();
        }
        else {
            this.mainLoader = new _Loader__WEBPACK_IMPORTED_MODULE_4__.Loader();
        }
        let maybeStartTransition;
        if (options === null || options === void 0 ? void 0 : options.inTransition) {
            const { inTransition } = options;
            maybeStartTransition = inTransition;
        }
        this.startScene = startScene;
        // Fire and forget promise for the initial scene
        if (maybeStartTransition) {
            const startSceneInstance = this.getSceneInstance(this.startScene);
            if (startSceneInstance) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                maybeStartTransition._addToTargetScene(this._engine, startSceneInstance);
                this.swapScene(this.startScene).then(() => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    return this.playTransition(maybeStartTransition, startSceneInstance);
                });
            }
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.swapScene(this.startScene);
        }
        this.currentSceneName = this.startScene;
    }
    _getLoader(sceneName) {
        return this._sceneToLoader.get(sceneName);
    }
    _getInTransition(sceneName) {
        var _a;
        const sceneOrRoute = this.scenes[sceneName];
        if (sceneOrRoute instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(sceneOrRoute)) {
            return undefined;
        }
        return (_a = sceneOrRoute === null || sceneOrRoute === void 0 ? void 0 : sceneOrRoute.transitions) === null || _a === void 0 ? void 0 : _a.in;
    }
    _getOutTransition(sceneName) {
        var _a;
        const sceneOrRoute = this.scenes[sceneName];
        if (sceneOrRoute instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(sceneOrRoute)) {
            return undefined;
        }
        return (_a = sceneOrRoute === null || sceneOrRoute === void 0 ? void 0 : sceneOrRoute.transitions) === null || _a === void 0 ? void 0 : _a.out;
    }
    getDeferredScene() {
        const maybeDeferred = this.getSceneDefinition(this._deferredGoto);
        if (this._deferredGoto && maybeDeferred) {
            return maybeDeferred;
        }
        return null;
    }
    /**
     * Returns a scene by name if it exists, might be the constructor and not the instance of a scene
     * @param name
     */
    getSceneDefinition(name) {
        const maybeScene = this.scenes[name];
        if (maybeScene instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(maybeScene)) {
            return maybeScene;
        }
        else if (maybeScene) {
            return maybeScene.scene;
        }
        return undefined;
    }
    /**
     * Returns the name of the registered scene, null if none can be found
     * @param scene
     */
    getSceneName(scene) {
        for (const [name, maybeScene] of Object.entries(this.scenes)) {
            if (maybeScene instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene) {
                if (scene === maybeScene) {
                    return name;
                }
            }
            else if (!(0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(maybeScene)) {
                if (scene === maybeScene.scene) {
                    return name;
                }
            }
        }
        for (const [name, maybeScene] of Object.entries(this.scenes)) {
            if ((0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(maybeScene)) {
                if (scene.constructor === maybeScene) {
                    return name;
                }
            }
            else if (!(maybeScene instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene)) {
                if (scene.constructor === maybeScene.scene) {
                    return name;
                }
            }
        }
        return null;
    }
    /**
     * Returns the same Director, but asserts a scene DOES exist to the type system
     * @param name
     */
    assertAdded(name) {
        return this;
    }
    /**
     * Returns the same Director, but asserts a scene DOES NOT exist to the type system
     * @param name
     */
    assertRemoved(name) {
        return this;
    }
    /**
     * Adds additional Scenes to the game!
     * @param name
     * @param sceneOrRoute
     */
    add(name, sceneOrRoute) {
        if (!(sceneOrRoute instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene) && !(0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(sceneOrRoute)) {
            const { loader, transitions } = sceneOrRoute;
            const { in: inTransition, out: outTransition } = transitions !== null && transitions !== void 0 ? transitions : {};
            this._sceneToTransition.set(name, { in: inTransition, out: outTransition });
            if ((0,_DefaultLoader__WEBPACK_IMPORTED_MODULE_3__.isLoaderConstructor)(loader)) {
                this._sceneToLoader.set(name, new loader());
            }
            else if (loader) {
                this._sceneToLoader.set(name, loader);
            }
        }
        if (this.scenes[name]) {
            this._logger.warn('Scene', name, 'already exists overwriting');
        }
        this.scenes[name] = sceneOrRoute;
        return this.assertAdded(name);
    }
    remove(nameOrScene) {
        if (nameOrScene instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(nameOrScene)) {
            const sceneOrCtor = nameOrScene;
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    const potentialSceneOrOptions = this.scenes[key];
                    let scene;
                    if (potentialSceneOrOptions instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_2__.isSceneConstructor)(potentialSceneOrOptions)) {
                        scene = potentialSceneOrOptions;
                    }
                    else {
                        scene = potentialSceneOrOptions.scene;
                    }
                    if (scene === sceneOrCtor) {
                        if (key === this.currentSceneName) {
                            throw new Error(`Cannot remove a currently active scene: ${key}`);
                        }
                        this._sceneToInstance.delete(key);
                        this._sceneToTransition.delete(key);
                        this._sceneToLoader.delete(key);
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof nameOrScene === 'string') {
            if (nameOrScene === this.currentSceneName) {
                throw new Error(`Cannot remove a currently active scene: ${nameOrScene}`);
            }
            // remove scene
            this._sceneToInstance.delete(nameOrScene);
            this._sceneToTransition.delete(nameOrScene);
            this._sceneToLoader.delete(nameOrScene);
            delete this.scenes[nameOrScene];
        }
    }
    /**
     * Go to a specific scene, and optionally override loaders and transitions
     * @param destinationScene
     * @param options
     */
    async goToScene(destinationScene, options) {
        var _a, _b, _c, _d, _e, _f;
        const maybeDest = this.getSceneInstance(destinationScene);
        if (!maybeDest) {
            this._logger.warn(`Scene ${destinationScene} does not exist! Check the name, are you sure you added it?`);
            return;
        }
        const sourceSceneInstance = this.currentScene;
        const sourceScene = this.currentSceneName;
        const engineInputEnabled = (_b = (_a = this._engine.input) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;
        this._isTransitioning = true;
        const maybeSourceOut = (_c = this.getSceneInstance(sourceScene)) === null || _c === void 0 ? void 0 : _c.onTransition('out');
        const maybeDestinationIn = maybeDest === null || maybeDest === void 0 ? void 0 : maybeDest.onTransition('in');
        options = {
            // Engine configuration then dynamic scene transitions
            ...{ sourceOut: (_d = this._getOutTransition(this.currentSceneName)) !== null && _d !== void 0 ? _d : maybeSourceOut },
            ...{ destinationIn: (_e = this._getInTransition(destinationScene)) !== null && _e !== void 0 ? _e : maybeDestinationIn },
            // Goto options
            ...options
        };
        const { sourceOut, destinationIn, sceneActivationData } = options;
        const outTransition = sourceOut !== null && sourceOut !== void 0 ? sourceOut : this._getOutTransition(this.currentSceneName);
        const inTransition = destinationIn !== null && destinationIn !== void 0 ? destinationIn : this._getInTransition(destinationScene);
        const hideLoader = (outTransition === null || outTransition === void 0 ? void 0 : outTransition.hideLoader) || (inTransition === null || inTransition === void 0 ? void 0 : inTransition.hideLoader);
        if (hideLoader) {
            // Start hidden loader early and take advantage of the transition
            // Don't await and block on a hidden loader
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.maybeLoadScene(destinationScene, hideLoader);
        }
        this._emitEvent('navigationstart', sourceScene, destinationScene);
        // Run the out transition on the current scene if present
        if (outTransition) {
            await this.playTransition(outTransition, sourceSceneInstance);
        }
        // Run the loader if present
        await this.maybeLoadScene(destinationScene, hideLoader);
        // Give incoming transition a chance to grab info from previous
        if (inTransition) {
            await inTransition.onPreviousSceneDeactivate(this.currentScene);
        }
        // Setup the in transition on the destination scene if present
        // this is important to it can be initialized with the
        if (inTransition) {
            inTransition._addToTargetScene(this._engine, maybeDest);
        }
        // Swap to the new scene
        // Runs scene lifecycle init and activate
        await this.swapScene(destinationScene, sceneActivationData);
        this._emitEvent('navigation', sourceScene, destinationScene);
        // Run the in transition on the new scene if present
        if (inTransition) {
            await this.playTransition(inTransition, maybeDest);
        }
        this._emitEvent('navigationend', sourceScene, destinationScene);
        (_f = this._engine.input) === null || _f === void 0 ? void 0 : _f.toggleEnabled(engineInputEnabled);
        this._isTransitioning = false;
    }
    /**
     * Retrieves a scene instance by key if it's registered.
     *
     * This will call any constructors that were given as a definition
     * @param scene
     */
    getSceneInstance(scene) {
        const sceneDefinition = this.getSceneDefinition(scene);
        if (!sceneDefinition) {
            return undefined;
        }
        if (this._sceneToInstance.has(scene)) {
            return this._sceneToInstance.get(scene);
        }
        if (sceneDefinition instanceof _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene) {
            this._sceneToInstance.set(scene, sceneDefinition);
            return sceneDefinition;
        }
        const newScene = new sceneDefinition();
        this._sceneToInstance.set(scene, newScene);
        return newScene;
    }
    /**
     * Triggers scene loading if has not already been loaded
     * @param scene
     * @param hideLoader
     */
    async maybeLoadScene(scene, hideLoader = false) {
        var _a;
        const loader = (_a = this._getLoader(scene)) !== null && _a !== void 0 ? _a : new _DefaultLoader__WEBPACK_IMPORTED_MODULE_3__.DefaultLoader();
        const sceneToLoad = this.getSceneDefinition(scene);
        const sceneToLoadInstance = this.getSceneInstance(scene);
        if (sceneToLoad && sceneToLoadInstance && !this._loadedScenes.has(sceneToLoadInstance)) {
            sceneToLoadInstance.onPreLoad(loader);
            sceneToLoadInstance.events.emit('preload', { loader });
            if (hideLoader) {
                // Don't await a hidden loader
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this._engine.load(loader, hideLoader);
            }
            else {
                await this._engine.load(loader);
            }
            this._loadedScenes.add(sceneToLoadInstance);
        }
    }
    /**
     * Plays a transition in the current scene and does book keeping for input.
     * @param transition
     */
    async playTransition(transition, targetScene) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isInitialized) {
            this._deferredTransition = transition;
            return;
        }
        if (transition) {
            this.currentTransition = transition;
            const sceneInputEnabled = (_b = (_a = targetScene.input) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;
            (_c = targetScene.input) === null || _c === void 0 ? void 0 : _c.toggleEnabled(!transition.blockInput);
            (_d = this._engine.input) === null || _d === void 0 ? void 0 : _d.toggleEnabled(!transition.blockInput);
            this.currentTransition._addToTargetScene(this._engine, targetScene);
            await this.currentTransition._play();
            (_e = targetScene.input) === null || _e === void 0 ? void 0 : _e.toggleEnabled(sceneInputEnabled);
        }
        (_f = this.currentTransition) === null || _f === void 0 ? void 0 : _f.kill();
        (_g = this.currentTransition) === null || _g === void 0 ? void 0 : _g.reset();
        this.currentTransition = undefined;
    }
    /**
     * Swaps the current and destination scene after performing required lifecycle events
     * @param destinationScene
     * @param data
     */
    async swapScene(destinationScene, data) {
        const engine = this._engine;
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoto = destinationScene;
            return;
        }
        const maybeDest = this.getSceneInstance(destinationScene);
        if (maybeDest) {
            const previousScene = this.currentScene;
            const nextScene = maybeDest;
            this._logger.debug('Going to scene:', destinationScene);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                const context = { engine, previousScene, nextScene };
                await this.currentScene._deactivate(context);
                this.currentScene.events.emit('deactivate', new _Events__WEBPACK_IMPORTED_MODULE_5__.DeactivateEvent(context, this.currentScene));
                this.currentScene.input.clear();
            }
            // wait for the scene to be loaded if needed
            const destLoader = this._sceneToLoader.get(destinationScene);
            await (destLoader === null || destLoader === void 0 ? void 0 : destLoader.areResourcesLoaded());
            // set current scene to new one
            this.currentScene = nextScene;
            this.currentSceneName = destinationScene;
            engine.screen.setCurrentCamera(nextScene.camera);
            // initialize the current scene if has not been already
            await this.currentScene._initialize(engine);
            const context = { engine, previousScene, nextScene, data };
            await this.currentScene._activate(context);
            this.currentScene.events.emit('activate', new _Events__WEBPACK_IMPORTED_MODULE_5__.ActivateEvent(context, this.currentScene));
        }
        else {
            this._logger.error('Scene', destinationScene, 'does not exist!');
        }
    }
    _emitEvent(eventName, sourceScene, destinationScene) {
        const source = this.getSceneDefinition(sourceScene);
        const dest = this.getSceneDefinition(destinationScene);
        this.events.emit(eventName, {
            sourceScene: source,
            sourceName: sourceScene,
            destinationScene: dest,
            destinationName: destinationScene
        });
    }
}


/***/ }),

/***/ "./Director/FadeInOut.ts":
/*!*******************************!*\
  !*** ./Director/FadeInOut.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_629071__) => {

__nested_webpack_require_629071__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_629071__.d(__nested_webpack_exports__, {
/* harmony export */   FadeInOut: () => (/* binding */ FadeInOut)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_629071__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_629071__(/*! ../Graphics */ "./Graphics/Rectangle.ts");
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_629071__(/*! ./Transition */ "./Director/Transition.ts");



class FadeInOut extends _Transition__WEBPACK_IMPORTED_MODULE_0__.Transition {
    constructor(options) {
        var _a, _b;
        super({
            ...options,
            duration: (_a = options.duration) !== null && _a !== void 0 ? _a : 2000
        });
        this.name = `FadeInOut#${this.id}`;
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black;
    }
    onInitialize(engine) {
        this.transform.pos = engine.screen.unsafeArea.topLeft;
        this.screenCover = new _Graphics__WEBPACK_IMPORTED_MODULE_2__.Rectangle({
            width: engine.screen.resolution.width,
            height: engine.screen.resolution.height,
            color: this.color
        });
        this.graphics.add(this.screenCover);
        this.graphics.opacity = this.progress;
    }
    onReset() {
        this.graphics.opacity = this.progress;
    }
    onStart(progress) {
        this.graphics.opacity = progress;
    }
    onEnd(progress) {
        this.graphics.opacity = progress;
    }
    onUpdate(progress) {
        this.graphics.opacity = progress;
    }
}


/***/ }),

/***/ "./Director/Loader.ts":
/*!****************************!*\
  !*** ./Director/Loader.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_631021__) => {

__nested_webpack_require_631021__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_631021__.d(__nested_webpack_exports__, {
/* harmony export */   Loader: () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_631021__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_631021__(/*! ../Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _Loader_logo_png__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_631021__(/*! ./Loader.logo.png */ "./Director/Loader.logo.png");
/* harmony import */ var _Loader_css__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_631021__(/*! ./Loader.css */ "./Director/Loader.css");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_631021__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_631021__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _DefaultLoader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_631021__(/*! ./DefaultLoader */ "./Director/DefaultLoader.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_631021__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_631021__(/*! ../Util/Future */ "./Util/Future.ts");









/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The {@apilink Loader} itself implements {@apilink Loadable} so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends _DefaultLoader__WEBPACK_IMPORTED_MODULE_0__.DefaultLoader {
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.onload = () => this._imageLoaded.resolve();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    constructor(loadablesOrOptions) {
        const options = Array.isArray(loadablesOrOptions)
            ? {
                loadables: loadablesOrOptions
            }
            : loadablesOrOptions;
        super(options);
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._originalOptions = { loadables: [] };
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();
        this._playButtonShown = false;
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = _Loader_logo_png__WEBPACK_IMPORTED_MODULE_3__["default"];
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is {@apilink Color.White}
         */
        this.loadingBarColor = _Color__WEBPACK_IMPORTED_MODULE_4__.Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this._imageLoaded = new _Util_Future__WEBPACK_IMPORTED_MODULE_5__.Future();
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = _Loader_css__WEBPACK_IMPORTED_MODULE_6__["default"].toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        this._originalOptions = { ...Loader._DEFAULT_LOADER_OPTIONS, ...options };
    }
    onInitialize(engine) {
        this.engine = engine;
        this.screen = engine.screen;
        this.canvas.width = this.engine.canvas.width;
        this.canvas.height = this.engine.canvas.height;
        this.screen.events.on('resize', () => {
            this.canvas.width = this.engine.canvas.width;
            this.canvas.height = this.engine.canvas.height;
        });
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    async showPlayButton() {
        var _a, _b;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            // Delay is to give the logo a chance to show, otherwise don't delay
            await (0,_Util_Util__WEBPACK_IMPORTED_MODULE_7__.delay)(500, (_a = this.engine) === null || _a === void 0 ? void 0 : _a.clock);
        }
        else {
            const resizeHandler = () => {
                try {
                    this._positionPlayButton();
                }
                catch (_a) {
                    // swallow if can't position
                }
            };
            if ((_b = this.engine) === null || _b === void 0 ? void 0 : _b.browser) {
                this.engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            this._positionPlayButton();
            const playButtonClicked = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propagation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this.engine.browser.window.off('resize', resizeHandler);
                    }
                    if (this._originalOptions.fullscreenAfterLoad) {
                        try {
                            this._logger.info('requesting fullscreen');
                            if (this._originalOptions.fullscreenContainer instanceof HTMLElement) {
                                this._originalOptions.fullscreenContainer.requestFullscreen();
                            }
                            else {
                                this.engine.screen.goFullScreen(this._originalOptions.fullscreenContainer);
                            }
                        }
                        catch (error) {
                            this._logger.error('could not go fullscreen', error);
                        }
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return await playButtonClicked;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    async onUserAction() {
        var _a;
        // short delay in showing the button for aesthetics
        await (0,_Util_Util__WEBPACK_IMPORTED_MODULE_7__.delay)(200, (_a = this.engine) === null || _a === void 0 ? void 0 : _a.clock);
        this.canvas.flagDirty();
        // show play button
        await this.showPlayButton();
    }
    async onBeforeLoad() {
        this.screen.pushResolutionAndViewport();
        this.screen.resolution = { width: this.canvas.width, height: this.canvas.height };
        this.screen.applyResolutionAndViewport();
        const image = this._image;
        await this._imageLoaded.promise;
        await (image === null || image === void 0 ? void 0 : image.decode()); // decode logo if it exists
    }
    // eslint-disable-next-line require-await
    async onAfterLoad() {
        this.screen.popResolutionAndViewport();
        this.screen.applyResolutionAndViewport();
        this.dispose();
    }
    _positionPlayButton() {
        if (this.engine) {
            const { x: left, y: top, width: screenWidth, height: screenHeight } = this.engine.canvas.getBoundingClientRect();
            if (this._playButtonRootElement) {
                const buttonWidth = this._playButton.clientWidth;
                const buttonHeight = this._playButton.clientHeight;
                if (this.playButtonPosition) {
                    this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                    this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
                }
                else {
                    this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                    this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
                }
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    onDraw(ctx) {
        const canvasHeight = this.engine.canvasHeight / this.engine.pixelRatio;
        const canvasWidth = this.engine.canvasWidth / this.engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this.engine.screen.antialiasing;
        this.engine.screen.antialiasing = true;
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this.engine.screen.antialiasing = oldAntialias;
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_8__.roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_8__.roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this.engine.screen.antialiasing = oldAntialias;
    }
}
Loader._DEFAULT_LOADER_OPTIONS = {
    loadables: [],
    fullscreenAfterLoad: false,
    fullscreenContainer: undefined
};


/***/ }),

/***/ "./Director/Slide.ts":
/*!***************************!*\
  !*** ./Director/Slide.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_646311__) => {

__nested_webpack_require_646311__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_646311__.d(__nested_webpack_exports__, {
/* harmony export */   Slide: () => (/* binding */ Slide)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_646311__(/*! ../Graphics */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_646311__(/*! ./Transition */ "./Director/Transition.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_646311__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_646311__(/*! ../Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_646311__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");





/**
 * Slide`s between the previous scene and the destination scene
 *
 * Note: Slide` only works as an "in" transition
 */
class Slide extends _Transition__WEBPACK_IMPORTED_MODULE_0__.Transition {
    constructor(options) {
        var _a;
        super({ direction: 'in', ...options }); // default the correct direction
        this._easing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_1__.EasingFunctions.Linear;
        this.name = `Slide#${this.id}`;
        this.slideDirection = options.slideDirection;
        this.transform.coordPlane = _Math_coord_plane__WEBPACK_IMPORTED_MODULE_2__.CoordPlane.World;
        this.graphics.forceOnScreen = true;
        this._easing = (_a = options.easingFunction) !== null && _a !== void 0 ? _a : this._easing;
        this._vectorEasing = _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_1__.EasingFunctions.CreateVectorEasingFunction(this._easing);
    }
    async onPreviousSceneDeactivate(scene) {
        this._image = await scene.engine.screenshot(true);
        // Firefox is particularly slow
        // needed in case the image isn't ready yet
        await this._image.decode();
        this._screenCover = _Graphics__WEBPACK_IMPORTED_MODULE_3__.ImageSource.fromHtmlImageElement(this._image).toSprite();
    }
    onInitialize(engine) {
        this._engine = engine;
        switch (this.slideDirection) {
            case 'up': {
                this._directionOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(0, -engine.screen.resolution.height);
                break;
            }
            case 'down': {
                this._directionOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(0, engine.screen.resolution.height);
                break;
            }
            case 'left': {
                this._directionOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(-engine.screen.resolution.width, 0);
                break;
            }
            case 'right': {
                this._directionOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(engine.screen.resolution.width, 0);
                break;
            }
        }
        this._camera = this._engine.currentScene.camera;
        this._destinationCameraPosition = this._camera.pos.clone();
        // For sliding shift the camera and the transition slide by offset
        this._camera.pos = this._camera.pos.add(this._directionOffset);
        this.transform.pos = this.transform.pos.add(this._directionOffset);
        this._startCameraPosition = this._camera.pos.clone();
        this.graphics.use(this._screenCover);
        // This is because we preserve hidpi res on the screen shot which COULD be bigger than the logical resolution
        this.transform.scale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(1 / engine.screen.pixelRatio, 1 / engine.screen.pixelRatio);
    }
    onUpdate(progress) {
        // in-transitions count down from 1 -> 0, so our "end" is swapped
        this._camera.pos = this._vectorEasing(progress, this._destinationCameraPosition, this._startCameraPosition, 1);
    }
}


/***/ }),

/***/ "./Director/Transition.ts":
/*!********************************!*\
  !*** ./Director/Transition.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_650545__) => {

__nested_webpack_require_650545__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_650545__.d(__nested_webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_650545__(/*! ../Util/Future */ "./Util/Future.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_650545__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_650545__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_650545__(/*! ../Graphics */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_650545__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_650545__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_650545__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_650545__(/*! ../Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Util_Coroutine__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_650545__(/*! ../Util/Coroutine */ "./Util/Coroutine.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_650545__(/*! ../Util/Log */ "./Util/Log.ts");









/**
 * Base Transition that can be extended to provide custom scene transitions in Excalibur.
 */
class Transition extends _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__.Entity {
    /**
     * Returns a number between [0, 1] indicating what state the transition is in.
     *
     * * For 'out' direction transitions start at 0 and end at 1
     * * For 'in' direction transitions start at 1 and end at 0
     */
    get progress() {
        return this._currentProgress;
    }
    get complete() {
        if (this.direction === 'out') {
            return this.progress >= 1;
        }
        else {
            return this.progress <= 0;
        }
    }
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this.transform = new _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_2__.TransformComponent();
        this.graphics = new _Graphics__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent();
        this._completeFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_4__.Future();
        // State needs to be reset between uses
        this.started = false;
        this._currentDistance = 0;
        this._currentProgress = 0;
        this.done = this._completeFuture.promise;
        this.name = `Transition#${this.id}`;
        this.duration = options.duration;
        this.easing = (_a = options.easing) !== null && _a !== void 0 ? _a : _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_5__.EasingFunctions.Linear;
        this.direction = (_b = options.direction) !== null && _b !== void 0 ? _b : 'out';
        this.hideLoader = (_c = options.hideLoader) !== null && _c !== void 0 ? _c : false;
        this.blockInput = (_d = options.blockInput) !== null && _d !== void 0 ? _d : false;
        this.transform.coordPlane = _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.Screen;
        this.transform.pos = _Math_vector__WEBPACK_IMPORTED_MODULE_7__.Vector.Zero;
        this.transform.z = Infinity; // Transitions sit on top of everything
        this.graphics.anchor = _Math_vector__WEBPACK_IMPORTED_MODULE_7__.Vector.Zero;
        this.addComponent(this.transform);
        this.addComponent(this.graphics);
        if (this.direction === 'out') {
            this._currentProgress = 0;
        }
        else {
            this._currentProgress = 1;
        }
    }
    /**
     * Overridable lifecycle method, called before each update.
     *
     * **WARNING BE SURE** to call `super.updateTransition()` if overriding in your own custom implementation
     * @param engine
     * @param elapsed
     */
    updateTransition(engine, elapsed) {
        if (this.complete) {
            return;
        }
        this._currentDistance += (0,_Math_util__WEBPACK_IMPORTED_MODULE_8__.clamp)(elapsed / this.duration, 0, 1);
        if (this._currentDistance >= 1) {
            this._currentDistance = 1;
        }
        if (this.direction === 'out') {
            this._currentProgress = (0,_Math_util__WEBPACK_IMPORTED_MODULE_8__.clamp)(this.easing(this._currentDistance, 0, 1, 1), 0, 1);
        }
        else {
            this._currentProgress = (0,_Math_util__WEBPACK_IMPORTED_MODULE_8__.clamp)(this.easing(this._currentDistance, 1, 0, 1), 0, 1);
        }
    }
    /**
     * Overridable lifecycle method, called right before the previous scene has deactivated.
     *
     * This gives incoming transition a chance to grab info from previous scene if desired
     * @param scene
     */
    async onPreviousSceneDeactivate(scene) {
        // override me
    }
    /**
     * Overridable lifecycle method, called once at the beginning of the transition
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onStart(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called every frame of the transition
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onUpdate(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called at the end of the transition,
     *
     * `progress` is given between 0 and 1
     * @param progress
     */
    onEnd(progress) {
        // override me
    }
    /**
     * Overridable lifecycle method, called when the transition is reset
     *
     * Use this to override and provide your own reset logic for internal state in custom transition implementations
     */
    onReset() {
        // override me
    }
    /**
     * reset() is called by the engine to reset transitions
     */
    reset() {
        this.started = false;
        this._completeFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_4__.Future();
        this.done = this._completeFuture.promise;
        this._currentDistance = 0;
        if (this.direction === 'out') {
            this._currentProgress = 0;
        }
        else {
            this._currentProgress = 1;
        }
        this.onReset();
    }
    /**
     * @internal
     */
    _addToTargetScene(engine, targetScene) {
        const currentScene = targetScene;
        if (this.started) {
            this._logger.warn(`Attempted to add a transition ${this.name} that is already playing.`);
        }
        if (currentScene.world.entityManager.getById(this.id)) {
            return this._co;
        }
        this._engine = engine;
        currentScene.add(this);
        const self = this;
        this._co = (0,_Util_Coroutine__WEBPACK_IMPORTED_MODULE_9__.coroutine)(engine, function* () {
            while (!self.complete) {
                const elapsed = yield; // per frame
                self.updateTransition(self._engine, elapsed);
                self._execute();
            }
        }, {
            autostart: false
        });
        return this._co;
    }
    /**
     * Called internally by excalibur to swap scenes with transition
     * @internal
     */
    async _play() {
        if (this.started) {
            this.reset();
            this._logger.warn(`Attempted to play a transition ${this.name} that is already playing, reset transition.`);
        }
        if (!this._engine || !this._co) {
            this.reset();
            this._logger.warn(`Attempted to play a transition ${this.name} that hasn't been added`);
        }
        if (this._co) {
            await this._co.start();
        }
    }
    /**
     * execute() is called by the engine every frame to update the Transition lifecycle onStart/onUpdate/onEnd
     * @internal
     */
    _execute() {
        if (!this.isInitialized) {
            return;
        }
        if (!this.started) {
            this.started = true;
            this.onStart(this.progress);
        }
        this.onUpdate(this.progress);
        if (this.complete && !this._completeFuture.isCompleted) {
            this.onEnd(this.progress);
            this._completeFuture.resolve();
        }
    }
}


/***/ }),

/***/ "./Director/index.ts":
/*!***************************!*\
  !*** ./Director/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_659379__) => {

__nested_webpack_require_659379__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_659379__.d(__nested_webpack_exports__, {
/* harmony export */   CrossFade: () => (/* reexport safe */ _CrossFade__WEBPACK_IMPORTED_MODULE_2__.CrossFade),
/* harmony export */   DefaultLoader: () => (/* reexport safe */ _DefaultLoader__WEBPACK_IMPORTED_MODULE_6__.DefaultLoader),
/* harmony export */   Director: () => (/* reexport safe */ _Director__WEBPACK_IMPORTED_MODULE_4__.Director),
/* harmony export */   DirectorEvents: () => (/* reexport safe */ _Director__WEBPACK_IMPORTED_MODULE_4__.DirectorEvents),
/* harmony export */   FadeInOut: () => (/* reexport safe */ _FadeInOut__WEBPACK_IMPORTED_MODULE_1__.FadeInOut),
/* harmony export */   Loader: () => (/* reexport safe */ _Loader__WEBPACK_IMPORTED_MODULE_5__.Loader),
/* harmony export */   LoaderEvents: () => (/* reexport safe */ _DefaultLoader__WEBPACK_IMPORTED_MODULE_6__.LoaderEvents),
/* harmony export */   Slide: () => (/* reexport safe */ _Slide__WEBPACK_IMPORTED_MODULE_3__.Slide),
/* harmony export */   Transition: () => (/* reexport safe */ _Transition__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   isLoaderConstructor: () => (/* reexport safe */ _DefaultLoader__WEBPACK_IMPORTED_MODULE_6__.isLoaderConstructor)
/* harmony export */ });
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_659379__(/*! ./Transition */ "./Director/Transition.ts");
/* harmony import */ var _FadeInOut__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_659379__(/*! ./FadeInOut */ "./Director/FadeInOut.ts");
/* harmony import */ var _CrossFade__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_659379__(/*! ./CrossFade */ "./Director/CrossFade.ts");
/* harmony import */ var _Slide__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_659379__(/*! ./Slide */ "./Director/Slide.ts");
/* harmony import */ var _Director__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_659379__(/*! ./Director */ "./Director/Director.ts");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_659379__(/*! ./Loader */ "./Director/Loader.ts");
/* harmony import */ var _DefaultLoader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_659379__(/*! ./DefaultLoader */ "./Director/DefaultLoader.ts");









/***/ }),

/***/ "./Engine.ts":
/*!*******************!*\
  !*** ./Engine.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_661802__) => {

__nested_webpack_require_661802__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_661802__.d(__nested_webpack_exports__, {
/* harmony export */   Engine: () => (/* binding */ Engine),
/* harmony export */   EngineEvents: () => (/* binding */ EngineEvents),
/* harmony export */   ScrollPreventionMode: () => (/* binding */ ScrollPreventionMode)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_661802__(/*! ./ */ "./index.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_661802__(/*! ./Util/Future */ "./Util/Future.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_661802__(/*! ./EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Input_PointerScope__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_661802__(/*! ./Input/PointerScope */ "./Input/PointerScope.ts");
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_661802__(/*! ./Flags */ "./Flags.ts");
/* harmony import */ var _Polyfill__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_661802__(/*! ./Polyfill */ "./Polyfill.ts");
/* harmony import */ var _Screen__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_661802__(/*! ./Screen */ "./Screen.ts");
/* harmony import */ var _Director_DefaultLoader__WEBPACK_IMPORTED_MODULE_27__ = __nested_webpack_require_661802__(/*! ./Director/DefaultLoader */ "./Director/DefaultLoader.ts");
/* harmony import */ var _Director_Loader__WEBPACK_IMPORTED_MODULE_28__ = __nested_webpack_require_661802__(/*! ./Director/Loader */ "./Director/Loader.ts");
/* harmony import */ var _Util_Detector__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_661802__(/*! ./Util/Detector */ "./Util/Detector.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_26__ = __nested_webpack_require_661802__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_661802__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_30__ = __nested_webpack_require_661802__(/*! ./Color */ "./Color.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_661802__(/*! ./Scene */ "./Scene.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_661802__(/*! ./EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Debug_DebugConfig__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_661802__(/*! ./Debug/DebugConfig */ "./Debug/DebugConfig.ts");
/* harmony import */ var _Util_Browser__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_661802__(/*! ./Util/Browser */ "./Util/Browser.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_661802__(/*! ./Graphics */ "./Graphics/Context/ExcaliburGraphicsContext.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_661802__(/*! ./Graphics */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_661802__(/*! ./Graphics */ "./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_661802__(/*! ./Graphics */ "./Graphics/Context/texture-loader.ts");
/* harmony import */ var _Util_Clock__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_661802__(/*! ./Util/Clock */ "./Util/Clock.ts");
/* harmony import */ var _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_661802__(/*! ./Graphics/Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Graphics_GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_29__ = __nested_webpack_require_661802__(/*! ./Graphics/GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _Util_Toaster__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_661802__(/*! ./Util/Toaster */ "./Util/Toaster.ts");
/* harmony import */ var _Director_Director__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_661802__(/*! ./Director/Director */ "./Director/Director.ts");
/* harmony import */ var _Input_InputHost__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_661802__(/*! ./Input/InputHost */ "./Input/InputHost.ts");
/* harmony import */ var _Collision_PhysicsConfig__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_661802__(/*! ./Collision/PhysicsConfig */ "./Collision/PhysicsConfig.ts");
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_661802__(/*! ./Context */ "./Context.ts");
/* harmony import */ var _GarbageCollector__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_661802__(/*! ./GarbageCollector */ "./GarbageCollector.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_661802__(/*! ./Util/Util */ "./Util/Util.ts");






(0,_Polyfill__WEBPACK_IMPORTED_MODULE_0__.polyfill)();






















const EngineEvents = {
    FallbackGraphicsContext: 'fallbackgraphicscontext',
    Initialize: 'initialize',
    Visible: 'visible',
    Hidden: 'hidden',
    Start: 'start',
    Stop: 'stop',
    PreUpdate: 'preupdate',
    PostUpdate: 'postupdate',
    PreFrame: 'preframe',
    PostFrame: 'postframe',
    PreDraw: 'predraw',
    PostDraw: 'postdraw'
};
/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The {@apilink Engine} is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine {
    static useEngine() {
        const value = (0,_Context__WEBPACK_IMPORTED_MODULE_1__.useContext)(Engine.Context);
        if (!value) {
            throw new Error('Cannot inject engine with `useEngine()`, `useEngine()` was called outside of Engine lifecycle scope.');
        }
        return value;
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access {@apilink stats} that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * The current {@apilink Scene} being drawn and updated on screen
     */
    get currentScene() {
        return this.director.currentScene;
    }
    /**
     * The current {@apilink Scene} being drawn and updated on screen
     */
    get currentSceneName() {
        return this.director.currentSceneName;
    }
    /**
     * The default {@apilink Scene} of the game, use {@apilink Engine.goToScene} to transition to different scenes.
     */
    get rootScene() {
        return this.director.rootScene;
    }
    /**
     * Contains all the scenes currently registered with Excalibur
     */
    get scenes() {
        return this.director.scenes;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current {@apilink DisplayMode} of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    /**
     * Hints the graphics context to truncate fractional world space coordinates
     */
    get snapToPixel() {
        return this.graphicsContext.snapToPixel;
    }
    set snapToPixel(shouldSnapToPixel) {
        this.graphicsContext.snapToPixel = shouldSnapToPixel;
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * Creates a new game using the given {@apilink EngineOptions}. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through {@apilink EngineOptions}.
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        /**
         * Anything run under scope can use `useEngine()` to inject the current engine
         * @param cb
         */
        this.scope = (cb) => Engine.Context.scope(this, cb);
        /**
         * Current Excalibur version string
         *
         * Useful for plugins or other tools that need to know what features are available
         */
        this.version = ___WEBPACK_IMPORTED_MODULE_2__.EX_VERSION;
        /**
         * Listen to and emit events on the Engine
         */
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
        /**
         * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.
         *
         * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than
         * one that bounces between 30fps and 60fps
         */
        this.maxFps = Number.POSITIVE_INFINITY;
        this._inputEnabled = true;
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            _Util_Log__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance().fatal(e, e.stack);
        };
        this._toaster = new _Util_Toaster__WEBPACK_IMPORTED_MODULE_5__.Toaster();
        this._timescale = 1.0;
        this._isInitialized = false;
        this._originalOptions = {};
        this._handleWebGLContextLost = (e) => {
            var _a;
            e.preventDefault();
            this.clock.stop();
            this._logger.fatalOnce('WebGL Graphics Lost', e);
            const container = document.createElement('div');
            container.id = 'ex-webgl-graphics-context-lost';
            container.style.position = 'absolute';
            container.style.zIndex = '99';
            container.style.left = '50%';
            container.style.top = '50%';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.transform = 'translate(-50%, -50%)';
            container.style.backgroundColor = 'white';
            container.style.padding = '10px';
            container.style.borderStyle = 'solid 1px';
            const div = document.createElement('div');
            div.innerHTML = `
      <h1>There was an issue rendering, please refresh the page.</h1>
      <div>
        <p>WebGL Graphics Context Lost</p>

        <button id="ex-webgl-graphics-reload">Refresh Page</button>

        <p>There are a few reasons this might happen:</p>
        <ul>
          <li>Two or more pages are placing a high demand on the GPU</li>
          <li>Another page or operation has stalled the GPU and the browser has decided to reset the GPU</li>
          <li>The computer has multiple GPUs and the user has switched between them</li>
          <li>Graphics driver has crashed or restarted</li>
          <li>Graphics driver was updated</li>
        </ul>
      </div>
    `;
            container.appendChild(div);
            if ((_a = this.canvas) === null || _a === void 0 ? void 0 : _a.parentElement) {
                this.canvas.parentElement.appendChild(container);
                const button = div.querySelector('#ex-webgl-graphics-reload');
                button === null || button === void 0 ? void 0 : button.addEventListener('click', () => location.reload());
            }
        };
        this._performanceThresholdTriggered = false;
        this._fpsSamples = [];
        this._disposed = false;
        this._isLoading = false;
        this._hideLoader = false;
        this._isReadyFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_6__.Future();
        /**
         * Returns the current frames elapsed milliseconds
         */
        this.currentFrameElapsedMs = 0;
        /**
         * Returns the current frame lag when in fixed update mode
         */
        this.currentFrameLagMs = 0;
        this._lagMs = 0;
        this._screenShotRequests = [];
        options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };
        this._originalOptions = options;
        _Flags__WEBPACK_IMPORTED_MODULE_7__.Flags.freeze();
        // Initialize browser events facade
        this.browser = new _Util_Browser__WEBPACK_IMPORTED_MODULE_8__.BrowserEvents(window, document);
        // Check compatibility
        const detector = new _Util_Detector__WEBPACK_IMPORTED_MODULE_9__.Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${___WEBPACK_IMPORTED_MODULE_2__.EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === _Util_Log__WEBPACK_IMPORTED_MODULE_4__.LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        if (options.garbageCollection === true) {
            this.garbageCollectorConfig = {
                ..._GarbageCollector__WEBPACK_IMPORTED_MODULE_10__.DefaultGarbageCollectionOptions
            };
        }
        else if (options.garbageCollection === false) {
            this._logger.warn('WebGL Garbage Collection Disabled!!! If you leak any images over time your game will crash when GPU memory is exhausted');
            this.garbageCollectorConfig = null;
        }
        else {
            this.garbageCollectorConfig = {
                ..._GarbageCollector__WEBPACK_IMPORTED_MODULE_10__.DefaultGarbageCollectionOptions,
                ...options.garbageCollection
            };
        }
        this._garbageCollector = new _GarbageCollector__WEBPACK_IMPORTED_MODULE_10__.GarbageCollector({ getTimestamp: Date.now });
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            //test for existence of element
            if (document.getElementById(options.canvasElementId) === null) {
                throw new Error('Cannot find existing element in the DOM, please ensure element is created prior to engine creation.');
            }
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        if (this.canvas && !options.enableCanvasContextMenu) {
            this.canvas.addEventListener('contextmenu', (evt) => {
                evt.preventDefault();
            });
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : _Screen__WEBPACK_IMPORTED_MODULE_11__.DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = _Screen__WEBPACK_IMPORTED_MODULE_11__.DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = _Screen__WEBPACK_IMPORTED_MODULE_11__.DisplayMode.FitScreen;
        }
        this.grabWindowFocus = options.grabWindowFocus;
        this.pointerScope = options.pointerScope;
        this._originalDisplayMode = displayMode;
        let pixelArtSampler;
        let uvPadding;
        let nativeContextAntialiasing;
        let canvasImageRendering;
        let filtering;
        let multiSampleAntialiasing;
        if (typeof options.antialiasing === 'object') {
            ({ pixelArtSampler, nativeContextAntialiasing, multiSampleAntialiasing, filtering, canvasImageRendering } = {
                ...(options.pixelArt ? _Graphics__WEBPACK_IMPORTED_MODULE_12__.DefaultPixelArtOptions : _Graphics__WEBPACK_IMPORTED_MODULE_12__.DefaultAntialiasOptions),
                ...options.antialiasing
            });
        }
        else {
            pixelArtSampler = !!options.pixelArt;
            nativeContextAntialiasing = false;
            multiSampleAntialiasing = options.antialiasing;
            canvasImageRendering = options.antialiasing ? 'auto' : 'pixelated';
            filtering = options.antialiasing ? _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_13__.ImageFiltering.Blended : _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_13__.ImageFiltering.Pixel;
        }
        if (nativeContextAntialiasing && multiSampleAntialiasing) {
            this._logger.warnOnce(`Cannot use antialias setting nativeContextAntialiasing and multiSampleAntialiasing` +
                ` at the same time, they are incompatible settings. If you aren\'t sure use multiSampleAntialiasing`);
        }
        if (options.pixelArt) {
            uvPadding = 0.25;
        }
        if (!options.antialiasing || filtering === _Graphics_Filtering__WEBPACK_IMPORTED_MODULE_13__.ImageFiltering.Pixel) {
            uvPadding = 0;
        }
        // Override with any user option, if non default to .25 for pixel art, 0.01 for everything else
        uvPadding = (_c = (_b = options.uvPadding) !== null && _b !== void 0 ? _b : uvPadding) !== null && _c !== void 0 ? _c : 0.01;
        // Canvas 2D fallback can be flagged on
        let useCanvasGraphicsContext = _Flags__WEBPACK_IMPORTED_MODULE_7__.Flags.isEnabled('use-canvas-context');
        if (!useCanvasGraphicsContext) {
            // Attempt webgl first
            try {
                this.graphicsContext = new _Graphics__WEBPACK_IMPORTED_MODULE_14__.ExcaliburGraphicsContextWebGL({
                    canvasElement: this.canvas,
                    enableTransparency: this.enableCanvasTransparency,
                    pixelArtSampler: pixelArtSampler,
                    antialiasing: nativeContextAntialiasing,
                    multiSampleAntialiasing: multiSampleAntialiasing,
                    uvPadding: uvPadding,
                    powerPreference: options.powerPreference,
                    backgroundColor: options.backgroundColor,
                    snapToPixel: options.snapToPixel,
                    useDrawSorting: options.useDrawSorting,
                    garbageCollector: this.garbageCollectorConfig
                        ? {
                            garbageCollector: this._garbageCollector,
                            collectionInterval: this.garbageCollectorConfig.textureCollectInterval
                        }
                        : null,
                    handleContextLost: (_d = options.handleContextLost) !== null && _d !== void 0 ? _d : this._handleWebGLContextLost,
                    handleContextRestored: options.handleContextRestored
                });
            }
            catch (e) {
                this._logger.warn(`Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. ` +
                    `Some features of Excalibur will not work in this mode. \n\n` +
                    'Read more about this issue at https://excaliburjs.com/docs/performance');
                // fallback to canvas in case of failure
                useCanvasGraphicsContext = true;
            }
        }
        if (useCanvasGraphicsContext) {
            this.graphicsContext = new _Graphics__WEBPACK_IMPORTED_MODULE_15__.ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                antialiasing: nativeContextAntialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel,
                useDrawSorting: options.useDrawSorting
            });
        }
        this.screen = new _Screen__WEBPACK_IMPORTED_MODULE_11__.Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: nativeContextAntialiasing,
            canvasImageRendering: canvasImageRendering,
            browser: this.browser,
            viewport: (_e = options.viewport) !== null && _e !== void 0 ? _e : (options.width && options.height ? { width: options.width, height: options.height } : _Screen__WEBPACK_IMPORTED_MODULE_11__.Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : (_f = options.pixelRatio) !== null && _f !== void 0 ? _f : null
        });
        // TODO REMOVE STATIC!!!
        // Set default filtering based on antialiasing
        _Graphics__WEBPACK_IMPORTED_MODULE_16__.TextureLoader.filtering = filtering;
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.maxFps = (_g = options.maxFps) !== null && _g !== void 0 ? _g : this.maxFps;
        this.fixedUpdateTimestep = (_h = options.fixedUpdateTimestep) !== null && _h !== void 0 ? _h : this.fixedUpdateTimestep;
        this.fixedUpdateFps = (_j = options.fixedUpdateFps) !== null && _j !== void 0 ? _j : this.fixedUpdateFps;
        this.fixedUpdateTimestep = this.fixedUpdateTimestep || 1000 / this.fixedUpdateFps;
        this.clock = new _Util_Clock__WEBPACK_IMPORTED_MODULE_17__.StandardClock({
            maxFps: this.maxFps,
            tick: this._mainloop.bind(this),
            onFatalException: (e) => this.onFatalException(e)
        });
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        if (typeof options.physics === 'boolean') {
            this.physics = {
                ...(0,_Collision_PhysicsConfig__WEBPACK_IMPORTED_MODULE_18__.getDefaultPhysicsConfig)(),
                enabled: options.physics
            };
        }
        else {
            this.physics = {
                ...(0,_Collision_PhysicsConfig__WEBPACK_IMPORTED_MODULE_18__.getDefaultPhysicsConfig)()
            };
            (0,_Util_Util__WEBPACK_IMPORTED_MODULE_19__.mergeDeep)(this.physics, options.physics);
        }
        this.debug = new _Debug_DebugConfig__WEBPACK_IMPORTED_MODULE_20__.DebugConfig(this);
        this.director = new _Director_Director__WEBPACK_IMPORTED_MODULE_21__.Director(this, options.scenes);
        this._initialize(options);
        window.___EXCALIBUR_DEVTOOL = this;
        Engine.InstanceCount++;
    }
    _monitorPerformanceThresholdAndTriggerFallback() {
        const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;
        let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;
        if (threshold === undefined) {
            threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;
        }
        if (showPlayerMessage === undefined) {
            showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;
        }
        if (!_Flags__WEBPACK_IMPORTED_MODULE_7__.Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {
            // Calculate Average fps for last X number of frames after start
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                this._fpsSamples.splice(0, 1);
            }
            this._fpsSamples.push(this.clock.fpsSampler.fps);
            let total = 0;
            for (let i = 0; i < this._fpsSamples.length; i++) {
                total += this._fpsSamples[i];
            }
            const average = total / this._fpsSamples.length;
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                if (average <= threshold.fps) {
                    this._performanceThresholdTriggered = true;
                    this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\n` +
                        "this might mean your browser doesn't have webgl enabled or hardware acceleration is unavailable.\n\n" +
                        'If in Chrome:\n' +
                        '  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.\n' +
                        '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"\n' +
                        'If in Firefox, visit about:config\n' +
                        '  * Ensure webgl.disabled = false\n' +
                        '  * Ensure webgl.force-enabled = true\n' +
                        '  * Ensure layers.acceleration.force-enabled = true\n\n' +
                        'Read more about this issue at https://excaliburjs.com/docs/performance');
                    if (showPlayerMessage) {
                        this._toaster.toast('Excalibur is encountering performance issues. ' +
                            "It's possible that your browser doesn't have hardware acceleration enabled. " +
                            'Visit [LINK] for more information and potential solutions.', 'https://excaliburjs.com/docs/performance');
                    }
                    this.useCanvas2DFallback();
                    this.emit('fallbackgraphicscontext', this.graphicsContext);
                }
            }
        }
    }
    /**
     * Switches the engine's graphics context to the 2D Canvas.
     * @warning Some features of Excalibur will not work in this mode.
     */
    useCanvas2DFallback() {
        var _a, _b, _c;
        // Swap out the canvas
        const newCanvas = this.canvas.cloneNode(false);
        this.canvas.parentNode.replaceChild(newCanvas, this.canvas);
        this.canvas = newCanvas;
        const options = { ...this._originalOptions, antialiasing: this.screen.antialiasing };
        const displayMode = this._originalDisplayMode;
        // New graphics context
        this.graphicsContext = new _Graphics__WEBPACK_IMPORTED_MODULE_15__.ExcaliburGraphicsContext2DCanvas({
            canvasElement: this.canvas,
            enableTransparency: this.enableCanvasTransparency,
            antialiasing: options.antialiasing,
            backgroundColor: options.backgroundColor,
            snapToPixel: options.snapToPixel,
            useDrawSorting: options.useDrawSorting
        });
        // Reset screen
        if (this.screen) {
            this.screen.dispose();
        }
        this.screen = new _Screen__WEBPACK_IMPORTED_MODULE_11__.Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,
            browser: this.browser,
            viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : (options.width && options.height ? { width: options.width, height: options.height } : _Screen__WEBPACK_IMPORTED_MODULE_11__.Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : (_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null
        });
        this.screen.setCurrentCamera(this.currentScene.camera);
        // Reset pointers
        this.input.pointers.detach();
        const pointerTarget = options && options.pointerScope === _Input_PointerScope__WEBPACK_IMPORTED_MODULE_22__.PointerScope.Document ? document : this.canvas;
        this.input.pointers = this.input.pointers.recreate(pointerTarget, this);
        this.input.pointers.init();
    }
    /**
     * Attempts to completely clean up excalibur resources, including removing the canvas from the dom.
     *
     * To start again you will need to new up an Engine.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this.stop();
            this._garbageCollector.forceCollectAll();
            this.input.toggleEnabled(false);
            this.canvas.parentNode.removeChild(this.canvas);
            this.canvas = null;
            this.screen.dispose();
            this.graphicsContext.dispose();
            this.graphicsContext = null;
            Engine.InstanceCount--;
        }
    }
    isDisposed() {
        return this._disposed;
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value < 0) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance().warnOnce('engine.timescale to a value less than 0 are ignored');
            return;
        }
        this._timescale = value;
    }
    /**
     * Adds a {@apilink Timer} to the {@apilink currentScene}.
     * @param timer  The timer to add to the {@apilink currentScene}.
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a {@apilink Timer} from the {@apilink currentScene}.
     * @param timer  The timer to remove to the {@apilink currentScene}.
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a {@apilink Scene} to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        this.director.add(key, scene);
        return this;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        this.director.remove(entity);
    }
    add(entity) {
        if (arguments.length === 2) {
            this.director.add(arguments[0], arguments[1]);
            return;
        }
        const maybeDeferred = this.director.getDeferredScene();
        if (maybeDeferred instanceof _Scene__WEBPACK_IMPORTED_MODULE_23__.Scene) {
            maybeDeferred.add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_24__.Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof _Scene__WEBPACK_IMPORTED_MODULE_23__.Scene || (0,_Scene__WEBPACK_IMPORTED_MODULE_23__.isSceneConstructor)(entity)) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the current scene with optionally supplied:
     * * Activation data
     * * Transitions
     * * Loaders
     *
     * Example:
     * ```typescript
     * game.goToScene('myScene', {
     *   sceneActivationData: {any: 'thing at all'},
     *   destinationIn: new FadeInOut({duration: 1000, direction: 'in'}),
     *   sourceOut: new FadeInOut({duration: 1000, direction: 'out'}),
     *   loader: MyLoader
     * });
     * ```
     *
     * Scenes are defined in the Engine constructor
     * ```typescript
     * const engine = new ex.Engine({
        scenes: {...}
      });
     * ```
     * Or by adding dynamically
     *
     * ```typescript
     * engine.addScene('myScene', new ex.Scene());
     * ```
     * @param destinationScene
     * @param options
     */
    async goToScene(destinationScene, options) {
        await this.scope(async () => {
            await this.director.goToScene(destinationScene, options);
        });
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        var _a, _b;
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        const pointerTarget = options && options.pointerScope === _Input_PointerScope__WEBPACK_IMPORTED_MODULE_22__.PointerScope.Document ? document : this.canvas;
        const grabWindowFocus = (_b = (_a = this._originalOptions) === null || _a === void 0 ? void 0 : _a.grabWindowFocus) !== null && _b !== void 0 ? _b : true;
        this.input = new _Input_InputHost__WEBPACK_IMPORTED_MODULE_25__.InputHost({
            pointerTarget,
            grabWindowFocus,
            engine: this
        });
        this.inputMapper = this.input.inputMapper;
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        this.browser.document.on('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                this.events.emit('hidden', new _Events__WEBPACK_IMPORTED_MODULE_26__.HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else if (document.visibilityState === 'visible') {
                this.events.emit('visible', new _Events__WEBPACK_IMPORTED_MODULE_26__.VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    toggleInputEnabled(enabled) {
        this._inputEnabled = enabled;
        this.input.toggleEnabled(this._inputEnabled);
    }
    onInitialize(engine) {
        // Override me
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    async _overrideInitialize(engine) {
        if (!this.isInitialized) {
            await this.director.onInitialize();
            await this.onInitialize(engine);
            this.events.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_26__.InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Updates the entire state of the game
     * @param elapsed  Number of milliseconds elapsed since the last update.
     */
    _update(elapsed) {
        var _a;
        if (this._isLoading) {
            // suspend updates until loading is finished
            (_a = this._loader) === null || _a === void 0 ? void 0 : _a.onUpdate(this, elapsed);
            // Update input listeners
            this.input.update();
            return;
        }
        // Publish preupdate events
        this.clock.__runScheduledCbs('preupdate');
        this._preupdate(elapsed);
        // process engine level events
        this.currentScene.update(this, elapsed);
        // Update graphics postprocessors
        this.graphicsContext.updatePostProcessors(elapsed);
        // Publish update event
        this.clock.__runScheduledCbs('postupdate');
        this._postupdate(elapsed);
        // Update input listeners
        this.input.update();
    }
    /**
     * @internal
     */
    _preupdate(elapsed) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_26__.PreUpdateEvent(this, elapsed, this));
        this.onPreUpdate(this, elapsed);
    }
    /**
     * Safe to override method
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPreUpdate(engine, elapsed) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(elapsed) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_26__.PostUpdateEvent(this, elapsed, this));
        this.onPostUpdate(this, elapsed);
    }
    /**
     * Safe to override method
     * @param engine The reference to the current game engine
     * @param elapsed  The time elapsed since the last update in milliseconds
     */
    onPostUpdate(engine, elapsed) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param elapsed  Number of milliseconds elapsed since the last draw.
     */
    _draw(elapsed) {
        var _a, _b;
        // Use scene background color if present, fallback to engine
        this.graphicsContext.backgroundColor = (_a = this.currentScene.backgroundColor) !== null && _a !== void 0 ? _a : this.backgroundColor;
        this.graphicsContext.beginDrawLifecycle();
        this.graphicsContext.clear();
        this.clock.__runScheduledCbs('predraw');
        this._predraw(this.graphicsContext, elapsed);
        // Drawing nothing else while loading
        if (this._isLoading) {
            if (!this._hideLoader) {
                (_b = this._loader) === null || _b === void 0 ? void 0 : _b.canvas.draw(this.graphicsContext, 0, 0);
                this.clock.__runScheduledCbs('postdraw');
                this.graphicsContext.flush();
                this.graphicsContext.endDrawLifecycle();
            }
            return;
        }
        this.currentScene.draw(this.graphicsContext, elapsed);
        this.clock.__runScheduledCbs('postdraw');
        this._postdraw(this.graphicsContext, elapsed);
        // Flush any pending drawings
        this.graphicsContext.flush();
        this.graphicsContext.endDrawLifecycle();
        this._checkForScreenShots();
    }
    /**
     * @internal
     */
    _predraw(ctx, elapsed) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_26__.PreDrawEvent(ctx, elapsed, this));
        this.onPreDraw(ctx, elapsed);
    }
    /**
     * Safe to override method to hook into pre draw
     * @param ctx {@link ExcaliburGraphicsContext} for drawing
     * @param elapsed  Number of milliseconds elapsed since the last draw.
     */
    onPreDraw(ctx, elapsed) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(ctx, elapsed) {
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_26__.PostDrawEvent(ctx, elapsed, this));
        this.onPostDraw(ctx, elapsed);
    }
    /**
     * Safe to override method to hook into pre draw
     * @param ctx {@link ExcaliburGraphicsContext} for drawing
     * @param elapsed  Number of milliseconds elapsed since the last draw.
     */
    onPostDraw(ctx, elapsed) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return !this._isLoading;
    }
    get ready() {
        return this._isReadyFuture.isCompleted;
    }
    isReady() {
        return this._isReadyFuture.promise;
    }
    async start(sceneNameOrLoader, options) {
        await this.scope(async () => {
            if (!this._compatible) {
                throw new Error('Excalibur is incompatible with your browser');
            }
            this._isLoading = true;
            let loader;
            if (sceneNameOrLoader instanceof _Director_DefaultLoader__WEBPACK_IMPORTED_MODULE_27__.DefaultLoader) {
                loader = sceneNameOrLoader;
            }
            else if (typeof sceneNameOrLoader === 'string') {
                this.director.configureStart(sceneNameOrLoader, options);
                loader = this.director.mainLoader;
            }
            // Start the excalibur clock which drives the mainloop
            this._logger.debug('Starting game clock...');
            this.browser.resume();
            this.clock.start();
            if (this.garbageCollectorConfig) {
                this._garbageCollector.start();
            }
            this._logger.debug('Game clock started');
            await this.load(loader !== null && loader !== void 0 ? loader : new _Director_Loader__WEBPACK_IMPORTED_MODULE_28__.Loader());
            // Initialize before ready
            await this._overrideInitialize(this);
            this._isReadyFuture.resolve();
            this.emit('start', new _Events__WEBPACK_IMPORTED_MODULE_26__.GameStartEvent(this));
            return this._isReadyFuture.promise;
        });
    }
    _mainloop(elapsed) {
        this.scope(() => {
            this.emit('preframe', new _Events__WEBPACK_IMPORTED_MODULE_26__.PreFrameEvent(this, this.stats.prevFrame));
            const elapsedMs = elapsed * this.timescale;
            this.currentFrameElapsedMs = elapsedMs;
            // reset frame stats (reuse existing instances)
            const frameId = this.stats.prevFrame.id + 1;
            this.stats.currFrame.reset();
            this.stats.currFrame.id = frameId;
            this.stats.currFrame.elapsedMs = elapsedMs;
            this.stats.currFrame.fps = this.clock.fpsSampler.fps;
            _Graphics_GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_29__.GraphicsDiagnostics.clear();
            const beforeUpdate = this.clock.now();
            const fixedTimestepMs = this.fixedUpdateTimestep;
            if (this.fixedUpdateTimestep) {
                this._lagMs += elapsedMs;
                while (this._lagMs >= fixedTimestepMs) {
                    this._update(fixedTimestepMs);
                    this._lagMs -= fixedTimestepMs;
                }
            }
            else {
                this._update(elapsedMs);
            }
            const afterUpdate = this.clock.now();
            this.currentFrameLagMs = this._lagMs;
            this._draw(elapsedMs);
            const afterDraw = this.clock.now();
            this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
            this.stats.currFrame.duration.draw = afterDraw - afterUpdate;
            this.stats.currFrame.graphics.drawnImages = _Graphics_GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_29__.GraphicsDiagnostics.DrawnImagesCount;
            this.stats.currFrame.graphics.drawCalls = _Graphics_GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_29__.GraphicsDiagnostics.DrawCallCount;
            this.emit('postframe', new _Events__WEBPACK_IMPORTED_MODULE_26__.PostFrameEvent(this, this.stats.currFrame));
            this.stats.prevFrame.reset(this.stats.currFrame);
            this._monitorPerformanceThresholdAndTriggerFallback();
        });
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this.clock.isRunning()) {
            this.emit('stop', new _Events__WEBPACK_IMPORTED_MODULE_26__.GameStopEvent(this));
            this.browser.pause();
            this.clock.stop();
            this._garbageCollector.stop();
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's running status, Useful for checking whether engine is running or paused.
     */
    isRunning() {
        return this.clock.isRunning();
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
     */
    screenshot(preserveHiDPIResolution = false) {
        const screenShotPromise = new Promise((resolve) => {
            this._screenShotRequests.push({ preserveHiDPIResolution, resolve });
        });
        return screenShotPromise;
    }
    _checkForScreenShots() {
        // We must grab the draw buffer before we yield to the browser
        // the draw buffer is cleared after compositing
        // the reason for the asynchrony is setting `preserveDrawingBuffer: true`
        // forces the browser to copy buffers which can have a mass perf impact on mobile
        for (const request of this._screenShotRequests) {
            const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;
            const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;
            const screenshot = document.createElement('canvas');
            screenshot.width = finalWidth;
            screenshot.height = finalHeight;
            const ctx = screenshot.getContext('2d');
            ctx.imageSmoothingEnabled = this.screen.antialiasing;
            ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);
            const result = new Image();
            const raw = screenshot.toDataURL('image/png');
            result.onload = () => {
                request.resolve(result);
            };
            result.src = raw;
        }
        // Reset state
        this._screenShotRequests.length = 0;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some {@apilink Loadable} such as a {@apilink Loader} collection, {@apilink Sound}, or {@apilink Texture}.
     */
    async load(loader, hideLoader = false) {
        await this.scope(async () => {
            try {
                // early exit if loaded
                if (loader.isLoaded()) {
                    return;
                }
                this._loader = loader;
                this._isLoading = true;
                this._hideLoader = hideLoader;
                if (loader instanceof _Director_Loader__WEBPACK_IMPORTED_MODULE_28__.Loader) {
                    loader.suppressPlayButton = loader.suppressPlayButton || this._suppressPlayButton;
                }
                this._loader.onInitialize(this);
                await loader.load();
            }
            catch (e) {
                this._logger.error('Error loading resources, things may not behave properly', e);
                await Promise.resolve();
            }
            finally {
                this._isLoading = false;
                this._hideLoader = false;
                this._loader = null;
            }
        });
    }
}
Engine.Context = (0,_Context__WEBPACK_IMPORTED_MODULE_1__.createContext)();
Engine.InstanceCount = 0;
/**
 * Default {@apilink EngineOptions}
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    useDrawSorting: true,
    configurePerformanceCanvas2DFallback: {
        allow: false,
        showPlayerMessage: false,
        threshold: { fps: 20, numberOfFrames: 100 }
    },
    canvasElementId: '',
    canvasElement: undefined,
    enableCanvasContextMenu: false,
    snapToPixel: false,
    antialiasing: true,
    pixelArt: false,
    garbageCollection: true,
    powerPreference: 'high-performance',
    pointerScope: _Input_PointerScope__WEBPACK_IMPORTED_MODULE_22__.PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    grabWindowFocus: true,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: _Color__WEBPACK_IMPORTED_MODULE_30__.Color.fromHex('#2185d0') // Excalibur blue
};


/***/ }),

/***/ "./EntityComponentSystem/Component.ts":
/*!********************************************!*\
  !*** ./EntityComponentSystem/Component.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_715265__) => {

__nested_webpack_require_715265__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_715265__.d(__nested_webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component),
/* harmony export */   isComponentCtor: () => (/* binding */ isComponentCtor)
/* harmony export */ });
/**
 *
 */
function isComponentCtor(value) {
    return !!value && !!value.prototype && !!value.prototype.constructor;
}
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependencies
 *
 * ```typescript
 * class MyComponent extends ex.Component {
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        // TODO maybe generate a unique id?
        /**
         * Current owning {@apilink Entity}, if any, of this component. Null if not added to any {@apilink Entity}
         */
        this.owner = undefined;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Components/MotionComponent.ts":
/*!*************************************************************!*\
  !*** ./EntityComponentSystem/Components/MotionComponent.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_717475__) => {

__nested_webpack_require_717475__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_717475__.d(__nested_webpack_exports__, {
/* harmony export */   MotionComponent: () => (/* binding */ MotionComponent)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_717475__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_717475__(/*! ../Component */ "./EntityComponentSystem/Component.ts");


class MotionComponent extends _Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor() {
        super(...arguments);
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inertia can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Components/TransformComponent.ts":
/*!****************************************************************!*\
  !*** ./EntityComponentSystem/Components/TransformComponent.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_719380__) => {

__nested_webpack_require_719380__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_719380__.d(__nested_webpack_exports__, {
/* harmony export */   TransformComponent: () => (/* binding */ TransformComponent)
/* harmony export */ });
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_719380__(/*! ../../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Math_transform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_719380__(/*! ../../Math/transform */ "./Math/transform.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_719380__(/*! ../Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_719380__(/*! ../../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_719380__(/*! ../../Util/Log */ "./Util/Log.ts");





class TransformComponent extends _Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor() {
        super(...arguments);
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._parentComponent = null;
        this._transform = new _Math_transform__WEBPACK_IMPORTED_MODULE_2__.Transform();
        this._addChildTransform = (child) => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = this._transform;
                childTxComponent._parentComponent = this;
            }
        };
        /**
         * Observable that emits when the z index changes on this component
         */
        this.zIndexChanged$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_3__.Observable();
        this._coordPlane = _Math_coord_plane__WEBPACK_IMPORTED_MODULE_4__.CoordPlane.World;
    }
    get() {
        return this._transform;
    }
    onAdd(owner) {
        for (const child of owner.children) {
            this._addChildTransform(child);
        }
        owner.childrenAdded$.subscribe((child) => this._addChildTransform(child));
        owner.childrenRemoved$.subscribe((child) => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = null;
                childTxComponent._parentComponent = null;
            }
        });
    }
    onRemove(_previousOwner) {
        this._transform.parent = null;
        this._parentComponent = null;
    }
    /**
     * The z-index ordering of the entity, a higher values are drawn on top of lower values.
     * For example z=99 would be drawn on top of z=0.
     */
    get z() {
        return this._transform.z;
    }
    set z(val) {
        const oldz = this._transform.z;
        this._transform.z = val;
        if (oldz !== val) {
            this.zIndexChanged$.notifyAll(val);
        }
    }
    get globalZ() {
        return this._transform.globalZ;
    }
    set globalZ(z) {
        this._transform.globalZ = z;
    }
    /**
     * The {@apilink CoordPlane | `coordinate plane`} for this transform for the entity.
     */
    get coordPlane() {
        if (this._parentComponent) {
            return this._parentComponent.coordPlane;
        }
        return this._coordPlane;
    }
    set coordPlane(value) {
        var _a;
        if (!this._parentComponent) {
            this._coordPlane = value;
        }
        else {
            this._logger.warn(`Cannot set coordinate plane on child entity ${(_a = this.owner) === null || _a === void 0 ? void 0 : _a.name}, children inherit their coordinate plane from their parents.`);
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(v) {
        this._transform.pos = v;
    }
    get globalPos() {
        return this._transform.globalPos;
    }
    set globalPos(v) {
        this._transform.globalPos = v;
    }
    get rotation() {
        return this._transform.rotation;
    }
    set rotation(rotation) {
        this._transform.rotation = rotation;
    }
    get globalRotation() {
        return this._transform.globalRotation;
    }
    set globalRotation(rotation) {
        this._transform.globalRotation = rotation;
    }
    get scale() {
        return this._transform.scale;
    }
    set scale(v) {
        this._transform.scale = v;
    }
    get globalScale() {
        return this._transform.globalScale;
    }
    set globalScale(v) {
        this._transform.globalScale = v;
    }
    applyInverse(v) {
        return this._transform.applyInverse(v);
    }
    apply(v) {
        return this._transform.apply(v);
    }
    clone() {
        const component = new TransformComponent();
        component._transform = this._transform.clone();
        return component;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Entity.ts":
/*!*****************************************!*\
  !*** ./EntityComponentSystem/Entity.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_724505__) => {

__nested_webpack_require_724505__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_724505__.d(__nested_webpack_exports__, {
/* harmony export */   AddedComponent: () => (/* binding */ AddedComponent),
/* harmony export */   Entity: () => (/* binding */ Entity),
/* harmony export */   EntityEvents: () => (/* binding */ EntityEvents),
/* harmony export */   RemovedComponent: () => (/* binding */ RemovedComponent),
/* harmony export */   isAddedComponent: () => (/* binding */ isAddedComponent),
/* harmony export */   isRemovedComponent: () => (/* binding */ isRemovedComponent)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_724505__(/*! ./Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_724505__(/*! ../Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_724505__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_724505__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_724505__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_724505__(/*! ../Util/Log */ "./Util/Log.ts");







/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
const EntityEvents = {
    Add: 'add',
    Remove: 'remove',
    Initialize: 'initialize',
    PreUpdate: 'preupdate',
    PostUpdate: 'postupdate',
    Kill: 'kill'
};
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity {
    constructor(componentsOrOptions, name) {
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this.name = `Entity#${this.id}`;
        /**
         * Listen to or emit events for an entity
         */
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._tags = new Set();
        this.componentAdded$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        this.componentRemoved$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        this.tagAdded$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        this.tagRemoved$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        /**
         * Current components on the entity
         *
         * **Do not modify**
         *
         * Use addComponent/removeComponent otherwise the ECS will not be notified of changes.
         */
        this.components = new Map();
        this.componentValues = [];
        this._componentsToRemove = [];
        /**
         * The current scene that the entity is in, if any
         */
        this.scene = null;
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.isActive = true;
        this._parent = null;
        this.childrenAdded$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        this.childrenRemoved$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
        this._children = [];
        this._isInitialized = false;
        this._isAdded = false;
        let componentsToAdd;
        let nameToAdd;
        let silence = false;
        if (Array.isArray(componentsOrOptions)) {
            componentsToAdd = componentsOrOptions;
            nameToAdd = name;
        }
        else if (componentsOrOptions && typeof componentsOrOptions === 'object') {
            const { components, name, silenceWarnings } = componentsOrOptions;
            componentsToAdd = components !== null && components !== void 0 ? components : [];
            nameToAdd = name;
            silence = !!silenceWarnings;
        }
        if (nameToAdd) {
            this.name = nameToAdd;
        }
        if (componentsToAdd) {
            for (const component of componentsToAdd) {
                this.addComponent(component);
            }
        }
        if (true) {
            if (!silence) {
                setTimeout(() => {
                    if (!this.scene && !this.isInitialized) {
                        _Util_Log__WEBPACK_IMPORTED_MODULE_2__.Logger.getInstance().warn(`Entity "${this.name || this.id}" was not added to a scene.`);
                    }
                }, 5000);
            }
        }
    }
    /**
     * Whether this entity is active, if set to false it will be reclaimed
     * @deprecated use isActive
     */
    get active() {
        return this.isActive;
    }
    /**
     * Whether this entity is active, if set to false it will be reclaimed
     * @deprecated use isActive
     */
    set active(val) {
        this.isActive = val;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     * If parented it will be removed from the parent when killed.
     */
    kill() {
        if (this.isActive) {
            this.isActive = false;
            this.unparent();
        }
        this.emit('kill', new _Events__WEBPACK_IMPORTED_MODULE_3__.KillEvent(this));
    }
    isKilled() {
        return !this.isActive;
    }
    /**
     * Specifically get the tags on the entity from {@apilink TagsComponent}
     */
    get tags() {
        return this._tags;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this._tags.has(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     */
    addTag(tag) {
        this._tags.add(tag);
        this.tagAdded$.notifyAll(tag);
        return this;
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     */
    removeTag(tag) {
        this._tags.delete(tag);
        this.tagRemoved$.notifyAll(tag);
        return this;
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return Array.from(this.components.keys());
    }
    /**
     * Returns all component instances on entity
     */
    getComponents() {
        return Array.from(this.components.values());
    }
    /**
     * Verifies that an entity has all the required types
     * @param requiredTypes
     */
    hasAll(requiredTypes) {
        for (let i = 0; i < requiredTypes.length; i++) {
            if (!this.components.has(requiredTypes[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Verifies that an entity has all the required tags
     * @param requiredTags
     */
    hasAllTags(requiredTags) {
        for (let i = 0; i < requiredTags.length; i++) {
            if (!this.tags.has(requiredTags[i])) {
                return false;
            }
        }
        return true;
    }
    get(type) {
        return this.components.get(type);
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            (0,_Util_Util__WEBPACK_IMPORTED_MODULE_4__.removeItemFromArray)(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        // Avoid modifying the array issue by walking backwards
        for (let i = this.children.length - 1; i >= 0; i--) {
            this.removeChild(this.children[i]);
        }
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            if (curr) {
                queue = queue.concat(curr.children);
                result = result.concat(curr.children);
            }
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            const componentInstance = this.get(c);
            if (componentInstance) {
                newEntity.addComponent(componentInstance.clone());
            }
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it already exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    _getClassHierarchyRoot(componentType) {
        var _a, _b;
        let current = componentType;
        let parent = (_a = Object.getPrototypeOf(current.prototype)) === null || _a === void 0 ? void 0 : _a.constructor;
        while (parent && parent !== Object && parent !== _Component__WEBPACK_IMPORTED_MODULE_5__.Component) {
            current = parent;
            parent = (_b = Object.getPrototypeOf(current.prototype)) === null || _b === void 0 ? void 0 : _b.constructor;
        }
        return current;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.constructor)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component.constructor, true);
            }
            else {
                // early exit component exits
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const rootComponent = this._getClassHierarchyRoot(component.constructor);
        this.components.set(rootComponent, component);
        this.components.set(component.constructor, component);
        this.componentValues.push(component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this.componentAdded$.notifyAll(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param typeOrInstance
     * @param force
     */
    removeComponent(typeOrInstance, force = false) {
        let type;
        if ((0,_Component__WEBPACK_IMPORTED_MODULE_5__.isComponentCtor)(typeOrInstance)) {
            type = typeOrInstance;
        }
        else {
            type = typeOrInstance.constructor;
        }
        if (force) {
            const componentToRemove = this.components.get(type);
            if (componentToRemove) {
                this.componentRemoved$.notifyAll(componentToRemove);
                componentToRemove.owner = undefined;
                if (componentToRemove.onRemove) {
                    componentToRemove.onRemove(this);
                }
                const componentIndex = this.componentValues.indexOf(componentToRemove);
                if (componentIndex > -1) {
                    this.componentValues.splice(componentIndex, 1);
                }
            }
            const rootComponent = this._getClassHierarchyRoot(type);
            this.components.delete(rootComponent);
            this.components.delete(type); // remove after the notify to preserve typing
        }
        else {
            this._componentsToRemove.push(type);
        }
        return this;
    }
    clearComponents() {
        const components = this.types;
        for (const c of components) {
            this.removeComponent(c);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const type of this._componentsToRemove) {
            this.removeComponent(type, true);
        }
        this._componentsToRemove.length = 0;
    }
    /**
     * Check if a component type exists
     * @param type
     */
    has(type) {
        return this.components.has(type);
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    get isAdded() {
        return this._isAdded;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            this.events.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_3__.InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Adds this Actor, meant to be called by the Scene when Actor is added.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     * @internal
     */
    _add(engine) {
        if (!this.isAdded && this.isActive) {
            this.onAdd(engine);
            this.events.emit('add', new _Events__WEBPACK_IMPORTED_MODULE_3__.AddEvent(engine, this));
            this._isAdded = true;
        }
    }
    /**
     * Removes Actor, meant to be called by the Scene when Actor is added.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     * @internal
     */
    _remove(engine) {
        if (this.isAdded && !this.isActive) {
            this.onRemove(engine);
            this.events.emit('remove', new _Events__WEBPACK_IMPORTED_MODULE_3__.RemoveEvent(engine, this));
            this._isAdded = false;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
     * @internal
     */
    _preupdate(engine, elapsed) {
        this.events.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__.PreUpdateEvent(engine, elapsed, this));
        this.onPreUpdate(engine, elapsed);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
     * @internal
     */
    _postupdate(engine, elapsed) {
        this.events.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_3__.PostUpdateEvent(engine, elapsed, this));
        this.onPostUpdate(engine, elapsed);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(engine) {
        // Override me
    }
    /**
     * `onAdd` is called when Actor is added to scene. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('add', (evt) => {...})`
     */
    onAdd(engine) {
        // Override me
    }
    /**
     * `onRemove` is called when Actor is added to scene. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('remove', (evt) => {...})`
     */
    onRemove(engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(engine, elapsed) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(engine, elapsed) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     * @internal
     * @param engine
     * @param elapsed
     */
    update(engine, elapsed) {
        this._initialize(engine);
        this._add(engine);
        this._preupdate(engine, elapsed);
        for (const child of this.children) {
            child.update(engine, elapsed);
        }
        this._postupdate(engine, elapsed);
        this._remove(engine);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        if (handler) {
            this.events.off(eventName, handler);
        }
        else {
            this.events.off(eventName);
        }
    }
}
Entity._ID = 0;


/***/ }),

/***/ "./EntityComponentSystem/EntityManager.ts":
/*!************************************************!*\
  !*** ./EntityComponentSystem/EntityManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_744848__) => {

__nested_webpack_require_744848__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_744848__.d(__nested_webpack_exports__, {
/* harmony export */   EntityManager: () => (/* binding */ EntityManager)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_744848__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_744848__(/*! ../Util/Util */ "./Util/Util.ts");


// Add/Remove entities and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._childAddedHandlerMap = new Map();
        this._childRemovedHandlerMap = new Map();
        this._createChildAddedHandler = () => (e) => {
            this.addEntity(e);
        };
        this._createChildRemovedHandler = () => (e) => {
            this.removeEntity(e, false);
        };
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param scene
     * @param elapsed
     */
    updateEntities(scene, elapsed) {
        for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
            const entity = this.entities[entityIndex];
            entity.update(scene.engine, elapsed);
            if (!entity.isActive) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
            const entity = this.entities[entityIndex];
            if (!entity.isActive) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.isActive = true;
        entity.scene = this._world.scene;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            // if entity has children
            entity.children.forEach((c) => {
                c.scene = entity.scene;
                this.addEntity(c);
            });
            const childAdded = this._createChildAddedHandler();
            this._childAddedHandlerMap.set(entity, childAdded);
            const childRemoved = this._createChildRemovedHandler();
            this._childRemovedHandlerMap.set(entity, childRemoved);
            entity.childrenAdded$.subscribe(childAdded);
            entity.childrenRemoved$.subscribe(childRemoved);
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a, _b;
        let id = 0;
        if (idOrEntity instanceof _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.isActive) {
            entity.isActive = false;
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            entity.scene = null;
            (0,_Util_Util__WEBPACK_IMPORTED_MODULE_1__.removeItemFromArray)(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            // if entity has children
            entity.children.forEach((c) => {
                c.scene = null;
                this.removeEntity(c, deferred);
            });
            const childAddedHandler = this._childAddedHandlerMap.get(entity);
            if (childAddedHandler) {
                entity.childrenAdded$.unsubscribe(childAddedHandler);
            }
            const childRemovedHandler = this._childRemovedHandlerMap.get(entity);
            if (childRemovedHandler) {
                entity.childrenRemoved$.unsubscribe(childRemovedHandler);
            }
            // stats
            if ((_b = (_a = this._world) === null || _a === void 0 ? void 0 : _a.scene) === null || _b === void 0 ? void 0 : _b.engine) {
                this._world.scene.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (let entityIndex = 0; entityIndex < this._entitiesToRemove.length; entityIndex++) {
            const entity = this._entitiesToRemove[entityIndex];
            if (entity.isActive) {
                continue;
            }
            this.removeEntity(entity, false);
        }
        this._entitiesToRemove.length = 0;
    }
    processComponentRemovals() {
        for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
            const entity = this.entities[entityIndex];
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter((e) => e.name === name);
    }
    clear() {
        for (let i = this.entities.length - 1; i >= 0; i--) {
            this.removeEntity(this.entities[i]);
        }
    }
}


/***/ }),

/***/ "./EntityComponentSystem/Priority.ts":
/*!*******************************************!*\
  !*** ./EntityComponentSystem/Priority.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_750323__) => {

__nested_webpack_require_750323__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_750323__.d(__nested_webpack_exports__, {
/* harmony export */   SystemPriority: () => (/* binding */ SystemPriority)
/* harmony export */ });
/**
 * Higher priorities run earlier than others in the system update
 */
const SystemPriority = {
    Highest: -Infinity,
    Higher: -5,
    Average: 0,
    Lower: 5,
    Lowest: Infinity
};


/***/ }),

/***/ "./EntityComponentSystem/Query.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/Query.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_751000__) => {

__nested_webpack_require_751000__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_751000__.d(__nested_webpack_exports__, {
/* harmony export */   Query: () => (/* binding */ Query)
/* harmony export */ });
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_751000__(/*! ../Util/Observable */ "./Util/Observable.ts");

/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query {
    constructor(requiredComponents) {
        this.requiredComponents = requiredComponents;
        this.components = new Set();
        this.entities = [];
        /**
         * This fires right after the component is added
         */
        this.entityAdded$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * This fires right before the component is actually removed from the entity, it will still be available for cleanup purposes
         */
        this.entityRemoved$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        if (requiredComponents.length === 0) {
            throw new Error('Cannot create query without components');
        }
        for (const type of requiredComponents) {
            this.components.add(type);
        }
        this.id = Query.createId(requiredComponents);
    }
    static createId(requiredComponents) {
        // TODO what happens if a user defines the same type name as a built in type
        // ! TODO this could be dangerous depending on the bundler's settings for names
        // Maybe some kind of hash function is better here?
        return requiredComponents
            .slice()
            .map((c) => c.name)
            .sort()
            .join('-');
    }
    /**
     * Potentially adds an entity to a query index, returns true if added, false if not
     * @param entity
     */
    checkAndAdd(entity) {
        if (!this.entities.includes(entity) && entity.hasAll(Array.from(this.components))) {
            this.entities.push(entity);
            this.entityAdded$.notifyAll(entity);
            return true;
        }
        return false;
    }
    removeEntity(entity) {
        const index = this.entities.indexOf(entity);
        if (index > -1) {
            this.entities.splice(index, 1);
            this.entityRemoved$.notifyAll(entity);
        }
    }
    /**
     * Returns a list of entities that match the query
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this.entities.sort(sort);
        }
        return this.entities;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/QueryManager.ts":
/*!***********************************************!*\
  !*** ./EntityComponentSystem/QueryManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_754126__) => {

__nested_webpack_require_754126__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_754126__.d(__nested_webpack_exports__, {
/* harmony export */   QueryManager: () => (/* binding */ QueryManager)
/* harmony export */ });
/* harmony import */ var _Query__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_754126__(/*! ./Query */ "./EntityComponentSystem/Query.ts");
/* harmony import */ var _TagQuery__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_754126__(/*! ./TagQuery */ "./EntityComponentSystem/TagQuery.ts");


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = new Map();
        this._addComponentHandlers = new Map();
        this._removeComponentHandlers = new Map();
        this._componentToQueriesIndex = new Map();
        this._tagQueries = new Map();
        this._addTagHandlers = new Map();
        this._removeTagHandlers = new Map();
        this._tagToQueriesIndex = new Map();
        this._createAddComponentHandler = (entity) => (c) => {
            this.addComponent(entity, c);
        };
        this._createRemoveComponentHandler = (entity) => (c) => {
            this.removeComponent(entity, c);
        };
        this._createAddTagHandler = (entity) => (tag) => {
            this.addTag(entity, tag);
        };
        this._createRemoveTagHandler = (entity) => (tag) => {
            this.removeTag(entity, tag);
        };
    }
    createQuery(requiredComponents) {
        const id = _Query__WEBPACK_IMPORTED_MODULE_0__.Query.createId(requiredComponents);
        if (this._queries.has(id)) {
            // short circuit if query is already created
            return this._queries.get(id);
        }
        const query = new _Query__WEBPACK_IMPORTED_MODULE_0__.Query(requiredComponents);
        this._queries.set(query.id, query);
        // index maintenance
        for (const component of requiredComponents) {
            const queries = this._componentToQueriesIndex.get(component);
            if (!queries) {
                this._componentToQueriesIndex.set(component, [query]);
            }
            else {
                queries.push(query);
            }
        }
        for (const entity of this._world.entities) {
            this.addEntity(entity);
        }
        return query;
    }
    createTagQuery(requiredTags) {
        const id = _TagQuery__WEBPACK_IMPORTED_MODULE_1__.TagQuery.createId(requiredTags);
        if (this._tagQueries.has(id)) {
            // short circuit if query is already created
            return this._tagQueries.get(id);
        }
        const query = new _TagQuery__WEBPACK_IMPORTED_MODULE_1__.TagQuery(requiredTags);
        this._tagQueries.set(query.id, query);
        // index maintenance
        for (const tag of requiredTags) {
            const queries = this._tagToQueriesIndex.get(tag);
            if (!queries) {
                this._tagToQueriesIndex.set(tag, [query]);
            }
            else {
                queries.push(query);
            }
        }
        for (const entity of this._world.entities) {
            this.addEntity(entity);
        }
        return query;
    }
    /**
     * Scans queries and locates any that need this entity added
     * @param entity
     */
    addEntity(entity) {
        const maybeAddComponent = this._addComponentHandlers.get(entity);
        const maybeRemoveComponent = this._removeComponentHandlers.get(entity);
        const addComponent = maybeAddComponent !== null && maybeAddComponent !== void 0 ? maybeAddComponent : this._createAddComponentHandler(entity);
        const removeComponent = maybeRemoveComponent !== null && maybeRemoveComponent !== void 0 ? maybeRemoveComponent : this._createRemoveComponentHandler(entity);
        this._addComponentHandlers.set(entity, addComponent);
        this._removeComponentHandlers.set(entity, removeComponent);
        const maybeAddTag = this._addTagHandlers.get(entity);
        const maybeRemoveTag = this._removeTagHandlers.get(entity);
        const addTag = maybeAddTag !== null && maybeAddTag !== void 0 ? maybeAddTag : this._createAddTagHandler(entity);
        const removeTag = maybeRemoveTag !== null && maybeRemoveTag !== void 0 ? maybeRemoveTag : this._createRemoveTagHandler(entity);
        this._addTagHandlers.set(entity, addTag);
        this._removeTagHandlers.set(entity, removeTag);
        for (const query of this._queries.values()) {
            query.checkAndAdd(entity);
        }
        for (const tagQuery of this._tagQueries.values()) {
            tagQuery.checkAndAdd(entity);
        }
        entity.componentAdded$.subscribe(addComponent);
        entity.componentRemoved$.subscribe(removeComponent);
        entity.tagAdded$.subscribe(addTag);
        entity.tagRemoved$.subscribe(removeTag);
    }
    /**
     * Scans queries and locates any that need this entity removed
     * @param entity
     */
    removeEntity(entity) {
        // Handle components
        const addComponent = this._addComponentHandlers.get(entity);
        const removeComponent = this._removeComponentHandlers.get(entity);
        for (const query of this._queries.values()) {
            query.removeEntity(entity);
        }
        if (addComponent) {
            entity.componentAdded$.unsubscribe(addComponent);
        }
        if (removeComponent) {
            entity.componentRemoved$.unsubscribe(removeComponent);
        }
        // Handle tags
        const addTag = this._addTagHandlers.get(entity);
        const removeTag = this._removeTagHandlers.get(entity);
        for (const tagQuery of this._tagQueries.values()) {
            tagQuery.removeEntity(entity);
        }
        if (addTag) {
            entity.tagAdded$.unsubscribe(addTag);
        }
        if (removeTag) {
            entity.tagRemoved$.unsubscribe(removeTag);
        }
    }
    /**
     * Updates any queries when a component is added to an entity
     * @param entity
     * @param component
     */
    addComponent(entity, component) {
        var _a;
        const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.checkAndAdd(entity);
        }
    }
    /**
     * Updates any queries when a component is removed from an entity
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        var _a;
        const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.removeEntity(entity);
        }
    }
    /**
     * Updates any queries when a tag is added to an entity
     * @param entity
     * @param tag
     */
    addTag(entity, tag) {
        var _a;
        const queries = (_a = this._tagToQueriesIndex.get(tag)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.checkAndAdd(entity);
        }
    }
    /**
     * Updates any queries when a component is removed from an entity
     * @param entity
     * @param tag
     */
    removeTag(entity, tag) {
        var _a;
        const queries = (_a = this._tagToQueriesIndex.get(tag)) !== null && _a !== void 0 ? _a : [];
        for (const query of queries) {
            query.removeEntity(entity);
        }
    }
}


/***/ }),

/***/ "./EntityComponentSystem/System.ts":
/*!*****************************************!*\
  !*** ./EntityComponentSystem/System.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_761859__) => {

__nested_webpack_require_761859__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_761859__.d(__nested_webpack_exports__, {
/* harmony export */   System: () => (/* binding */ System),
/* harmony export */   SystemType: () => (/* binding */ SystemType)
/* harmony export */ });
/* harmony import */ var _Priority__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_761859__(/*! ./Priority */ "./EntityComponentSystem/Priority.ts");

/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur {@apilink System} that updates entities of certain types.
 * Systems are scene specific
 *
 *
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System {
 *   static priority = SystemPriority.Lowest;
 *   public readonly systemType = SystemType.Update;
 *   public query: Query<typeof TransformComponent>;
 *   constructor(public world: World) {
 *   super();
 *      this.query = this.world.query([TransformComponent]);
 *   }
 *   public update(elapsed: number) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
}
/**
 * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
 * For a system to execute before all other a lower priority value (-1 for example) must be set.
 * For a system to execute after all other a higher priority value (10 for example) must be set.
 */
System.priority = _Priority__WEBPACK_IMPORTED_MODULE_0__.SystemPriority.Average;


/***/ }),

/***/ "./EntityComponentSystem/SystemManager.ts":
/*!************************************************!*\
  !*** ./EntityComponentSystem/SystemManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_763889__) => {

__nested_webpack_require_763889__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_763889__.d(__nested_webpack_exports__, {
/* harmony export */   SystemManager: () => (/* binding */ SystemManager),
/* harmony export */   isSystemConstructor: () => (/* binding */ isSystemConstructor)
/* harmony export */ });
/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_763889__(/*! ./System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_763889__(/*! ../Util/Util */ "./Util/Util.ts");


/**
 *
 */
function isSystemConstructor(x) {
    var _a, _b;
    return !!(x === null || x === void 0 ? void 0 : x.prototype) && !!((_b = (_a = x === null || x === void 0 ? void 0 : x.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
}
/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call {@apilink SystemManager.addSystem}
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param systemOrCtor
     */
    addSystem(systemOrCtor) {
        let system;
        if (systemOrCtor instanceof _System__WEBPACK_IMPORTED_MODULE_0__.System) {
            system = systemOrCtor;
        }
        else {
            system = new systemOrCtor(this._world);
        }
        this.systems.push(system);
        this.systems.sort((a, b) => a.constructor.priority - b.constructor.priority);
        // If systems are added and the manager has already been init'd
        // then immediately init the system
        if (this.initialized && system.initialize) {
            system.initialize(this._world, this._world.scene);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        (0,_Util_Util__WEBPACK_IMPORTED_MODULE_1__.removeItemFromArray)(system, this.systems);
    }
    /**
     * Initialize all systems in the manager
     *
     * Systems added after initialize() will be initialized on add
     */
    initialize() {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world, this._world.scene);
                }
            }
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param scene context reference
     * @param elapsed time in milliseconds
     */
    updateSystems(type, scene, elapsed) {
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(scene, elapsed);
            }
        }
        for (const s of systems) {
            s.update(elapsed);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(scene, elapsed);
            }
        }
    }
    clear() {
        for (let i = this.systems.length - 1; i >= 0; i--) {
            this.removeSystem(this.systems[i]);
        }
    }
}


/***/ }),

/***/ "./EntityComponentSystem/TagQuery.ts":
/*!*******************************************!*\
  !*** ./EntityComponentSystem/TagQuery.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_767787__) => {

__nested_webpack_require_767787__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_767787__.d(__nested_webpack_exports__, {
/* harmony export */   TagQuery: () => (/* binding */ TagQuery)
/* harmony export */ });
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_767787__(/*! ../Util/Observable */ "./Util/Observable.ts");

class TagQuery {
    constructor(requiredTags) {
        this.requiredTags = requiredTags;
        this.tags = new Set();
        this.entities = [];
        /**
         * This fires right after the component is added
         */
        this.entityAdded$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * This fires right before the component is actually removed from the entity, it will still be available for cleanup purposes
         */
        this.entityRemoved$ = new _Util_Observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        if (requiredTags.length === 0) {
            throw new Error('Cannot create tag query without tags');
        }
        for (const tag of requiredTags) {
            this.tags.add(tag);
        }
        this.id = TagQuery.createId(requiredTags);
    }
    static createId(requiredComponents) {
        return requiredComponents.slice().sort().join('-');
    }
    checkAndAdd(entity) {
        if (!this.entities.includes(entity) && entity.hasAllTags(Array.from(this.tags))) {
            this.entities.push(entity);
            this.entityAdded$.notifyAll(entity);
            return true;
        }
        return false;
    }
    removeEntity(entity) {
        const index = this.entities.indexOf(entity);
        if (index > -1) {
            this.entities.splice(index, 1);
            this.entityRemoved$.notifyAll(entity);
        }
    }
    /**
     * Returns a list of entities that match the query
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this.entities.sort(sort);
        }
        return this.entities;
    }
}


/***/ }),

/***/ "./EntityComponentSystem/World.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/World.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_770121__) => {

__nested_webpack_require_770121__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_770121__.d(__nested_webpack_exports__, {
/* harmony export */   World: () => (/* binding */ World)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_770121__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityManager__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_770121__(/*! ./EntityManager */ "./EntityComponentSystem/EntityManager.ts");
/* harmony import */ var _QueryManager__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_770121__(/*! ./QueryManager */ "./EntityComponentSystem/QueryManager.ts");
/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_770121__(/*! ./System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _SystemManager__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_770121__(/*! ./SystemManager */ "./EntityComponentSystem/SystemManager.ts");





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param scene
     */
    constructor(scene) {
        this.scene = scene;
        this.queryManager = new _QueryManager__WEBPACK_IMPORTED_MODULE_0__.QueryManager(this);
        this.entityManager = new _EntityManager__WEBPACK_IMPORTED_MODULE_1__.EntityManager(this);
        this.systemManager = new _SystemManager__WEBPACK_IMPORTED_MODULE_2__.SystemManager(this);
    }
    /**
     * Query the ECS world for entities that match your components
     * @param requiredTypes
     */
    query(requiredTypes) {
        return this.queryManager.createQuery(requiredTypes);
    }
    queryTags(requiredTags) {
        return this.queryManager.createTagQuery(requiredTags);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, elapsed) {
        if (type === _System__WEBPACK_IMPORTED_MODULE_3__.SystemType.Update) {
            this.entityManager.updateEntities(this.scene, elapsed);
        }
        this.systemManager.updateSystems(type, this.scene, elapsed);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof _Entity__WEBPACK_IMPORTED_MODULE_4__.Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof _System__WEBPACK_IMPORTED_MODULE_3__.System || (0,_SystemManager__WEBPACK_IMPORTED_MODULE_2__.isSystemConstructor)(entityOrSystem)) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    /**
     * Get a system out of the ECS world
     */
    get(system) {
        return this.systemManager.get(system);
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof _Entity__WEBPACK_IMPORTED_MODULE_4__.Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof _System__WEBPACK_IMPORTED_MODULE_3__.System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    get entities() {
        return this.entityManager.entities;
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}


/***/ }),

/***/ "./EntityComponentSystem/index.ts":
/*!****************************************!*\
  !*** ./EntityComponentSystem/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_773819__) => {

__nested_webpack_require_773819__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_773819__.d(__nested_webpack_exports__, {
/* harmony export */   AddedComponent: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.AddedComponent),
/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   Entity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity),
/* harmony export */   EntityEvents: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.EntityEvents),
/* harmony export */   EntityManager: () => (/* reexport safe */ _EntityManager__WEBPACK_IMPORTED_MODULE_2__.EntityManager),
/* harmony export */   MotionComponent: () => (/* reexport safe */ _Components_MotionComponent__WEBPACK_IMPORTED_MODULE_11__.MotionComponent),
/* harmony export */   Query: () => (/* reexport safe */ _Query__WEBPACK_IMPORTED_MODULE_3__.Query),
/* harmony export */   QueryManager: () => (/* reexport safe */ _QueryManager__WEBPACK_IMPORTED_MODULE_5__.QueryManager),
/* harmony export */   RemovedComponent: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.RemovedComponent),
/* harmony export */   System: () => (/* reexport safe */ _System__WEBPACK_IMPORTED_MODULE_6__.System),
/* harmony export */   SystemManager: () => (/* reexport safe */ _SystemManager__WEBPACK_IMPORTED_MODULE_7__.SystemManager),
/* harmony export */   SystemPriority: () => (/* reexport safe */ _Priority__WEBPACK_IMPORTED_MODULE_9__.SystemPriority),
/* harmony export */   SystemType: () => (/* reexport safe */ _System__WEBPACK_IMPORTED_MODULE_6__.SystemType),
/* harmony export */   TagQuery: () => (/* reexport safe */ _TagQuery__WEBPACK_IMPORTED_MODULE_4__.TagQuery),
/* harmony export */   TransformComponent: () => (/* reexport safe */ _Components_TransformComponent__WEBPACK_IMPORTED_MODULE_10__.TransformComponent),
/* harmony export */   World: () => (/* reexport safe */ _World__WEBPACK_IMPORTED_MODULE_8__.World),
/* harmony export */   isAddedComponent: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.isAddedComponent),
/* harmony export */   isComponentCtor: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.isComponentCtor),
/* harmony export */   isRemovedComponent: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.isRemovedComponent),
/* harmony export */   isSystemConstructor: () => (/* reexport safe */ _SystemManager__WEBPACK_IMPORTED_MODULE_7__.isSystemConstructor)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_773819__(/*! ./Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_773819__(/*! ./Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityManager__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_773819__(/*! ./EntityManager */ "./EntityComponentSystem/EntityManager.ts");
/* harmony import */ var _Query__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_773819__(/*! ./Query */ "./EntityComponentSystem/Query.ts");
/* harmony import */ var _TagQuery__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_773819__(/*! ./TagQuery */ "./EntityComponentSystem/TagQuery.ts");
/* harmony import */ var _QueryManager__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_773819__(/*! ./QueryManager */ "./EntityComponentSystem/QueryManager.ts");
/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_773819__(/*! ./System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _SystemManager__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_773819__(/*! ./SystemManager */ "./EntityComponentSystem/SystemManager.ts");
/* harmony import */ var _World__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_773819__(/*! ./World */ "./EntityComponentSystem/World.ts");
/* harmony import */ var _Priority__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_773819__(/*! ./Priority */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _Components_TransformComponent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_773819__(/*! ./Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Components_MotionComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_773819__(/*! ./Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");















/***/ }),

/***/ "./EventEmitter.ts":
/*!*************************!*\
  !*** ./EventEmitter.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_778449__) => {

__nested_webpack_require_778449__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_778449__.d(__nested_webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)
/* harmony export */ });
/**
 * Excalibur's typed event emitter, this allows events to be sent with any string to Type mapping
 */
class EventEmitter {
    constructor() {
        this._paused = false;
        this._empty = true;
        this._listeners = {};
        this._listenersOnce = {};
        this._pipes = [];
    }
    /**
     * Removes all listeners and pipes
     */
    clear() {
        this._listeners = {};
        this._listenersOnce = {};
        this._pipes.length = 0;
        this._empty = true;
    }
    on(eventName, handler) {
        var _a;
        this._empty = false;
        this._listeners[eventName] = (_a = this._listeners[eventName]) !== null && _a !== void 0 ? _a : [];
        this._listeners[eventName].push(handler);
        return {
            close: () => this.off(eventName, handler)
        };
    }
    once(eventName, handler) {
        var _a;
        this._empty = false;
        this._listenersOnce[eventName] = (_a = this._listenersOnce[eventName]) !== null && _a !== void 0 ? _a : [];
        this._listenersOnce[eventName].push(handler);
        return {
            close: () => this.off(eventName, handler)
        };
    }
    off(eventName, handler) {
        var _a, _b;
        if (handler) {
            const newListeners = (_a = this._listeners[eventName]) === null || _a === void 0 ? void 0 : _a.filter((h) => h !== handler);
            this._listeners[eventName] = newListeners;
            const newOnceListeners = (_b = this._listenersOnce[eventName]) === null || _b === void 0 ? void 0 : _b.filter((h) => h !== handler);
            this._listenersOnce[eventName] = newOnceListeners;
        }
        else {
            delete this._listeners[eventName];
        }
    }
    emit(eventName, event) {
        if (this._empty) {
            return;
        }
        if (this._paused) {
            return;
        }
        const listeners = this._listeners[eventName];
        if (listeners) {
            for (let i = 0; i < listeners.length; i++) {
                listeners[i](event);
            }
        }
        const onces = this._listenersOnce[eventName];
        this._listenersOnce[eventName] = [];
        if (onces) {
            for (let i = 0; i < onces.length; i++) {
                onces[i](event);
            }
        }
        for (let i = 0; i < this._pipes.length; i++) {
            this._pipes[i].emit(eventName, event);
        }
    }
    /**
     * Replay events from this emitter to another
     * @param emitter
     */
    pipe(emitter) {
        if (this === emitter) {
            throw Error('Cannot pipe to self');
        }
        this._empty = false;
        this._pipes.push(emitter);
        return {
            close: () => {
                const i = this._pipes.indexOf(emitter);
                if (i > -1) {
                    this._pipes.splice(i, 1);
                }
            }
        };
    }
    /**
     * Remove any piped emitters
     * @param emitter
     */
    unpipe(emitter) {
        const i = this._pipes.indexOf(emitter);
        if (i > -1) {
            this._pipes.splice(i, 1);
        }
    }
    /**
     * Paused event emitters do not emit events
     */
    pause() {
        this._paused = true;
    }
    /**
     * Unpaused event emitter do emit events
     */
    unpause() {
        this._paused = false;
    }
}


/***/ }),

/***/ "./Events.ts":
/*!*******************!*\
  !*** ./Events.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_782185__) => {

__nested_webpack_require_782185__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_782185__.d(__nested_webpack_exports__, {
/* harmony export */   ActionCompleteEvent: () => (/* binding */ ActionCompleteEvent),
/* harmony export */   ActionStartEvent: () => (/* binding */ ActionStartEvent),
/* harmony export */   ActivateEvent: () => (/* binding */ ActivateEvent),
/* harmony export */   AddEvent: () => (/* binding */ AddEvent),
/* harmony export */   CollisionEndEvent: () => (/* binding */ CollisionEndEvent),
/* harmony export */   CollisionPostSolveEvent: () => (/* binding */ CollisionPostSolveEvent),
/* harmony export */   CollisionPreSolveEvent: () => (/* binding */ CollisionPreSolveEvent),
/* harmony export */   CollisionStartEvent: () => (/* binding */ CollisionStartEvent),
/* harmony export */   ContactEndEvent: () => (/* binding */ ContactEndEvent),
/* harmony export */   ContactStartEvent: () => (/* binding */ ContactStartEvent),
/* harmony export */   DeactivateEvent: () => (/* binding */ DeactivateEvent),
/* harmony export */   EnterTriggerEvent: () => (/* binding */ EnterTriggerEvent),
/* harmony export */   EnterViewPortEvent: () => (/* binding */ EnterViewPortEvent),
/* harmony export */   EventTypes: () => (/* binding */ EventTypes),
/* harmony export */   ExitTriggerEvent: () => (/* binding */ ExitTriggerEvent),
/* harmony export */   ExitViewPortEvent: () => (/* binding */ ExitViewPortEvent),
/* harmony export */   GameEvent: () => (/* binding */ GameEvent),
/* harmony export */   GameStartEvent: () => (/* binding */ GameStartEvent),
/* harmony export */   GameStopEvent: () => (/* binding */ GameStopEvent),
/* harmony export */   GamepadAxisEvent: () => (/* binding */ GamepadAxisEvent),
/* harmony export */   GamepadButtonEvent: () => (/* binding */ GamepadButtonEvent),
/* harmony export */   GamepadConnectEvent: () => (/* binding */ GamepadConnectEvent),
/* harmony export */   GamepadDisconnectEvent: () => (/* binding */ GamepadDisconnectEvent),
/* harmony export */   HiddenEvent: () => (/* binding */ HiddenEvent),
/* harmony export */   InitializeEvent: () => (/* binding */ InitializeEvent),
/* harmony export */   KillEvent: () => (/* binding */ KillEvent),
/* harmony export */   PostCollisionEvent: () => (/* binding */ PostCollisionEvent),
/* harmony export */   PostDebugDrawEvent: () => (/* binding */ PostDebugDrawEvent),
/* harmony export */   PostDrawEvent: () => (/* binding */ PostDrawEvent),
/* harmony export */   PostFrameEvent: () => (/* binding */ PostFrameEvent),
/* harmony export */   PostKillEvent: () => (/* binding */ PostKillEvent),
/* harmony export */   PostTransformDrawEvent: () => (/* binding */ PostTransformDrawEvent),
/* harmony export */   PostUpdateEvent: () => (/* binding */ PostUpdateEvent),
/* harmony export */   PreCollisionEvent: () => (/* binding */ PreCollisionEvent),
/* harmony export */   PreDebugDrawEvent: () => (/* binding */ PreDebugDrawEvent),
/* harmony export */   PreDrawEvent: () => (/* binding */ PreDrawEvent),
/* harmony export */   PreFrameEvent: () => (/* binding */ PreFrameEvent),
/* harmony export */   PreKillEvent: () => (/* binding */ PreKillEvent),
/* harmony export */   PreTransformDrawEvent: () => (/* binding */ PreTransformDrawEvent),
/* harmony export */   PreUpdateEvent: () => (/* binding */ PreUpdateEvent),
/* harmony export */   RemoveEvent: () => (/* binding */ RemoveEvent),
/* harmony export */   VisibleEvent: () => (/* binding */ VisibleEvent)
/* harmony export */ });
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
    EventTypes["ActionStart"] = "actionstart";
    EventTypes["ActionComplete"] = "actioncomplete";
    EventTypes["Add"] = "add";
    EventTypes["Remove"] = "remove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        /**
         * Other target object for this event
         */
        this.other = null;
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, elapsed, self) {
        super();
        this.ctx = ctx;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, elapsed, self) {
        super();
        this.ctx = ctx;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'pretransformdraw' event is emitted on actors/entities before any graphics transforms have taken place.
 * Useful if you need to completely customize the draw or modify the transform before drawing in the draw step (for example needing
 * latest camera positions)
 *
 */
class PreTransformDrawEvent extends GameEvent {
    constructor(ctx, elapsed, self) {
        super();
        this.ctx = ctx;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'posttransformdraw' event is emitted on actors/entities after all graphics have been draw and transforms reset.
 * Useful if you need to completely custom the draw after everything is done.
 *
 */
class PostTransformDrawEvent extends GameEvent {
    constructor(ctx, elapsed, self) {
        super();
        this.ctx = ctx;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, self) {
        super();
        this.ctx = ctx;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, self) {
        super();
        this.ctx = ctx;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, elapsed, self) {
        super();
        this.engine = engine;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, elapsed, self) {
        super();
        this.engine = engine;
        this.elapsed = elapsed;
        this.self = self;
        this.target = self;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. {@apilink Gamepads} receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. {@apilink Gamepads} receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See {@apilink Gamepads} for information on responding to controller input. {@apilink Gamepad} instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, self) {
        super();
        this.button = button;
        this.value = value;
        this.self = self;
        this.target = self;
    }
}
/**
 * Gamepad axis event. See {@apilink Gamepads} for information on responding to controller input. {@apilink Gamepad} instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, self) {
        super();
        this.axis = axis;
        this.value = value;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event received by the {@apilink Engine} when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * Event received by the {@apilink Engine} when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor | `actor`} when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param self          The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(self, other, side, intersection, contact) {
        super();
        this.self = self;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor | `actor`} when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param self          The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(self, other, side, intersection, contact) {
        super();
        this.self = self;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
        this.target = self;
    }
}
class ContactStartEvent {
    constructor(self, other, side, contact) {
        this.self = self;
        this.other = other;
        this.side = side;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(self, other, side, lastContact) {
        this.self = self;
        this.other = other;
        this.side = side;
        this.lastContact = lastContact;
    }
}
class CollisionPreSolveEvent {
    constructor(self, other, side, intersection, contact) {
        this.self = self;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(self, other, side, intersection, contact) {
        this.self = self;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an {@apilink Actor | `actor`} collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param self
     * @param other
     * @param side
     * @param contact
     */
    constructor(self, other, side, contact) {
        super();
        this.self = self;
        this.other = other;
        this.side = side;
        this.contact = contact;
        this.target = self;
    }
}
/**
 * Event thrown when the {@apilink Actor | `actor`} is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(self, other, side, lastContact) {
        super();
        this.self = self;
        this.other = other;
        this.side = side;
        this.lastContact = lastContact;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor}, {@apilink Scene}, and {@apilink Engine} only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, self) {
        super();
        this.engine = engine;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on a {@apilink Scene} on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene activation
     */
    constructor(context, self) {
        super();
        this.context = context;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on a {@apilink Scene} on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene deactivation
     */
    constructor(context, self) {
        super();
        this.context = context;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor} when the graphics bounds completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor} when any part of the graphics bounds are on screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(self) {
        super();
        this.self = self;
        this.target = self;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(self, entity) {
        super();
        this.self = self;
        this.entity = entity;
        this.target = self;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(self, entity) {
        super();
        this.self = self;
        this.entity = entity;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor} when an action starts.
 */
class ActionStartEvent extends GameEvent {
    constructor(action, self) {
        super();
        this.action = action;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an {@apilink Actor} when an action completes.
 */
class ActionCompleteEvent extends GameEvent {
    constructor(action, self) {
        super();
        this.action = action;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an [[Actor]] when an Actor added to scene.
 */
class AddEvent extends GameEvent {
    constructor(engine, self) {
        super();
        this.engine = engine;
        this.self = self;
        this.target = self;
    }
}
/**
 * Event thrown on an [[Actor]] when an Actor removed from scene.
 */
class RemoveEvent extends GameEvent {
    constructor(engine, self) {
        super();
        this.engine = engine;
        this.self = self;
        this.target = self;
    }
}


/***/ }),

/***/ "./Events/MediaEvents.ts":
/*!*******************************!*\
  !*** ./Events/MediaEvents.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_802111__) => {

__nested_webpack_require_802111__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_802111__.d(__nested_webpack_exports__, {
/* harmony export */   MediaEvent: () => (/* binding */ MediaEvent),
/* harmony export */   NativeSoundEvent: () => (/* binding */ NativeSoundEvent),
/* harmony export */   NativeSoundProcessedEvent: () => (/* binding */ NativeSoundProcessedEvent)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_802111__(/*! ../Events */ "./Events.ts");

class MediaEvent extends _Events__WEBPACK_IMPORTED_MODULE_0__.GameEvent {
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}


/***/ }),

/***/ "./Flags.ts":
/*!******************!*\
  !*** ./Flags.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_804273__) => {

__nested_webpack_require_804273__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_804273__.d(__nested_webpack_exports__, {
/* harmony export */   Flags: () => (/* binding */ Flags)
/* harmony export */ });
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before {@apilink Engine} construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Force excalibur to load the Canvas 2D graphics context fallback
     * @warning not all features of excalibur are supported in the Canvas 2D fallback
     */
    static useCanvasGraphicsContext() {
        Flags.enable('use-canvas-context');
    }
    /**
     * Force excalibur to use the less optimized image renderer
     */
    static useLegacyImageRenderer() {
        Flags.enable('use-legacy-image-renderer');
    }
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};


/***/ }),

/***/ "./GarbageCollector.ts":
/*!*****************************!*\
  !*** ./GarbageCollector.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_806917__) => {

__nested_webpack_require_806917__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_806917__.d(__nested_webpack_exports__, {
/* harmony export */   DefaultGarbageCollectionOptions: () => (/* binding */ DefaultGarbageCollectionOptions),
/* harmony export */   GarbageCollector: () => (/* binding */ GarbageCollector)
/* harmony export */ });
const DefaultGarbageCollectionOptions = {
    textureCollectInterval: 60000
    // TODO future work to integrate the font and text configuration, refactor existing collection mechanism
    // fontCollectInterval: 60_000,
    // textMeasurementCollectInterval: 60_000,
};
class GarbageCollector {
    constructor(options) {
        this.options = options;
        this._running = false;
        this._collectionMap = new Map();
        this._collectors = new Map();
        /**
         * Runs the collection loop to cleanup any stale resources given the registered collect handlers
         */
        this.collectStaleResources = (deadline) => {
            if (!this._running) {
                return;
            }
            for (const [type, [collector, timeoutInterval]] of this._collectors.entries()) {
                const now = this.options.getTimestamp();
                for (const [resource, [resourceType, time]] of this._collectionMap.entries()) {
                    if (type !== resourceType || time + timeoutInterval >= now) {
                        continue;
                    }
                    const collected = collector(resource);
                    if (collected) {
                        this._collectionMap.delete(resource);
                    }
                }
            }
            this._collectHandle = requestIdleCallback(this.collectStaleResources);
        };
    }
    /**
     *
     * @param type Resource type
     * @param timeoutInterval If resource type exceeds interval in milliseconds collect() is called
     * @param collect Collection implementation, returns true if collected
     */
    registerCollector(type, timeoutInterval, collect) {
        this._collectors.set(type, [collect, timeoutInterval]);
    }
    /**
     * Add a resource to be tracked for collection
     * @param type
     * @param resource
     */
    addCollectableResource(type, resource) {
        this._collectionMap.set(resource, [type, this.options.getTimestamp()]);
    }
    /**
     * Update the resource last used timestamp preventing collection
     * @param resource
     */
    touch(resource) {
        const collectionData = this._collectionMap.get(resource);
        if (collectionData) {
            this._collectionMap.set(resource, [collectionData[0], this.options.getTimestamp()]);
        }
    }
    /**
     * Force collect all resources, useful for shutting down a game
     * or if you know that you will not use anything you've allocated before now
     */
    forceCollectAll() {
        for (const [_, [collector]] of this._collectors.entries()) {
            for (const [resource] of this._collectionMap.entries()) {
                const collected = collector(resource);
                if (collected) {
                    this._collectionMap.delete(resource);
                }
            }
        }
    }
    /**
     * Starts the garbage collection loop
     */
    start() {
        this._running = true;
        this.collectStaleResources();
    }
    /**
     * Stops the garbage collection loop
     */
    stop() {
        this._running = false;
        cancelIdleCallback(this._collectHandle);
    }
}


/***/ }),

/***/ "./Graphics/Animation.ts":
/*!*******************************!*\
  !*** ./Graphics/Animation.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_810657__) => {

__nested_webpack_require_810657__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_810657__.d(__nested_webpack_exports__, {
/* harmony export */   Animation: () => (/* binding */ Animation),
/* harmony export */   AnimationDirection: () => (/* binding */ AnimationDirection),
/* harmony export */   AnimationEvents: () => (/* binding */ AnimationEvents),
/* harmony export */   AnimationStrategy: () => (/* binding */ AnimationStrategy)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_810657__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_810657__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_810657__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_810657__(/*! ../EventEmitter */ "./EventEmitter.ts");




var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is playing backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
const AnimationEvents = {
    Frame: 'frame',
    Loop: 'loop',
    End: 'end'
};
/**
 * Create an Animation given a list of {@apilink Frame | `frames`} in {@apilink AnimationOptions}
 *
 * To create an Animation from a {@apilink SpriteSheet}, use {@apilink Animation.fromSpriteSheet}
 */
class Animation extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        var _a, _b, _c;
        super(options);
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._pingPongDirection = 1;
        this._done = false;
        this._playing = true;
        this._speed = 1;
        this._reversed = false;
        this.frames = options.frames;
        this.speed = (_a = options.speed) !== null && _a !== void 0 ? _a : this.speed;
        this.strategy = (_b = options.strategy) !== null && _b !== void 0 ? _b : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_c = options.frameDuration) !== null && _c !== void 0 ? _c : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation({
            frames: this.frames.map((f) => ({ ...f })),
            frameDuration: this.frameDuration,
            speed: this.speed,
            reverse: this._reversed,
            strategy: this.strategy,
            ...this.cloneGraphicOptions()
        });
    }
    get width() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame && maybeFrame.graphic) {
            return Math.abs(maybeFrame.graphic.width * this.scale.x);
        }
        return 0;
    }
    get height() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame && maybeFrame.graphic) {
            return Math.abs(maybeFrame.graphic.height * this.scale.y);
        }
        return 0;
    }
    /**
     * Create an Animation from a {@apilink SpriteSheet}, a list of indices into the sprite sheet, a duration per frame
     * and optional {@apilink AnimationStrategy}
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     * @param spriteSheet ex.SpriteSheet
     * @param spriteSheetIndex 0 based index from left to right, top down (row major order) of the ex.SpriteSheet
     * @param durationPerFrame duration per frame in milliseconds
     * @param strategy Optional strategy, default AnimationStrategy.Loop
     */
    static fromSpriteSheet(spriteSheet, spriteSheetIndex, durationPerFrame, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = spriteSheetIndex.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => spriteSheetIndex.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrame
            })),
            strategy: strategy
        });
    }
    /**
     * Create an {@apilink Animation} from a {@apilink SpriteSheet} given a list of coordinates
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheetCoordinates({
     *  spriteSheet,
     *  frameCoordinates: [
     *    {x: 0, y: 5, duration: 100, options { flipHorizontal: true }},
     *    {x: 1, y: 5, duration: 200},
     *    {x: 2, y: 5},
     *    {x: 3, y: 5}
     *  ],
     *  strategy: AnimationStrategy.PingPong
     * });
     * ```
     * @param options
     * @returns Animation
     */
    static fromSpriteSheetCoordinates(options) {
        var _a;
        const { spriteSheet, frameCoordinates, durationPerFrame, durationPerFrameMs, speed, strategy, reverse } = options;
        const defaultDuration = (_a = durationPerFrame !== null && durationPerFrame !== void 0 ? durationPerFrame : durationPerFrameMs) !== null && _a !== void 0 ? _a : 100;
        const frames = [];
        for (const coord of frameCoordinates) {
            const { x, y, duration, options } = coord;
            const sprite = spriteSheet.getSprite(x, y, options);
            if (sprite) {
                frames.push({
                    graphic: sprite,
                    duration: duration !== null && duration !== void 0 ? duration : defaultDuration
                });
            }
            else {
                Animation._LOGGER.warn(`Skipping frame! SpriteSheet does not have coordinate (${x}, ${y}), please check your SpriteSheet to confirm that sprite exists`);
            }
        }
        return new Animation({
            frames,
            strategy,
            speed,
            reverse
        });
    }
    /**
     * Current animation speed
     *
     * 1 meaning normal 1x speed.
     * 2 meaning 2x speed and so on.
     */
    get speed() {
        return this._speed;
    }
    /**
     * Current animation speed
     *
     * 1 meaning normal 1x speed.
     * 2 meaning 2x speed and so on.
     */
    set speed(val) {
        this._speed = (0,_Math_util__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.abs(val), 0, Infinity);
    }
    /**
     * Returns the current Frame of the animation
     *
     * Use {@apilink Animation.currentFrameIndex} to get the frame number and
     * {@apilink Animation.goToFrame} to set the current frame index
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     *
     * Use {@apilink Animation.currentFrame} to grab the current {@apilink Frame} object
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns the amount of time in milliseconds left in the current frame
     */
    get currentFrameTimeLeft() {
        return this._timeLeftInFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    get isReversed() {
        return this._reversed;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = this._reversed && this._pingPongDirection === 1 ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
        }
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     *
     * Optionally specify an override for the duration of the frame, useful for
     * keeping multiple animations in sync with one another.
     * @param frameNumber
     * @param duration
     */
    goToFrame(frameNumber, duration) {
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = duration !== null && duration !== void 0 ? duration : this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = duration !== null && duration !== void 0 ? duration : ((maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration);
            this.events.emit('frame', { ...maybeFrame, frameIndex: this.currentFrameIndex });
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = (0,_Math_util__WEBPACK_IMPORTED_MODULE_2__.clamp)(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._pingPongDirection >= this.frames.length) {
                    this._pingPongDirection = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._pingPongDirection < 0) {
                    this._pingPongDirection = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._pingPongDirection % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsed Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsed, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', { ...this.currentFrame, frameIndex: this.currentFrameIndex });
        }
        this._timeLeftInFrame -= elapsed * this._speed;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame && this.currentFrame.graphic) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = _Util_Log__WEBPACK_IMPORTED_MODULE_3__.Logger.getInstance();


/***/ }),

/***/ "./Graphics/Canvas.ts":
/*!****************************!*\
  !*** ./Graphics/Canvas.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_825565__) => {

__nested_webpack_require_825565__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_825565__.d(__nested_webpack_exports__, {
/* harmony export */   Canvas: () => (/* binding */ Canvas)
/* harmony export */ });
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_825565__(/*! ./Raster */ "./Graphics/Raster.ts");

/**
 * A canvas {@apilink Graphic} to provide an adapter between the 2D Canvas API and the {@apilink ExcaliburGraphicsContext}.
 *
 * The {@apilink Canvas} works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the {@apilink ExcaliburGraphicsContext} implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends _Raster__WEBPACK_IMPORTED_MODULE_0__.Raster {
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    constructor(_options = {}) {
        super(_options);
        this._options = _options;
    }
    clone() {
        return new Canvas({
            ...this._options,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}


/***/ }),

/***/ "./Graphics/Circle.ts":
/*!****************************!*\
  !*** ./Graphics/Circle.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_827233__) => {

__nested_webpack_require_827233__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_827233__.d(__nested_webpack_exports__, {
/* harmony export */   Circle: () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_827233__(/*! ./Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_827233__(/*! ./Raster */ "./Graphics/Raster.ts");


/**
 * A circle {@apilink Graphic} for drawing circles to the {@apilink ExcaliburGraphicsContext}
 *
 * Circles default to {@apilink ImageFiltering.Blended}
 */
class Circle extends _Raster__WEBPACK_IMPORTED_MODULE_0__.Raster {
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    constructor(options) {
        var _a, _b, _c;
        super(options);
        this._radius = 0;
        const lineWidth = (_a = options.lineWidth) !== null && _a !== void 0 ? _a : (options.strokeColor ? 1 : 0); // default lineWidth in canvas is 1px
        this.padding = (_b = options.padding) !== null && _b !== void 0 ? _b : 2 + lineWidth / 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.filtering = (_c = options.filtering) !== null && _c !== void 0 ? _c : _Filtering__WEBPACK_IMPORTED_MODULE_1__.ImageFiltering.Blended;
        this.rasterize();
    }
    clone() {
        return new Circle({
            radius: this.radius,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}


/***/ }),

/***/ "./Graphics/Context/ExcaliburGraphicsContext.ts":
/*!******************************************************!*\
  !*** ./Graphics/Context/ExcaliburGraphicsContext.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_829580__) => {

__nested_webpack_require_829580__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_829580__.d(__nested_webpack_exports__, {
/* harmony export */   DefaultAntialiasOptions: () => (/* binding */ DefaultAntialiasOptions),
/* harmony export */   DefaultPixelArtOptions: () => (/* binding */ DefaultPixelArtOptions)
/* harmony export */ });
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_829580__(/*! ../Filtering */ "./Graphics/Filtering.ts");

const DefaultAntialiasOptions = {
    pixelArtSampler: false,
    nativeContextAntialiasing: false,
    multiSampleAntialiasing: true,
    filtering: _Filtering__WEBPACK_IMPORTED_MODULE_0__.ImageFiltering.Blended,
    canvasImageRendering: 'auto'
};
const DefaultPixelArtOptions = {
    pixelArtSampler: true,
    nativeContextAntialiasing: false,
    multiSampleAntialiasing: true,
    filtering: _Filtering__WEBPACK_IMPORTED_MODULE_0__.ImageFiltering.Blended,
    canvasImageRendering: 'auto'
};


/***/ }),

/***/ "./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts":
/*!**************************************************************!*\
  !*** ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_830897__) => {

__nested_webpack_require_830897__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_830897__.d(__nested_webpack_exports__, {
/* harmony export */   ExcaliburGraphicsContext2DCanvas: () => (/* binding */ ExcaliburGraphicsContext2DCanvas)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_830897__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _state_stack__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_830897__(/*! ./state-stack */ "./Graphics/Context/state-stack.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_830897__(/*! ../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _debug_text__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_830897__(/*! ./debug-text */ "./Graphics/Context/debug-text.ts");




const pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new _debug_text__WEBPACK_IMPORTED_MODULE_0__.DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this._ex.snapToPixel ? ~~(y + pixelSnapEpsilon) : y, this._ex.snapToPixel ? ~~(width + pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + pixelSnapEpsilon) : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black }) {
        var _a, _b;
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = (_b = (_a = lineOptions.color) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point.x + pixelSnapEpsilon) : point.x, this._ex.snapToPixel ? ~~(point.y + pixelSnapEpsilon) : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    constructor(options) {
        /**
         * Unused in Canvas implementation
         */
        this.useDrawSorting = false;
        /**
         * Unused in Canvas implementation
         */
        this.z = 0;
        this.backgroundColor = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.ExcaliburBlue;
        this._state = new _state_stack__WEBPACK_IMPORTED_MODULE_2__.StateStack();
        this.snapToPixel = false;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, context, enableTransparency, snapToPixel, antialiasing: smoothing, backgroundColor } = options;
        this.__ctx =
            context !== null && context !== void 0 ? context : canvasElement.getContext('2d', {
                alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
            });
        if (!this.__ctx) {
            throw new Error('Cannot build new ExcaliburGraphicsContext2D for some reason!');
        }
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport(_resolution) {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_3__.GraphicsDiagnostics.DrawCallCount++;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_3__.GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + pixelSnapEpsilon) : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.__ctx.save();
        this.__ctx.beginPath();
        if (stroke) {
            this.__ctx.strokeStyle = stroke.toString();
        }
        if (thickness) {
            this.__ctx.lineWidth = thickness;
        }
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        if (stroke) {
            this.__ctx.stroke();
        }
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
        this._state.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
        this._state.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    getTransform() {
        throw new Error('Not implemented');
    }
    multiply(_m) {
        this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));
    }
    addPostProcessor(_postprocessor) {
        // pass
    }
    removePostProcessor(_postprocessor) {
        // pass
    }
    clearPostProcessors() {
        // pass
    }
    updatePostProcessors(elapsed) {
        // pass
    }
    beginDrawLifecycle() {
        // pass
    }
    endDrawLifecycle() {
        // pass
    }
    set material(material) {
        this._state.current.material = material;
    }
    get material() {
        return this._state.current.material;
    }
    createMaterial(options) {
        // pass
        return null;
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_3__.GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
    dispose() {
        this.__ctx = undefined;
    }
}


/***/ }),

/***/ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts":
/*!***********************************************************!*\
  !*** ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_841004__) => {

__nested_webpack_require_841004__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_841004__.d(__nested_webpack_exports__, {
/* harmony export */   ExcaliburGraphicsContextWebGL: () => (/* binding */ ExcaliburGraphicsContextWebGL),
/* harmony export */   pixelSnapEpsilon: () => (/* binding */ pixelSnapEpsilon)
/* harmony export */ });
/* harmony import */ var _Math_matrix__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_841004__(/*! ../../Math/matrix */ "./Math/matrix.ts");
/* harmony import */ var _transform_stack__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_841004__(/*! ./transform-stack */ "./Graphics/Context/transform-stack.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_841004__(/*! ../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_841004__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _state_stack__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_841004__(/*! ./state-stack */ "./Graphics/Context/state-stack.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_841004__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _debug_text__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_841004__(/*! ./debug-text */ "./Graphics/Context/debug-text.ts");
/* harmony import */ var _render_target__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_841004__(/*! ./render-target */ "./Graphics/Context/render-target.ts");
/* harmony import */ var _texture_loader__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_841004__(/*! ./texture-loader */ "./Graphics/Context/texture-loader.ts");
/* harmony import */ var _line_renderer_line_renderer__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_841004__(/*! ./line-renderer/line-renderer */ "./Graphics/Context/line-renderer/line-renderer.ts");
/* harmony import */ var _point_renderer_point_renderer__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_841004__(/*! ./point-renderer/point-renderer */ "./Graphics/Context/point-renderer/point-renderer.ts");
/* harmony import */ var _screen_pass_painter_screen_pass_painter__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_841004__(/*! ./screen-pass-painter/screen-pass-painter */ "./Graphics/Context/screen-pass-painter/screen-pass-painter.ts");
/* harmony import */ var _image_renderer_image_renderer__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_841004__(/*! ./image-renderer/image-renderer */ "./Graphics/Context/image-renderer/image-renderer.ts");
/* harmony import */ var _rectangle_renderer_rectangle_renderer__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_841004__(/*! ./rectangle-renderer/rectangle-renderer */ "./Graphics/Context/rectangle-renderer/rectangle-renderer.ts");
/* harmony import */ var _circle_renderer_circle_renderer__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_841004__(/*! ./circle-renderer/circle-renderer */ "./Graphics/Context/circle-renderer/circle-renderer.ts");
/* harmony import */ var _Util_Pool__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_841004__(/*! ../../Util/Pool */ "./Util/Pool.ts");
/* harmony import */ var _draw_call__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_841004__(/*! ./draw-call */ "./Graphics/Context/draw-call.ts");
/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_841004__(/*! ./material */ "./Graphics/Context/material.ts");
/* harmony import */ var _material_renderer_material_renderer__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_841004__(/*! ./material-renderer/material-renderer */ "./Graphics/Context/material-renderer/material-renderer.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_841004__(/*! ./shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _particle_renderer_particle_renderer__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_841004__(/*! ./particle-renderer/particle-renderer */ "./Graphics/Context/particle-renderer/particle-renderer.ts");
/* harmony import */ var _image_renderer_v2_image_renderer_v2__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_841004__(/*! ./image-renderer-v2/image-renderer-v2 */ "./Graphics/Context/image-renderer-v2/image-renderer-v2.ts");
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_841004__(/*! ../../Flags */ "./Flags.ts");









// renderers














const pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new _debug_text__WEBPACK_IMPORTED_MODULE_0__.DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black }) {
        this.drawLine((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x, y), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x + width, y), { ...rectOptions });
        this.drawLine((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x + width, y), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x + width, y + height), { ...rectOptions });
        this.drawLine((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x + width, y + height), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x, y + height), { ...rectOptions });
        this.drawLine((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x, y + height), (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(x, y), { ...rectOptions });
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions) {
        var _a;
        this._webglCtx.draw('ex.line', start, end, (_a = lineOptions === null || lineOptions === void 0 ? void 0 : lineOptions.color) !== null && _a !== void 0 ? _a : _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black, size: 5 }) {
        this._webglCtx.draw('ex.point', point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    get z() {
        return this._state.current.z;
    }
    set z(value) {
        this._state.current.z = value;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    get ortho() {
        return this._ortho;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        let supported = true;
        if (dim.width > 4096 || dim.height > 4096) {
            supported = false;
        }
        return supported;
    }
    constructor(options) {
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_3__.Logger.getInstance();
        this._renderers = new Map();
        this.imageRenderer = _Flags__WEBPACK_IMPORTED_MODULE_4__.Flags.isEnabled('use-legacy-image-renderer') ? 'ex.image' : 'ex.image-v2';
        this._isDrawLifecycle = false;
        this.useDrawSorting = true;
        this._drawCallPool = new _Util_Pool__WEBPACK_IMPORTED_MODULE_5__.Pool(() => new _draw_call__WEBPACK_IMPORTED_MODULE_6__.DrawCall(), undefined, 4000);
        this._drawCallIndex = 0;
        this._drawCalls = new Array(4000).fill(null);
        // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process
        this._postProcessTargets = [];
        this._postprocessors = [];
        this._transform = new _transform_stack__WEBPACK_IMPORTED_MODULE_7__.TransformStack();
        this._state = new _state_stack__WEBPACK_IMPORTED_MODULE_8__.StateStack();
        /**
         * Snaps the drawing x/y coordinate to the nearest whole pixel
         */
        this.snapToPixel = false;
        /**
         * Native context smoothing
         */
        this.smoothing = false;
        /**
         * Whether the pixel art sampler is enabled for smooth sub pixel anti-aliasing
         */
        this.pixelArtSampler = false;
        /**
         * UV padding in pixels to use in internal image rendering to prevent texture bleed
         *
         */
        this.uvPadding = 0.01;
        this.backgroundColor = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.ExcaliburBlue;
        this.multiSampleAntialiasing = true;
        this.transparency = true;
        this._isContextLost = false;
        this._disposed = false;
        this._imageToWidth = new Map();
        this._imageToHeight = new Map();
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        this._totalPostProcessorTime = 0;
        const { canvasElement, context, enableTransparency, antialiasing, uvPadding, multiSampleAntialiasing, pixelArtSampler, powerPreference, snapToPixel, backgroundColor, useDrawSorting, garbageCollector, handleContextLost, handleContextRestored } = options;
        this.__gl =
            context !== null && context !== void 0 ? context : canvasElement.getContext('webgl2', {
                antialias: antialiasing !== null && antialiasing !== void 0 ? antialiasing : this.smoothing,
                premultipliedAlpha: false,
                alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : this.transparency,
                depth: false,
                powerPreference: powerPreference !== null && powerPreference !== void 0 ? powerPreference : 'high-performance'
            });
        if (!this.__gl) {
            throw Error('Failed to retrieve webgl context from browser');
        }
        if (handleContextLost) {
            this.__gl.canvas.addEventListener('webglcontextlost', handleContextLost, false);
        }
        if (handleContextRestored) {
            this.__gl.canvas.addEventListener('webglcontextrestored', handleContextRestored, false);
        }
        this.__gl.canvas.addEventListener('webglcontextlost', () => {
            this._isContextLost = true;
        });
        this.__gl.canvas.addEventListener('webglcontextrestored', () => {
            this._isContextLost = false;
        });
        this.textureLoader = new _texture_loader__WEBPACK_IMPORTED_MODULE_9__.TextureLoader(this.__gl, garbageCollector);
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = antialiasing !== null && antialiasing !== void 0 ? antialiasing : this.smoothing;
        this.transparency = enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : this.transparency;
        this.pixelArtSampler = pixelArtSampler !== null && pixelArtSampler !== void 0 ? pixelArtSampler : this.pixelArtSampler;
        this.uvPadding = uvPadding !== null && uvPadding !== void 0 ? uvPadding : this.uvPadding;
        this.multiSampleAntialiasing = typeof multiSampleAntialiasing === 'boolean' ? multiSampleAntialiasing : this.multiSampleAntialiasing;
        this.samples = typeof multiSampleAntialiasing === 'object' ? multiSampleAntialiasing.samples : undefined;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;
        this._drawCallPool.disableWarnings = true;
        this._drawCallPool.preallocate();
        this._init();
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this.textureLoader.dispose();
            for (const renderer of this._renderers.values()) {
                renderer.dispose();
            }
            this._renderers.clear();
            this._drawCallPool.dispose();
            this._drawCalls.length = 0;
            this.__gl = null;
        }
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = _Math_matrix__WEBPACK_IMPORTED_MODULE_10__.Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(false);
        // Setup builtin renderers
        this.register(new _image_renderer_image_renderer__WEBPACK_IMPORTED_MODULE_11__.ImageRenderer({
            uvPadding: this.uvPadding,
            pixelArtSampler: this.pixelArtSampler
        }));
        this.register(new _material_renderer_material_renderer__WEBPACK_IMPORTED_MODULE_12__.MaterialRenderer());
        this.register(new _rectangle_renderer_rectangle_renderer__WEBPACK_IMPORTED_MODULE_13__.RectangleRenderer());
        this.register(new _circle_renderer_circle_renderer__WEBPACK_IMPORTED_MODULE_14__.CircleRenderer());
        this.register(new _point_renderer_point_renderer__WEBPACK_IMPORTED_MODULE_15__.PointRenderer());
        this.register(new _line_renderer_line_renderer__WEBPACK_IMPORTED_MODULE_16__.LineRenderer());
        this.register(new _particle_renderer_particle_renderer__WEBPACK_IMPORTED_MODULE_17__.ParticleRenderer());
        this.register(new _image_renderer_v2_image_renderer_v2__WEBPACK_IMPORTED_MODULE_18__.ImageRendererV2({
            uvPadding: this.uvPadding,
            pixelArtSampler: this.pixelArtSampler
        }));
        this.materialScreenTexture = gl.createTexture();
        if (!this.materialScreenTexture) {
            throw new Error('Could not create screen texture!');
        }
        gl.bindTexture(gl.TEXTURE_2D, this.materialScreenTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.bindTexture(gl.TEXTURE_2D, null);
        this._screenRenderer = new _screen_pass_painter_screen_pass_painter__WEBPACK_IMPORTED_MODULE_19__.ScreenPassPainter(gl);
        this._renderTarget = new _render_target__WEBPACK_IMPORTED_MODULE_20__.RenderTarget({
            gl,
            transparency: this.transparency,
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this._postProcessTargets = [
            new _render_target__WEBPACK_IMPORTED_MODULE_20__.RenderTarget({
                gl,
                transparency: this.transparency,
                width: gl.canvas.width,
                height: gl.canvas.height
            }),
            new _render_target__WEBPACK_IMPORTED_MODULE_20__.RenderTarget({
                gl,
                transparency: this.transparency,
                width: gl.canvas.width,
                height: gl.canvas.height
            })
        ];
        this._msaaTarget = new _render_target__WEBPACK_IMPORTED_MODULE_20__.RenderTarget({
            gl,
            transparency: this.transparency,
            width: gl.canvas.width,
            height: gl.canvas.height,
            antialias: this.multiSampleAntialiasing,
            samples: this.samples
        });
    }
    register(renderer) {
        this._renderers.set(renderer.type, renderer);
        renderer.initialize(this.__gl, this);
    }
    get(rendererName) {
        return this._renderers.get(rendererName);
    }
    _isCurrentRenderer(renderer) {
        if (!this._currentRenderer || this._currentRenderer === renderer) {
            return true;
        }
        return false;
    }
    beginDrawLifecycle() {
        this._isDrawLifecycle = true;
    }
    endDrawLifecycle() {
        this._isDrawLifecycle = false;
    }
    draw(rendererName, ...args) {
        if (true) {
            if (args.length > 9) {
                throw new Error('Only 10 or less renderer arguments are supported!;');
            }
        }
        if (!this._isDrawLifecycle) {
            this._logger.warnOnce(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\n` +
                `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);
        }
        if (this._isContextLost) {
            this._logger.errorOnce(`Unable to draw ${rendererName}, the webgl context is lost`);
            return;
        }
        const renderer = this._renderers.get(rendererName);
        if (renderer) {
            if (this.useDrawSorting) {
                const drawCall = this._drawCallPool.get();
                drawCall.z = this._state.current.z;
                drawCall.priority = renderer.priority;
                drawCall.renderer = rendererName;
                this.getTransform().clone(drawCall.transform);
                drawCall.state.z = this._state.current.z;
                drawCall.state.opacity = this._state.current.opacity;
                drawCall.state.tint = this._state.current.tint;
                drawCall.state.material = this._state.current.material;
                drawCall.args[0] = args[0];
                drawCall.args[1] = args[1];
                drawCall.args[2] = args[2];
                drawCall.args[3] = args[3];
                drawCall.args[4] = args[4];
                drawCall.args[5] = args[5];
                drawCall.args[6] = args[6];
                drawCall.args[7] = args[7];
                drawCall.args[8] = args[8];
                drawCall.args[9] = args[9];
                this._drawCalls[this._drawCallIndex++] = drawCall;
            }
            else {
                // Set the current renderer if not defined
                if (!this._currentRenderer) {
                    this._currentRenderer = renderer;
                }
                if (!this._isCurrentRenderer(renderer)) {
                    // switching graphics means we must flush the previous
                    this._currentRenderer.flush();
                }
                // If we are still using the same renderer we can add to the current batch
                renderer.draw(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                this._currentRenderer = renderer;
            }
        }
        else {
            throw Error(`No renderer with name ${rendererName} has been registered`);
        }
    }
    resetTransform() {
        this._transform.reset();
    }
    updateViewport(resolution) {
        const gl = this.__gl;
        this._ortho = this._ortho = _Math_matrix__WEBPACK_IMPORTED_MODULE_10__.Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);
        this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);
        this._msaaTarget.setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);
    }
    _getImageWidth(image) {
        let maybeWidth = this._imageToWidth.get(image);
        if (maybeWidth === undefined) {
            maybeWidth = image.width;
            this._imageToWidth.set(image, maybeWidth);
        }
        return maybeWidth;
    }
    _getImageHeight(image) {
        let maybeHeight = this._imageToHeight.get(image);
        if (maybeHeight === undefined) {
            maybeHeight = image.height;
            this._imageToHeight.set(image, maybeHeight);
        }
        return maybeHeight;
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (this._getImageWidth(image) === 0 || this._getImageHeight(image) === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            _Util_Log__WEBPACK_IMPORTED_MODULE_3__.Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        if (this._state.current.material) {
            this.draw('ex.material', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
        }
        else {
            if (this.imageRenderer === 'ex.image') {
                this.draw(this.imageRenderer, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
            }
            else {
                this.draw(this.imageRenderer, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
            }
        }
    }
    drawLine(start, end, color, thickness = 1) {
        this.draw('ex.rectangle', start, end, color, thickness);
    }
    drawRectangle(pos, width, height, color, stroke, strokeThickness) {
        this.draw('ex.rectangle', pos, width, height, color, stroke, strokeThickness);
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.draw('ex.circle', pos, radius, color, stroke, thickness);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    getTransform() {
        return this._transform.current;
    }
    multiply(m) {
        this._transform.current.multiply(m, this._transform.current);
    }
    addPostProcessor(postprocessor) {
        this._postprocessors.push(postprocessor);
        postprocessor.initialize(this.__gl);
    }
    removePostProcessor(postprocessor) {
        const index = this._postprocessors.indexOf(postprocessor);
        if (index !== -1) {
            this._postprocessors.splice(index, 1);
        }
    }
    clearPostProcessors() {
        this._postprocessors.length = 0;
    }
    updatePostProcessors(elapsed) {
        for (const postprocessor of this._postprocessors) {
            const shader = postprocessor.getShader();
            shader.use();
            const uniforms = shader.getUniforms();
            this._totalPostProcessorTime += elapsed;
            if (uniforms.find((u) => u.name === 'u_time_ms')) {
                shader.setUniformFloat('u_time_ms', this._totalPostProcessorTime);
            }
            if (uniforms.find((u) => u.name === 'u_elapsed_ms')) {
                shader.setUniformFloat('u_elapsed_ms', elapsed);
            }
            if (uniforms.find((u) => u.name === 'u_resolution')) {
                shader.setUniformFloatVector('u_resolution', (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(this.width, this.height));
            }
            if (postprocessor.onUpdate) {
                postprocessor.onUpdate(elapsed);
            }
        }
    }
    set material(material) {
        this._state.current.material = material;
    }
    get material() {
        return this._state.current.material;
    }
    /**
     * Creates and initializes the material which compiles the internal shader
     * @param options
     * @returns Material
     */
    createMaterial(options) {
        const material = new _material__WEBPACK_IMPORTED_MODULE_21__.Material({ ...options, graphicsContext: this });
        return material;
    }
    createShader(options) {
        const gl = this.__gl;
        const { vertexSource, fragmentSource } = options;
        const shader = new _shader__WEBPACK_IMPORTED_MODULE_22__.Shader({
            gl,
            vertexSource,
            fragmentSource
        });
        shader.compile();
        return shader;
    }
    clear() {
        const gl = this.__gl;
        const currentTarget = this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget;
        currentTarget.use();
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        var _a;
        if (this._isContextLost) {
            this._logger.errorOnce(`Unable to flush the webgl context is lost`);
            return;
        }
        // render target captures all draws and redirects to the render target
        let currentTarget = this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget;
        currentTarget.use();
        if (this.useDrawSorting) {
            // null out unused draw calls
            for (let i = this._drawCallIndex; i < this._drawCalls.length; i++) {
                this._drawCalls[i] = null;
            }
            // sort draw calls
            // Find the original order of the first instance of the draw call
            const originalSort = new Map();
            for (const [name] of this._renderers) {
                let firstIndex = 0;
                for (firstIndex = 0; firstIndex < this._drawCallIndex; firstIndex++) {
                    if (this._drawCalls[firstIndex].renderer === name) {
                        break;
                    }
                }
                originalSort.set(name, firstIndex);
            }
            this._drawCalls.sort((a, b) => {
                if (a === null || b === null) {
                    return 0;
                }
                const zIndex = a.z - b.z;
                const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);
                const priority = a.priority - b.priority;
                if (zIndex === 0) {
                    // sort by z first
                    if (priority === 0) {
                        // sort by priority
                        return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order
                    }
                    return priority;
                }
                return zIndex;
            });
            const oldTransform = this._transform.current;
            const oldState = this._state.current;
            if (this._drawCalls.length && this._drawCallIndex) {
                let currentRendererName = this._drawCalls[0].renderer;
                let currentRenderer = this._renderers.get(currentRendererName);
                for (let i = 0; i < this._drawCallIndex; i++) {
                    // hydrate the state for renderers
                    this._transform.current = this._drawCalls[i].transform;
                    this._state.current = this._drawCalls[i].state;
                    if (this._drawCalls[i].renderer !== currentRendererName) {
                        // switching graphics renderer means we must flush the previous
                        currentRenderer.flush();
                        currentRendererName = this._drawCalls[i].renderer;
                        currentRenderer = this._renderers.get(currentRendererName);
                    }
                    // ! hack to grab screen texture before materials run because they might want it
                    if (currentRenderer instanceof _material_renderer_material_renderer__WEBPACK_IMPORTED_MODULE_12__.MaterialRenderer && ((_a = this.material) === null || _a === void 0 ? void 0 : _a.isUsingScreenTexture)) {
                        currentTarget.copyToTexture(this.materialScreenTexture);
                        currentTarget.use();
                    }
                    // If we are still using the same renderer we can add to the current batch
                    currentRenderer.draw(...this._drawCalls[i].args);
                }
                if (currentRenderer.hasPendingDraws()) {
                    currentRenderer.flush();
                }
            }
            // reset state
            this._transform.current = oldTransform;
            this._state.current = oldState;
            // reclaim draw calls
            this._drawCallPool.done();
            this._drawCallIndex = 0;
            this._imageToHeight.clear();
            this._imageToWidth.clear();
        }
        else {
            // This is the final flush at the moment to draw any leftover pending draw
            for (const renderer of this._renderers.values()) {
                if (renderer.hasPendingDraws()) {
                    renderer.flush();
                }
            }
        }
        currentTarget.disable();
        // post process step
        if (this._postprocessors.length > 0) {
            const source = currentTarget.toRenderSource();
            source.use();
        }
        // flip flop render targets for post processing
        for (let i = 0; i < this._postprocessors.length; i++) {
            currentTarget = this._postProcessTargets[i % 2];
            this._postProcessTargets[i % 2].use();
            this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);
            this._postProcessTargets[i % 2].toRenderSource().use();
        }
        // Final blit to the screen
        currentTarget.blitToScreen();
    }
}


/***/ }),

/***/ "./Graphics/Context/circle-renderer/circle-renderer.ts":
/*!*************************************************************!*\
  !*** ./Graphics/Context/circle-renderer/circle-renderer.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_872098__) => {

__nested_webpack_require_872098__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_872098__.d(__nested_webpack_exports__, {
/* harmony export */   CircleRenderer: () => (/* binding */ CircleRenderer)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_872098__(/*! ../../../Color */ "./Color.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_872098__(/*! ../../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_872098__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_872098__(/*! ../ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _quad_index_buffer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_872098__(/*! ../quad-index-buffer */ "./Graphics/Context/quad-index-buffer.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_872098__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_872098__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_872098__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _circle_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_872098__(/*! ./circle-renderer.frag.glsl */ "./Graphics/Context/circle-renderer/circle-renderer.frag.glsl");
/* harmony import */ var _circle_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_872098__(/*! ./circle-renderer.vert.glsl */ "./Graphics/Context/circle-renderer/circle-renderer.vert.glsl");










class CircleRenderer {
    constructor() {
        this.type = 'ex.circle';
        this.priority = 0;
        this._maxCircles = 10922; // max(uint16) / 6 verts
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_0__.Shader({
            gl,
            fragmentSource: _circle_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
            vertexSource: _circle_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_2__["default"]
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__.VertexBuffer({
            gl,
            size: 14 * 4 * this._maxCircles,
            type: 'dynamic'
        });
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_4__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new _quad_index_buffer__WEBPACK_IMPORTED_MODULE_5__.QuadIndexBuffer(gl, this._maxCircles, true);
    }
    dispose() {
        this._buffer.dispose();
        this._quads.dispose();
        this._shader.dispose();
        this._context = null;
        this._gl = null;
    }
    _isFull() {
        if (this._circleCount >= this._maxCircles) {
            return true;
        }
        return false;
    }
    draw(pos, radius, color, stroke = _Color__WEBPACK_IMPORTED_MODULE_6__.Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._circleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(-radius, -radius)));
        const topRight = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(radius, -radius)));
        const bottomRight = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(radius, radius)));
        const bottomLeft = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(-radius, radius)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
        }
        // TODO UV could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    }
    hasPendingDraws() {
        return this._circleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._circleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__.GraphicsDiagnostics.DrawnImagesCount += this._circleCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__.GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
}


/***/ }),

/***/ "./Graphics/Context/debug-text.ts":
/*!****************************************!*\
  !*** ./Graphics/Context/debug-text.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_882447__) => {

__nested_webpack_require_882447__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_882447__.d(__nested_webpack_exports__, {
/* harmony export */   DebugText: () => (/* binding */ DebugText)
/* harmony export */ });
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_882447__(/*! ../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _SpriteFont__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_882447__(/*! ../SpriteFont */ "./Graphics/SpriteFont.ts");
/* harmony import */ var _SpriteSheet__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_882447__(/*! ../SpriteSheet */ "./Graphics/SpriteSheet.ts");
/* harmony import */ var _debug_font_png__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_882447__(/*! ./debug-font.png */ "./Graphics/Context/debug-font.png");




/**
 * Internal debug text helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = _debug_font_png__WEBPACK_IMPORTED_MODULE_0__["default"];
        this.size = 16;
        // We fire and forget, we don't care if it's loaded or not
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.load();
    }
    load() {
        this._imageSource = new _ImageSource__WEBPACK_IMPORTED_MODULE_1__.ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = _SpriteSheet__WEBPACK_IMPORTED_MODULE_2__.SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 4,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new _SpriteFont__WEBPACK_IMPORTED_MODULE_3__.SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+# ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, null, pos.x, pos.y);
        }
    }
}


/***/ }),

/***/ "./Graphics/Context/draw-call.ts":
/*!***************************************!*\
  !*** ./Graphics/Context/draw-call.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_885006__) => {

__nested_webpack_require_885006__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_885006__.d(__nested_webpack_exports__, {
/* harmony export */   DrawCall: () => (/* binding */ DrawCall)
/* harmony export */ });
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_885006__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_885006__(/*! ../../Color */ "./Color.ts");


class DrawCall {
    constructor() {
        this.z = 0;
        this.priority = 0;
        this.renderer = '';
        this.transform = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_0__.AffineMatrix.identity();
        this.state = {
            z: 0,
            opacity: 1,
            tint: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White,
            material: null
        };
        this.args = new Array(10);
    }
}


/***/ }),

/***/ "./Graphics/Context/image-renderer-v2/image-renderer-v2.ts":
/*!*****************************************************************!*\
  !*** ./Graphics/Context/image-renderer-v2/image-renderer-v2.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_886277__) => {

__nested_webpack_require_886277__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_886277__.d(__nested_webpack_exports__, {
/* harmony export */   ImageRendererV2: () => (/* binding */ ImageRendererV2)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_886277__(/*! ../../../Color */ "./Color.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_886277__(/*! ../../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_886277__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_886277__(/*! ../../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_886277__(/*! ../../Wrapping */ "./Graphics/Wrapping.ts");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_886277__(/*! ../ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_886277__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_886277__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_886277__(/*! ../webgl-util */ "./Graphics/Context/webgl-util.ts");
/* harmony import */ var _image_renderer_v2_frag_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_886277__(/*! ./image-renderer-v2.frag.glsl */ "./Graphics/Context/image-renderer-v2/image-renderer-v2.frag.glsl");
/* harmony import */ var _image_renderer_v2_vert_glsl__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_886277__(/*! ./image-renderer-v2.vert.glsl */ "./Graphics/Context/image-renderer-v2/image-renderer-v2.vert.glsl");
// import { Color } from '../../../Color';
// import { parseImageFiltering } from '../../Filtering';











class ImageRendererV2 {
    constructor(options) {
        this.type = 'ex.image-v2';
        this.priority = 0;
        // TODO this could be bigger probably
        this._maxImages = 20000; // max(uint16) / 6 verts
        this._maxTextures = 0;
        this._components = 2 + 2 + 2 + 2 + 1 + 2 + 2 + 1 + 2 + 2 + 4;
        // Per flush vars
        this._imageCount = 0;
        this._textures = [];
        this._textureIndex = 0;
        this._textureToIndex = new Map();
        this._images = new Set();
        this._vertexIndex = 0;
        this._imageToWidth = new Map();
        this._imageToHeight = new Map();
        this._view = [0, 0, 0, 0];
        this._dest = [0, 0];
        this._defaultTint = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White;
        this.pixelArtSampler = options.pixelArtSampler;
        this.uvPadding = options.uvPadding;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // Transform shader source
        const maxTexture = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const maxComplexity = (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getMaxShaderComplexity)(gl, maxTexture);
        this._maxTextures = Math.min(maxTexture, maxComplexity);
        const transformedFrag = this._transformFragmentSource(_image_renderer_v2_frag_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], this._maxTextures);
        // Compile shader
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_3__.Shader({
            gl,
            fragmentSource: transformedFrag,
            vertexSource: _image_renderer_v2_vert_glsl__WEBPACK_IMPORTED_MODULE_4__["default"]
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        this._shader.setUniformIntArray('u_textures', [...Array(this._maxTextures)].map((_, i) => i));
        this._vao = gl.createVertexArray();
        gl.bindVertexArray(this._vao);
        this._quadMesh = new Float32Array([
            // pos       uv
            0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0,
            1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1
        ]);
        this._meshBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._meshBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._quadMesh, gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
        gl.enableVertexAttribArray(1);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        // Setup memory layout
        const components = this._components;
        this._transformData = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__.VertexBuffer({
            gl,
            size: components * this._maxImages, // components * images
            type: 'dynamic'
        });
        this._transformData.bind();
        // attributes
        let offset = 0;
        let start = 2;
        const bytesPerFloat = 4;
        const totalSize = components * 4;
        // a_offset vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(2);
        offset += 2 * bytesPerFloat;
        // a_mat_column1 vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(3);
        offset += 2 * bytesPerFloat;
        // a_mat_column2 vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(4);
        offset += 2 * bytesPerFloat;
        // a_mat_column3 vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(5);
        offset += 2 * bytesPerFloat;
        // a_opacity float - 1
        gl.vertexAttribPointer(start++, 1, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(6);
        offset += 1 * bytesPerFloat;
        // a_res vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(7);
        offset += 2 * bytesPerFloat;
        // a_size vec2 - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(8);
        offset += 2 * bytesPerFloat;
        // a_texture_index - 1
        gl.vertexAttribPointer(start++, 1, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(9);
        offset += 1 * bytesPerFloat;
        // a_uv_min - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(10);
        offset += 2 * bytesPerFloat;
        // a_uv_max - 2
        gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(11);
        offset += 2 * bytesPerFloat;
        // a_tint - 4
        gl.vertexAttribPointer(start++, 4, gl.FLOAT, false, totalSize, offset);
        gl.enableVertexAttribArray(12);
        offset += 4 * bytesPerFloat;
        gl.vertexAttribDivisor(2, 1);
        gl.vertexAttribDivisor(3, 1);
        gl.vertexAttribDivisor(4, 1);
        gl.vertexAttribDivisor(5, 1);
        gl.vertexAttribDivisor(6, 1);
        gl.vertexAttribDivisor(7, 1);
        gl.vertexAttribDivisor(8, 1);
        gl.vertexAttribDivisor(9, 1);
        gl.vertexAttribDivisor(10, 1);
        gl.vertexAttribDivisor(11, 1);
        gl.vertexAttribDivisor(12, 1);
        gl.bindVertexArray(null);
    }
    _bindData(gl) {
        // Setup memory layout
        const components = this._components;
        this._transformData.bind();
        this._transformData.upload(components * this._imageCount);
        gl.bindVertexArray(this._vao);
    }
    dispose() {
        this._transformData.dispose();
        this._shader.dispose();
        this._textures.length = 0;
        this._context = null;
        this._gl = null;
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_texture_index <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_texture_index <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture(u_textures[${i}], uv);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    _addImageAsTexture(image) {
        if (this._images.has(image)) {
            return;
        }
        const maybeFiltering = image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_6__.ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? (0,_Filtering__WEBPACK_IMPORTED_MODULE_7__.parseImageFiltering)(maybeFiltering) : undefined;
        const wrapX = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_8__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_6__.ImageSourceAttributeConstants.WrappingX));
        const wrapY = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_8__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_6__.ImageSourceAttributeConstants.WrappingY));
        const force = image.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._context.textureLoader.load(image, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        image.removeAttribute('forceUpload');
        if (this._textures.indexOf(texture) === -1) {
            this._textures.push(texture);
            this._textureToIndex.set(texture, this._textureIndex++);
            this._images.add(image);
        }
    }
    _bindTextures(gl) {
        // Bind textures in the correct order
        const max = Math.min(this._textureIndex, this._maxTextures);
        for (let i = 0; i < max; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
        }
    }
    _getTextureIdForImage(image) {
        var _a;
        if (image) {
            const maybeTexture = this._context.textureLoader.get(image);
            return (_a = this._textureToIndex.get(maybeTexture)) !== null && _a !== void 0 ? _a : -1; //this._textures.indexOf(maybeTexture);
        }
        return -1;
    }
    _isFull() {
        if (this._imageCount >= this._maxImages) {
            return true;
        }
        if (this._textures.length >= this._maxTextures) {
            return true;
        }
        return false;
    }
    _getImageWidth(image) {
        let maybeWidth = this._imageToWidth.get(image);
        if (maybeWidth === undefined) {
            maybeWidth = image.width;
            this._imageToWidth.set(image, maybeWidth);
        }
        return maybeWidth;
    }
    _getImageHeight(image) {
        let maybeHeight = this._imageToHeight.get(image);
        if (maybeHeight === undefined) {
            maybeHeight = image.height;
            this._imageToHeight.set(image, maybeHeight);
        }
        return maybeHeight;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        var _a, _b, _c, _d;
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._imageCount++;
        // This creates and uploads the texture if not already done
        this._addImageAsTexture(image);
        const maybeImageWidth = this._getImageWidth(image);
        const maybeImageHeight = this._getImageHeight(image);
        let width = maybeImageWidth || swidth || 0;
        let height = maybeImageHeight || sheight || 0;
        this._view[0] = 0;
        this._view[1] = 0;
        this._view[2] = (_a = swidth !== null && swidth !== void 0 ? swidth : maybeImageWidth) !== null && _a !== void 0 ? _a : 0;
        this._view[3] = (_b = sheight !== null && sheight !== void 0 ? sheight : maybeImageHeight) !== null && _b !== void 0 ? _b : 0;
        this._dest[0] = sx !== null && sx !== void 0 ? sx : 1;
        this._dest[1] = sy !== null && sy !== void 0 ? sy : 1;
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            this._view[0] = sx !== null && sx !== void 0 ? sx : 1;
            this._view[1] = sy !== null && sy !== void 0 ? sy : 1;
            this._view[2] = (_c = swidth !== null && swidth !== void 0 ? swidth : maybeImageWidth) !== null && _c !== void 0 ? _c : 0;
            this._view[3] = (_d = sheight !== null && sheight !== void 0 ? sheight : maybeImageHeight) !== null && _d !== void 0 ? _d : 0;
            this._dest[0] = dx;
            this._dest[1] = dy;
            width = dwidth;
            height = dheight;
        }
        sx = this._view[0];
        sy = this._view[1];
        const sw = this._view[2];
        const sh = this._view[3];
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        if (snapToPixel) {
            this._dest[0] = ~~(this._dest[0] + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_9__.pixelSnapEpsilon);
            this._dest[1] = ~~(this._dest[1] + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_9__.pixelSnapEpsilon);
        }
        const tint = this._context.tint || this._defaultTint;
        const textureId = this._getTextureIdForImage(image);
        const imageWidth = maybeImageWidth || width;
        const imageHeight = maybeImageHeight || height;
        const uvx0 = (sx + this.uvPadding) / imageWidth;
        const uvy0 = (sy + this.uvPadding) / imageHeight;
        const uvx1 = (sx + sw - this.uvPadding) / imageWidth;
        const uvy1 = (sy + sh - this.uvPadding) / imageHeight;
        const txWidth = maybeImageWidth;
        const txHeight = maybeImageHeight;
        // update data
        const vertexBuffer = this._transformData.bufferData;
        vertexBuffer[this._vertexIndex++] = this._dest[0];
        vertexBuffer[this._vertexIndex++] = this._dest[1];
        vertexBuffer[this._vertexIndex++] = transform.data[0];
        vertexBuffer[this._vertexIndex++] = transform.data[1];
        vertexBuffer[this._vertexIndex++] = transform.data[2];
        vertexBuffer[this._vertexIndex++] = transform.data[3];
        vertexBuffer[this._vertexIndex++] = transform.data[4];
        vertexBuffer[this._vertexIndex++] = transform.data[5];
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = txWidth;
        vertexBuffer[this._vertexIndex++] = txHeight;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
    }
    hasPendingDraws() {
        return this._imageCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._imageCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._bindData(gl);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Turn on pixel art aa sampler
        this._shader.setUniformBoolean('u_pixelart', this.pixelArtSampler);
        // Bind textures to
        this._bindTextures(gl);
        // Draw all the quads
        gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, this._imageCount);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_10__.GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_10__.GraphicsDiagnostics.DrawCallCount++;
        gl.bindVertexArray(null);
        // Reset
        this._imageCount = 0;
        this._vertexIndex = 0;
        this._textures.length = 0;
        this._textureIndex = 0;
        this._textureToIndex.clear();
        this._images.clear();
        this._imageToWidth.clear();
        this._imageToHeight.clear();
    }
}


/***/ }),

/***/ "./Graphics/Context/image-renderer/image-renderer.ts":
/*!***********************************************************!*\
  !*** ./Graphics/Context/image-renderer/image-renderer.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_903703__) => {

__nested_webpack_require_903703__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_903703__.d(__nested_webpack_exports__, {
/* harmony export */   ImageRenderer: () => (/* binding */ ImageRenderer)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_903703__(/*! ../../../Color */ "./Color.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_903703__(/*! ../../../Math/util */ "./Math/util.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_903703__(/*! ../../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_903703__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_903703__(/*! ../../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_903703__(/*! ../../Wrapping */ "./Graphics/Wrapping.ts");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_903703__(/*! ../ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _quad_index_buffer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_903703__(/*! ../quad-index-buffer */ "./Graphics/Context/quad-index-buffer.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_903703__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_903703__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_903703__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_903703__(/*! ../webgl-util */ "./Graphics/Context/webgl-util.ts");
/* harmony import */ var _image_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_903703__(/*! ./image-renderer.frag.glsl */ "./Graphics/Context/image-renderer/image-renderer.frag.glsl");
/* harmony import */ var _image_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_903703__(/*! ./image-renderer.vert.glsl */ "./Graphics/Context/image-renderer/image-renderer.vert.glsl");














class ImageRenderer {
    constructor(options) {
        this.type = 'ex.image';
        this.priority = 0;
        this._maxImages = 10922; // max(uint16) / 6 verts
        this._maxTextures = 0;
        // Per flush vars
        this._imageCount = 0;
        this._textures = [];
        this._textureIndex = 0;
        this._textureToIndex = new Map();
        this._images = new Set();
        this._vertexIndex = 0;
        this._imageToWidth = new Map();
        this._imageToHeight = new Map();
        this._view = [0, 0, 0, 0];
        this._dest = [0, 0];
        this._quad = [0, 0, 0, 0, 0, 0, 0, 0];
        this._defaultTint = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White;
        this.pixelArtSampler = options.pixelArtSampler;
        this.uvPadding = options.uvPadding;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // Transform shader source
        // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...
        const maxTexture = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const maxComplexity = (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getMaxShaderComplexity)(gl, maxTexture);
        this._maxTextures = Math.min(maxTexture, maxComplexity);
        const transformedFrag = this._transformFragmentSource(_image_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], this._maxTextures);
        // Compile shader
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_3__.Shader({
            gl,
            fragmentSource: transformedFrag,
            vertexSource: _image_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_4__["default"]
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        this._shader.setUniformIntArray('u_textures', [...Array(this._maxTextures)].map((_, i) => i));
        // Setup memory layout
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__.VertexBuffer({
            gl,
            size: 12 * 4 * this._maxImages, // 12 components * 4 verts
            type: 'dynamic'
        });
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_6__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_opacity', 1],
                ['a_res', 2],
                ['a_texcoord', 2],
                ['a_textureIndex', 1],
                ['a_tint', 4]
            ]
        });
        // Setup index buffer
        this._quads = new _quad_index_buffer__WEBPACK_IMPORTED_MODULE_7__.QuadIndexBuffer(gl, this._maxImages, true);
    }
    dispose() {
        this._buffer.dispose();
        this._quads.dispose();
        this._shader.dispose();
        this._textures.length = 0;
        this._context = null;
        this._gl = null;
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      vec2 uv = u_pixelart ? uv_iq(v_texcoord, v_res) : v_texcoord;\n`;
            texturePickerBuilder += `      color = texture(u_textures[${i}], uv);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    _addImageAsTexture(image) {
        if (this._images.has(image)) {
            return;
        }
        const maybeFiltering = image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_8__.ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? (0,_Filtering__WEBPACK_IMPORTED_MODULE_9__.parseImageFiltering)(maybeFiltering) : undefined;
        const wrapX = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_10__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_8__.ImageSourceAttributeConstants.WrappingX));
        const wrapY = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_10__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_8__.ImageSourceAttributeConstants.WrappingY));
        const force = image.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._context.textureLoader.load(image, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        image.removeAttribute('forceUpload');
        if (this._textures.indexOf(texture) === -1) {
            this._textures.push(texture);
            this._textureToIndex.set(texture, this._textureIndex++);
            this._images.add(image);
        }
    }
    _bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this._maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
        }
    }
    _getTextureIdForImage(image) {
        var _a;
        if (image) {
            const maybeTexture = this._context.textureLoader.get(image);
            return (_a = this._textureToIndex.get(maybeTexture)) !== null && _a !== void 0 ? _a : -1; //this._textures.indexOf(maybeTexture);
        }
        return -1;
    }
    _isFull() {
        if (this._imageCount >= this._maxImages) {
            return true;
        }
        if (this._textures.length >= this._maxTextures) {
            return true;
        }
        return false;
    }
    _getImageWidth(image) {
        let maybeWidth = this._imageToWidth.get(image);
        if (maybeWidth === undefined) {
            maybeWidth = image.width;
            this._imageToWidth.set(image, maybeWidth);
        }
        return maybeWidth;
    }
    _getImageHeight(image) {
        let maybeHeight = this._imageToHeight.get(image);
        if (maybeHeight === undefined) {
            maybeHeight = image.height;
            this._imageToHeight.set(image, maybeHeight);
        }
        return maybeHeight;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        var _a, _b, _c, _d;
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._imageCount++;
        // This creates and uploads the texture if not already done
        this._addImageAsTexture(image);
        const maybeImageWidth = this._getImageWidth(image);
        const maybeImageHeight = this._getImageHeight(image);
        let width = maybeImageWidth || swidth || 0;
        let height = maybeImageHeight || sheight || 0;
        this._view[0] = 0;
        this._view[1] = 0;
        this._view[2] = (_a = swidth !== null && swidth !== void 0 ? swidth : maybeImageWidth) !== null && _a !== void 0 ? _a : 0;
        this._view[3] = (_b = sheight !== null && sheight !== void 0 ? sheight : maybeImageHeight) !== null && _b !== void 0 ? _b : 0;
        this._dest[0] = sx !== null && sx !== void 0 ? sx : 1;
        this._dest[1] = sy !== null && sy !== void 0 ? sy : 1;
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            this._view[0] = sx !== null && sx !== void 0 ? sx : 1;
            this._view[1] = sy !== null && sy !== void 0 ? sy : 1;
            this._view[2] = (_c = swidth !== null && swidth !== void 0 ? swidth : maybeImageWidth) !== null && _c !== void 0 ? _c : 0;
            this._view[3] = (_d = sheight !== null && sheight !== void 0 ? sheight : maybeImageHeight) !== null && _d !== void 0 ? _d : 0;
            this._dest[0] = dx;
            this._dest[1] = dy;
            width = dwidth;
            height = dheight;
        }
        sx = this._view[0];
        sy = this._view[1];
        const sw = this._view[2];
        const sh = this._view[3];
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        // top left
        this._quad[0] = this._dest[0];
        this._quad[1] = this._dest[1];
        // top right
        this._quad[2] = this._dest[0] + width;
        this._quad[3] = this._dest[1];
        // bottom left
        this._quad[4] = this._dest[0];
        this._quad[5] = this._dest[1] + height;
        // bottom right
        this._quad[6] = this._dest[0] + width;
        this._quad[7] = this._dest[1] + height;
        transform.multiplyQuadInPlace(this._quad);
        if (snapToPixel) {
            this._quad[0] = ~~(this._quad[0] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[0]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[1] = ~~(this._quad[1] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[1]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[2] = ~~(this._quad[2] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[2]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[3] = ~~(this._quad[3] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[3]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[4] = ~~(this._quad[4] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[4]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[5] = ~~(this._quad[5] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[5]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[6] = ~~(this._quad[6] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[6]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
            this._quad[7] = ~~(this._quad[7] + (0,_Math_util__WEBPACK_IMPORTED_MODULE_11__.sign)(this._quad[7]) * _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_12__.pixelSnapEpsilon);
        }
        const tint = this._context.tint || this._defaultTint;
        const textureId = this._getTextureIdForImage(image);
        const imageWidth = maybeImageWidth || width;
        const imageHeight = maybeImageHeight || height;
        const uvx0 = (sx + this.uvPadding) / imageWidth;
        const uvy0 = (sy + this.uvPadding) / imageHeight;
        const uvx1 = (sx + sw - this.uvPadding) / imageWidth;
        const uvy1 = (sy + sh - this.uvPadding) / imageHeight;
        const txWidth = maybeImageWidth;
        const txHeight = maybeImageHeight;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = this._quad[0];
        vertexBuffer[this._vertexIndex++] = this._quad[1];
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = txWidth;
        vertexBuffer[this._vertexIndex++] = txHeight;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = this._quad[4];
        vertexBuffer[this._vertexIndex++] = this._quad[5];
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = txWidth;
        vertexBuffer[this._vertexIndex++] = txHeight;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = this._quad[2];
        vertexBuffer[this._vertexIndex++] = this._quad[3];
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = txWidth;
        vertexBuffer[this._vertexIndex++] = txHeight;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = this._quad[6];
        vertexBuffer[this._vertexIndex++] = this._quad[7];
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = txWidth;
        vertexBuffer[this._vertexIndex++] = txHeight;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
    }
    hasPendingDraws() {
        return this._imageCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._imageCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true, 4 * 12 * this._imageCount); // 4 verts * 12 components
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Turn on pixel art aa sampler
        this._shader.setUniformBoolean('u_pixelart', this.pixelArtSampler);
        // Bind textures to
        this._bindTextures(gl);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_13__.GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_13__.GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._imageCount = 0;
        this._vertexIndex = 0;
        this._textures.length = 0;
        this._textureIndex = 0;
        this._textureToIndex.clear();
        this._images.clear();
        this._imageToWidth.clear();
        this._imageToHeight.clear();
    }
}


/***/ }),

/***/ "./Graphics/Context/line-renderer/line-renderer.ts":
/*!*********************************************************!*\
  !*** ./Graphics/Context/line-renderer/line-renderer.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_921894__) => {

__nested_webpack_require_921894__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_921894__.d(__nested_webpack_exports__, {
/* harmony export */   LineRenderer: () => (/* binding */ LineRenderer)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_921894__(/*! ../../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _line_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_921894__(/*! ./line-vertex.glsl */ "./Graphics/Context/line-renderer/line-vertex.glsl");
/* harmony import */ var _line_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_921894__(/*! ./line-fragment.glsl */ "./Graphics/Context/line-renderer/line-fragment.glsl");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_921894__(/*! ../.. */ "./Graphics/Context/shader.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_921894__(/*! ../.. */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_921894__(/*! ../.. */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_921894__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");





class LineRenderer {
    constructor() {
        this.type = 'ex.line';
        this.priority = 0;
        this._maxLines = 10922;
        this._vertexIndex = 0;
        this._lineCount = 0;
        this._startScratch = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
        this._endScratch = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(0, 0);
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new ___WEBPACK_IMPORTED_MODULE_1__.Shader({
            gl,
            vertexSource: _line_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
            fragmentSource: _line_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"]
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._vertexBuffer = new ___WEBPACK_IMPORTED_MODULE_4__.VertexBuffer({
            gl,
            size: 6 * 2 * this._maxLines,
            type: 'dynamic'
        });
        this._layout = new ___WEBPACK_IMPORTED_MODULE_5__.VertexLayout({
            gl,
            vertexBuffer: this._vertexBuffer,
            shader: this._shader,
            attributes: [
                ['a_position', 2],
                ['a_color', 4]
            ]
        });
    }
    dispose() {
        this._vertexBuffer.dispose();
        this._shader.dispose();
        this._context = null;
        this._gl = null;
    }
    draw(start, end, color) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._lineCount++;
        const transform = this._context.getTransform();
        const finalStart = transform.multiply(start, this._startScratch);
        const finalEnd = transform.multiply(end, this._endScratch);
        const vertexBuffer = this._vertexBuffer.bufferData;
        // Start
        vertexBuffer[this._vertexIndex++] = finalStart.x;
        vertexBuffer[this._vertexIndex++] = finalStart.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        // End
        vertexBuffer[this._vertexIndex++] = finalEnd.x;
        vertexBuffer[this._vertexIndex++] = finalEnd.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
    }
    _isFull() {
        if (this._lineCount >= this._maxLines) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._lineCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._lineCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__.GraphicsDiagnostics.DrawnImagesCount += this._lineCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__.GraphicsDiagnostics.DrawCallCount++;
        // reset
        this._vertexIndex = 0;
        this._lineCount = 0;
    }
}


/***/ }),

/***/ "./Graphics/Context/material-renderer/material-renderer.ts":
/*!*****************************************************************!*\
  !*** ./Graphics/Context/material-renderer/material-renderer.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_926997__) => {

__nested_webpack_require_926997__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_926997__.d(__nested_webpack_exports__, {
/* harmony export */   MaterialRenderer: () => (/* binding */ MaterialRenderer)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_926997__(/*! ../../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_926997__(/*! ../../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_926997__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_926997__(/*! ../../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_926997__(/*! ../../Wrapping */ "./Graphics/Wrapping.ts");
/* harmony import */ var _quad_index_buffer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_926997__(/*! ../quad-index-buffer */ "./Graphics/Context/quad-index-buffer.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_926997__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_926997__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");








class MaterialRenderer {
    constructor() {
        this.type = 'ex.material';
        this.priority = 0;
        this._textures = [];
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // Setup memory layout
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer({
            gl,
            size: 6 * 4, // 6 components * 4 verts
            type: 'dynamic'
        });
        // Setup a vertex layout/buffer to the material
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_1__.VertexLayout({
            gl,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_screenuv', 2]
            ],
            suppressWarnings: true
        });
        // Setup index buffer
        this._quads = new _quad_index_buffer__WEBPACK_IMPORTED_MODULE_2__.QuadIndexBuffer(gl, 1, true);
    }
    dispose() {
        this._buffer.dispose();
        this._quads.dispose();
        this._textures.length = 0;
        this._context = null;
        this._gl = null;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        var _a, _b, _c, _d;
        const gl = this._gl;
        // Extract context info
        const material = this._context.material;
        if (!material) {
            return;
        }
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        // material shader
        const shader = material.getShader();
        // construct geometry, or hold on to it in the material?
        // geometry primitive for drawing rectangles?
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        let vertexIndex = 0;
        let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];
        let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];
            dest = [dx, dy];
            width = dwidth;
            height = dheight;
        }
        sx = view[0];
        sy = view[1];
        const sw = view[2];
        const sh = view[3];
        const topLeft = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(dest[0], dest[1]);
        const topRight = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(dest[0] + width, dest[1]);
        const bottomLeft = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(dest[0], dest[1] + height);
        const bottomRight = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(dest[0] + width, dest[1] + height);
        const imageWidth = image.width || width;
        const imageHeight = image.height || height;
        const uvx0 = sx / imageWidth;
        const uvy0 = sy / imageHeight;
        const uvx1 = (sx + sw - 0.01) / imageWidth;
        const uvy1 = (sy + sh - 0.01) / imageHeight;
        const topLeftScreen = transform.getPosition();
        const bottomRightScreen = topLeftScreen.add(bottomRight);
        const screenUVX0 = topLeftScreen.x / this._context.width;
        const screenUVY0 = topLeftScreen.y / this._context.height;
        const screenUVX1 = bottomRightScreen.x / this._context.width;
        const screenUVY1 = bottomRightScreen.y / this._context.height;
        // (0, 0) - 0
        vertexBuffer[vertexIndex++] = topLeft.x;
        vertexBuffer[vertexIndex++] = topLeft.y;
        vertexBuffer[vertexIndex++] = uvx0;
        vertexBuffer[vertexIndex++] = uvy0;
        vertexBuffer[vertexIndex++] = screenUVX0;
        vertexBuffer[vertexIndex++] = screenUVY0;
        // (0, 1) - 1
        vertexBuffer[vertexIndex++] = bottomLeft.x;
        vertexBuffer[vertexIndex++] = bottomLeft.y;
        vertexBuffer[vertexIndex++] = uvx0;
        vertexBuffer[vertexIndex++] = uvy1;
        vertexBuffer[vertexIndex++] = screenUVX0;
        vertexBuffer[vertexIndex++] = screenUVY1;
        // (1, 0) - 2
        vertexBuffer[vertexIndex++] = topRight.x;
        vertexBuffer[vertexIndex++] = topRight.y;
        vertexBuffer[vertexIndex++] = uvx1;
        vertexBuffer[vertexIndex++] = uvy0;
        vertexBuffer[vertexIndex++] = screenUVX1;
        vertexBuffer[vertexIndex++] = screenUVY0;
        // (1, 1) - 3
        vertexBuffer[vertexIndex++] = bottomRight.x;
        vertexBuffer[vertexIndex++] = bottomRight.y;
        vertexBuffer[vertexIndex++] = uvx1;
        vertexBuffer[vertexIndex++] = uvy1;
        vertexBuffer[vertexIndex++] = screenUVX1;
        vertexBuffer[vertexIndex++] = screenUVY1;
        // This creates and uploads the texture if not already done
        const texture = this._addImageAsTexture(image);
        // apply material
        material.use();
        this._layout.shader = shader;
        // apply layout and geometry
        this._layout.use(true);
        // apply time in ms since the page (performance.now())
        shader.trySetUniformFloat('u_time_ms', performance.now());
        // apply opacity
        shader.trySetUniformFloat('u_opacity', opacity);
        // apply resolution
        shader.trySetUniformFloatVector('u_resolution', (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this._context.width, this._context.height));
        // apply graphic resolution
        shader.trySetUniformFloatVector('u_graphic_resolution', (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(imageWidth, imageHeight));
        // apply size
        shader.trySetUniformFloatVector('u_size', (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(sw, sh));
        // apply orthographic projection
        shader.trySetUniformMatrix('u_matrix', this._context.ortho);
        // apply geometry transform
        shader.trySetUniformMatrix('u_transform', transform.to4x4());
        // bind graphic image texture 'uniform sampler2D u_graphic;'
        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        shader.trySetUniformInt('u_graphic', 0);
        // bind the screen texture
        gl.activeTexture(gl.TEXTURE0 + 1);
        gl.bindTexture(gl.TEXTURE_2D, this._context.materialScreenTexture);
        shader.trySetUniformInt('u_screen_texture', 1);
        // bind any additional textures in the material
        material.uploadAndBind(gl);
        // bind quad index buffer
        this._quads.bind();
        // Draw a single quad
        gl.drawElements(gl.TRIANGLES, 6, this._quads.bufferGlType, 0);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_4__.GraphicsDiagnostics.DrawnImagesCount++;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_4__.GraphicsDiagnostics.DrawCallCount++;
    }
    _addImageAsTexture(image) {
        const maybeFiltering = image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_5__.ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? (0,_Filtering__WEBPACK_IMPORTED_MODULE_6__.parseImageFiltering)(maybeFiltering) : undefined;
        const wrapX = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_7__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_5__.ImageSourceAttributeConstants.WrappingX));
        const wrapY = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_7__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_5__.ImageSourceAttributeConstants.WrappingY));
        const force = image.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._context.textureLoader.load(image, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        image.removeAttribute('forceUpload');
        if (this._textures.indexOf(texture) === -1) {
            this._textures.push(texture);
        }
        return texture;
    }
    hasPendingDraws() {
        return false;
    }
    flush() {
        // flush does not do anything, material renderer renders immediately per draw
    }
}


/***/ }),

/***/ "./Graphics/Context/material.ts":
/*!**************************************!*\
  !*** ./Graphics/Context/material.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_937606__) => {

__nested_webpack_require_937606__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_937606__.d(__nested_webpack_exports__, {
/* harmony export */   Material: () => (/* binding */ Material)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_937606__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_937606__(/*! ./ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_937606__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_937606__(/*! ../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_937606__(/*! ../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_937606__(/*! ../Wrapping */ "./Graphics/Wrapping.ts");






const defaultVertexSource = `#version 300 es
in vec2 a_position;

in vec2 a_uv;
out vec2 v_uv;

in vec2 a_screenuv;
out vec2 v_screenuv;

uniform mat4 u_matrix;
uniform mat4 u_transform;

void main() {
  // Set the vertex position using the ortho & transform matrix
  gl_Position = u_matrix * u_transform * vec4(a_position, 0.0, 1.0);

  // Pass through the UV coord to the fragment shader
  v_uv = a_uv;
  v_screenuv = a_screenuv;
}
`;
class Material {
    constructor(options) {
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this._color = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Transparent;
        this._initialized = false;
        this._images = new Map();
        this._textures = new Map();
        const { color, name, vertexSource, fragmentSource, graphicsContext, images } = options;
        this._name = name !== null && name !== void 0 ? name : 'anonymous material';
        this._vertexSource = vertexSource !== null && vertexSource !== void 0 ? vertexSource : defaultVertexSource;
        this._fragmentSource = fragmentSource;
        this._color = color !== null && color !== void 0 ? color : this._color;
        if (!graphicsContext) {
            throw Error(`Material ${name} must be provided an excalibur webgl graphics context`);
        }
        if (graphicsContext instanceof _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_2__.ExcaliburGraphicsContextWebGL) {
            this._graphicsContext = graphicsContext;
            this._initialize(graphicsContext);
        }
        else {
            this._logger.warn(`Material ${name} was created in 2D Canvas mode, currently only WebGL is supported`);
        }
        if (images) {
            for (const key in images) {
                this.addImageSource(key, images[key]);
            }
        }
    }
    _initialize(graphicsContextWebGL) {
        if (this._initialized) {
            return;
        }
        const gl = graphicsContextWebGL.__gl;
        // max texture slots - 2 for the graphic texture and screen texture
        this._maxTextureSlots = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS) - 2;
        this._shader = graphicsContextWebGL.createShader({
            vertexSource: this._vertexSource,
            fragmentSource: this._fragmentSource
        });
        this._shader.compile();
        this._initialized = true;
    }
    get color() {
        return this._color;
    }
    set color(c) {
        this._color = c;
    }
    get name() {
        var _a;
        return (_a = this._name) !== null && _a !== void 0 ? _a : 'anonymous material';
    }
    get isUsingScreenTexture() {
        return this._fragmentSource.includes('u_screen_texture');
    }
    update(callback) {
        if (this._shader) {
            this._shader.use();
            callback(this._shader);
        }
    }
    getShader() {
        return this._shader;
    }
    addImageSource(textureUniformName, image) {
        if (this._images.size < this._maxTextureSlots) {
            this._images.set(textureUniformName, image);
        }
        else {
            this._logger.warn(`Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", ` +
                `no more textures will be uploaded due to hardware constraints.`);
        }
    }
    removeImageSource(textureName) {
        const image = this._images.get(textureName);
        this._graphicsContext.textureLoader.delete(image.image);
        this._images.delete(textureName);
    }
    _loadImageSource(image) {
        const imageElement = image.image;
        const maybeFiltering = imageElement.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? (0,_Filtering__WEBPACK_IMPORTED_MODULE_4__.parseImageFiltering)(maybeFiltering) : undefined;
        const wrapX = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_5__.parseImageWrapping)(imageElement.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.WrappingX));
        const wrapY = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_5__.parseImageWrapping)(imageElement.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.WrappingY));
        const force = imageElement.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._graphicsContext.textureLoader.load(imageElement, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        imageElement.removeAttribute('forceUpload');
        if (!this._textures.has(image)) {
            this._textures.set(image, texture);
        }
        return texture;
    }
    uploadAndBind(gl, startingTextureSlot = 2) {
        let textureSlot = startingTextureSlot;
        for (const [textureName, image] of this._images.entries()) {
            if (!image.isLoaded()) {
                this._logger.warnOnce(`Image named ${textureName} in material ${this.name} not loaded, nothing will be uploaded to the shader.` +
                    ` Did you forget to add this to a loader? https://excaliburjs.com/docs/loaders/`);
                continue;
            } // skip unloaded images, maybe warn
            const texture = this._loadImageSource(image);
            gl.activeTexture(gl.TEXTURE0 + textureSlot);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            this._shader.trySetUniformInt(textureName, textureSlot);
            textureSlot++;
        }
    }
    use() {
        if (this._initialized) {
            // bind the shader
            this._shader.use();
            // Apply standard uniforms
            this._shader.trySetUniformFloatColor('u_color', this._color);
        }
        else {
            throw Error(`Material ${this.name} not yet initialized, use the ExcaliburGraphicsContext.createMaterial() to work around this.`);
        }
    }
}


/***/ }),

/***/ "./Graphics/Context/particle-renderer/particle-renderer.ts":
/*!*****************************************************************!*\
  !*** ./Graphics/Context/particle-renderer/particle-renderer.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_945024__) => {

__nested_webpack_require_945024__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_945024__.d(__nested_webpack_exports__, {
/* harmony export */   ParticleRenderer: () => (/* binding */ ParticleRenderer)
/* harmony export */ });
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_945024__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _particle_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_945024__(/*! ./particle-vertex.glsl */ "./Graphics/Context/particle-renderer/particle-vertex.glsl");
/* harmony import */ var _particle_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_945024__(/*! ./particle-fragment.glsl */ "./Graphics/Context/particle-renderer/particle-fragment.glsl");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_945024__(/*! ../../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_945024__(/*! ../../../Color */ "./Color.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_945024__(/*! ../../ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_945024__(/*! ../../Wrapping */ "./Graphics/Wrapping.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_945024__(/*! ../../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Particles_Particles__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_945024__(/*! ../../../Particles/Particles */ "./Particles/Particles.ts");









class ParticleRenderer {
    constructor() {
        this.type = 'ex.particle';
        this.priority = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_0__.Shader({
            gl,
            vertexSource: _particle_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
            fragmentSource: _particle_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
            onPreLink: (program) => {
                gl.transformFeedbackVaryings(program, ['finalPosition', 'finalVelocity', 'finalRotation', 'finalAngularVelocity', 'finalLifeMs'], gl.INTERLEAVED_ATTRIBS);
            }
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
    }
    _getTexture(image) {
        const maybeFiltering = image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.Filtering);
        const filtering = maybeFiltering ? (0,_Filtering__WEBPACK_IMPORTED_MODULE_4__.parseImageFiltering)(maybeFiltering) : undefined;
        const wrapX = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_5__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.WrappingX));
        const wrapY = (0,_Wrapping__WEBPACK_IMPORTED_MODULE_5__.parseImageWrapping)(image.getAttribute(_ImageSource__WEBPACK_IMPORTED_MODULE_3__.ImageSourceAttributeConstants.WrappingY));
        const force = image.getAttribute('forceUpload') === 'true' ? true : false;
        const texture = this._context.textureLoader.load(image, {
            filtering,
            wrapping: { x: wrapX, y: wrapY }
        }, force);
        // remove force attribute after upload
        image.removeAttribute('forceUpload');
        return texture;
    }
    draw(renderer, elapsed) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const gl = this._gl;
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        const transform = renderer.particle.transform === _Particles_Particles__WEBPACK_IMPORTED_MODULE_6__.ParticleTransform.Local
            ? this._context.getTransform()
            : this._context.getTransform().multiply(renderer.emitter.transform.get().inverse);
        this._shader.setUniformAffineMatrix('u_transform', transform);
        this._shader.setUniformBoolean('fade', renderer.particle.fade ? true : false);
        this._shader.setUniformBoolean('useTexture', renderer.particle.graphic ? true : false);
        this._shader.setUniformFloat('maxLifeMs', (_a = renderer.particle.life) !== null && _a !== void 0 ? _a : 2000);
        this._shader.setUniformFloat('deltaMs', elapsed);
        this._shader.setUniformFloatVector('gravity', (_b = renderer.particle.acc) !== null && _b !== void 0 ? _b : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_7__.vec)(0, 0));
        this._shader.setUniformFloatColor('beginColor', (_c = renderer.particle.beginColor) !== null && _c !== void 0 ? _c : _Color__WEBPACK_IMPORTED_MODULE_8__.Color.Transparent);
        this._shader.setUniformFloatColor('endColor', (_d = renderer.particle.endColor) !== null && _d !== void 0 ? _d : _Color__WEBPACK_IMPORTED_MODULE_8__.Color.Transparent);
        let startSize = (_e = renderer.particle.startSize) !== null && _e !== void 0 ? _e : 0;
        let endSize = (_f = renderer.particle.endSize) !== null && _f !== void 0 ? _f : 0;
        const size = (_g = renderer.particle.size) !== null && _g !== void 0 ? _g : 0;
        if (size > 0) {
            startSize = size;
            endSize = size;
        }
        this._shader.setUniformFloat('startSize', startSize !== null && startSize !== void 0 ? startSize : 10);
        this._shader.setUniformFloat('endSize', endSize !== null && endSize !== void 0 ? endSize : 10);
        this._shader.setUniformFloat('startOpacity', (_h = renderer.particle.opacity) !== null && _h !== void 0 ? _h : 1);
        if (renderer.particle.focus) {
            this._shader.setUniformFloatVector('focus', renderer.particle.focus);
            this._shader.setUniformFloat('focusAccel', (_j = renderer.particle.focusAccel) !== null && _j !== void 0 ? _j : 0);
        }
        // Particle Graphic (only Sprites right now)
        if (renderer.particle.graphic) {
            const graphic = renderer.particle.graphic;
            const texture = this._getTexture(graphic.image.image);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            this._shader.setUniformInt('graphic', 0);
        }
        // Collision Mask
        // gl.activeTexture(gl.TEXTURE0 + 1);
        // gl.bindTexture(gl.TEXTURE_2D, obstacleTex);
        // gl.uniform1i(u_obstacle, 1);
        renderer.draw(gl);
    }
    hasPendingDraws() {
        return false;
    }
    flush() {
        // pass
    }
    dispose() {
        // pass
    }
}


/***/ }),

/***/ "./Graphics/Context/point-renderer/point-renderer.ts":
/*!***********************************************************!*\
  !*** ./Graphics/Context/point-renderer/point-renderer.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_951934__) => {

__nested_webpack_require_951934__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_951934__.d(__nested_webpack_exports__, {
/* harmony export */   PointRenderer: () => (/* binding */ PointRenderer)
/* harmony export */ });
/* harmony import */ var _point_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_951934__(/*! ./point-vertex.glsl */ "./Graphics/Context/point-renderer/point-vertex.glsl");
/* harmony import */ var _point_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_951934__(/*! ./point-fragment.glsl */ "./Graphics/Context/point-renderer/point-fragment.glsl");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_951934__(/*! ../ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_951934__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_951934__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_951934__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_951934__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");







class PointRenderer {
    constructor() {
        this.type = 'ex.point';
        this.priority = 0;
        this._maxPoints = 10922;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_0__.Shader({
            gl,
            vertexSource: _point_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
            fragmentSource: _point_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__["default"]
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__.VertexBuffer({
            gl,
            size: 7 * this._maxPoints,
            type: 'dynamic'
        });
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_4__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_color', 4],
                ['a_size', 1]
            ]
        });
    }
    dispose() {
        this._buffer.dispose();
        this._shader.dispose();
        this._context = null;
        this._gl = null;
    }
    draw(point, color, size) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._pointCount++;
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const finalPoint = transform.multiply(point);
        if (snapToPixel) {
            finalPoint.x = ~~(finalPoint.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_5__.pixelSnapEpsilon);
            finalPoint.y = ~~(finalPoint.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_5__.pixelSnapEpsilon);
        }
        const vertexBuffer = this._buffer.bufferData;
        vertexBuffer[this._vertexIndex++] = finalPoint.x;
        vertexBuffer[this._vertexIndex++] = finalPoint.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a * opacity;
        vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());
    }
    _isFull() {
        if (this._pointCount >= this._maxPoints) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._pointCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._pointCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.POINTS, 0, this._pointCount);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__.GraphicsDiagnostics.DrawnImagesCount += this._pointCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_6__.GraphicsDiagnostics.DrawCallCount++;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
}


/***/ }),

/***/ "./Graphics/Context/quad-index-buffer.ts":
/*!***********************************************!*\
  !*** ./Graphics/Context/quad-index-buffer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_956983__) => {

__nested_webpack_require_956983__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_956983__.d(__nested_webpack_exports__, {
/* harmony export */   QuadIndexBuffer: () => (/* binding */ QuadIndexBuffer)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_956983__(/*! ../.. */ "./Util/Log.ts");

/**
 * Helper that defines and index buffer for quad geometry
 *
 * Index buffers allow you to save space in vertex buffers when you share vertices in geometry
 * it is almost always worth it in terms of performance to use an index buffer.
 */
class QuadIndexBuffer {
    /**
     * @param gl WebGL2RenderingContext this layout will be attached to, these cannot be reused across contexts.
     * @param numberOfQuads Specify the max number of quads you want to draw
     * @param useUint16 Optionally force a uint16 buffer
     */
    constructor(gl, numberOfQuads, useUint16) {
        this._logger = ___WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this._gl = gl;
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        const totalVertices = numberOfQuads * 6;
        if (!useUint16) {
            this.bufferData = new Uint32Array(totalVertices);
        }
        else {
            // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck
            const maxUint16 = 65535;
            const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads
            this.bufferGlType = gl.UNSIGNED_SHORT;
            this.bufferData = new Uint16Array(totalVertices);
            // TODO Should we error if this happens?? maybe not might crash mid game
            if (numberOfQuads > maxUint16Index) {
                this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);
            }
        }
        let currentQuad = 0;
        for (let i = 0; i < totalVertices; i += 6) {
            // first triangle
            this.bufferData[i + 0] = currentQuad + 0;
            this.bufferData[i + 1] = currentQuad + 1;
            this.bufferData[i + 2] = currentQuad + 2;
            // second triangle
            this.bufferData[i + 3] = currentQuad + 2;
            this.bufferData[i + 4] = currentQuad + 1;
            this.bufferData[i + 5] = currentQuad + 3;
            currentQuad += 4;
        }
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    get size() {
        return this.bufferData.length;
    }
    /**
     * Upload data to the GPU
     */
    upload() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    /**
     * Bind this index buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
    }
    dispose() {
        const gl = this._gl;
        gl.deleteBuffer(this.buffer);
        this._gl = null;
    }
}


/***/ }),

/***/ "./Graphics/Context/rectangle-renderer/rectangle-renderer.ts":
/*!*******************************************************************!*\
  !*** ./Graphics/Context/rectangle-renderer/rectangle-renderer.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_960427__) => {

__nested_webpack_require_960427__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_960427__.d(__nested_webpack_exports__, {
/* harmony export */   RectangleRenderer: () => (/* binding */ RectangleRenderer)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_960427__(/*! ../../../Color */ "./Color.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_960427__(/*! ../../../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_960427__(/*! ../../GraphicsDiagnostics */ "./Graphics/GraphicsDiagnostics.ts");
/* harmony import */ var _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_960427__(/*! ../ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _quad_index_buffer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_960427__(/*! ../quad-index-buffer */ "./Graphics/Context/quad-index-buffer.ts");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_960427__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_960427__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_960427__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _rectangle_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_960427__(/*! ./rectangle-renderer.frag.glsl */ "./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl");
/* harmony import */ var _rectangle_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_960427__(/*! ./rectangle-renderer.vert.glsl */ "./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl");










class RectangleRenderer {
    constructor() {
        this.type = 'ex.rectangle';
        this.priority = 0;
        this._maxRectangles = 10922; // max(uint16) / 6 verts
        this._rectangleCount = 0;
        this._vertexIndex = 0;
        this._transparent = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Transparent;
        this._scratch1 = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._scratch2 = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._scratch3 = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._scratch4 = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_2__.Shader({
            gl,
            fragmentSource: _rectangle_renderer_frag_glsl__WEBPACK_IMPORTED_MODULE_3__["default"],
            vertexSource: _rectangle_renderer_vert_glsl__WEBPACK_IMPORTED_MODULE_4__["default"]
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_5__.VertexBuffer({
            gl,
            size: 16 * 4 * this._maxRectangles,
            type: 'dynamic'
        });
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_6__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_size', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new _quad_index_buffer__WEBPACK_IMPORTED_MODULE_7__.QuadIndexBuffer(gl, this._maxRectangles, true);
    }
    dispose() {
        this._buffer.dispose();
        this._quads.dispose();
        this._shader.dispose();
        this._context = null;
        this._gl = null;
    }
    _isFull() {
        if (this._rectangleCount >= this._maxRectangles) {
            return true;
        }
        return false;
    }
    draw(...args) {
        if (args[0] instanceof _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector && args[1] instanceof _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector) {
            this.drawLine.apply(this, args);
        }
        else {
            this.drawRectangle.apply(this, args);
        }
    }
    drawLine(start, end, color, thickness = 1) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const dir = end.sub(start);
        const length = dir.magnitude;
        const normal = dir.normalize().perpendicular();
        const halfThick = thickness / 2;
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startX, startY)------------------>(endX, endY)
         *    |                                            |
         *    + -------------------------------------------+
         */
        const startTop = transform.multiply(normal.scale(halfThick, this._scratch1).add(start, this._scratch1), this._scratch1);
        const startBottom = transform.multiply(normal.scale(-halfThick, this._scratch2).add(start, this._scratch2), this._scratch2);
        const endTop = transform.multiply(normal.scale(halfThick, this._scratch3).add(end, this._scratch3), this._scratch3);
        const endBottom = transform.multiply(normal.scale(-halfThick, this._scratch4).add(end, this._scratch4), this._scratch4);
        if (snapToPixel) {
            startTop.x = ~~(startTop.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            startTop.y = ~~(startTop.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            endTop.x = ~~(endTop.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            endTop.y = ~~(endTop.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            startBottom.x = ~~(startBottom.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            startBottom.y = ~~(startBottom.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            endBottom.x = ~~(endBottom.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            endBottom.y = ~~(endBottom.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        const stroke = this._transparent;
        const strokeThickness = 0;
        const width = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = startTop.x;
        vertexBuffer[this._vertexIndex++] = startTop.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = startBottom.x;
        vertexBuffer[this._vertexIndex++] = startBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = endTop.x;
        vertexBuffer[this._vertexIndex++] = endTop.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = endBottom.x;
        vertexBuffer[this._vertexIndex++] = endBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    }
    drawRectangle(pos, width, height, color, stroke = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0)));
        const topRight = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(width, 0)));
        const bottomRight = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(width, height)));
        const bottomLeft = transform.multiply(pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, height)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + _ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_8__.pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
    }
    hasPendingDraws() {
        return this._rectangleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._rectangleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__.GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;
        _GraphicsDiagnostics__WEBPACK_IMPORTED_MODULE_9__.GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._rectangleCount = 0;
        this._vertexIndex = 0;
    }
}


/***/ }),

/***/ "./Graphics/Context/render-source.ts":
/*!*******************************************!*\
  !*** ./Graphics/Context/render-source.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_978511__) => {

__nested_webpack_require_978511__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_978511__.d(__nested_webpack_exports__, {
/* harmony export */   RenderSource: () => (/* binding */ RenderSource)
/* harmony export */ });
class RenderSource {
    constructor(_gl, _texture) {
        this._gl = _gl;
        this._texture = _texture;
    }
    use() {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
    }
    disable() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}


/***/ }),

/***/ "./Graphics/Context/render-target.ts":
/*!*******************************************!*\
  !*** ./Graphics/Context/render-target.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_979359__) => {

__nested_webpack_require_979359__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_979359__.d(__nested_webpack_exports__, {
/* harmony export */   RenderTarget: () => (/* binding */ RenderTarget)
/* harmony export */ });
/* harmony import */ var _render_source__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_979359__(/*! ./render-source */ "./Graphics/Context/render-source.ts");

class RenderTarget {
    constructor(options) {
        var _a, _b;
        this.antialias = false;
        this.samples = 1;
        this._gl = options.gl;
        this.width = options.width;
        this.height = options.height;
        this.transparency = options.transparency;
        this.antialias = (_a = options.antialias) !== null && _a !== void 0 ? _a : this.antialias;
        this.samples = (_b = options.samples) !== null && _b !== void 0 ? _b : this._gl.getParameter(this._gl.MAX_SAMPLES);
        const gl = this._gl;
        // Determine current context format for blitting later needs to match
        if (gl.drawingBufferFormat) {
            this.bufferFormat = gl.drawingBufferFormat;
        }
        else {
            // Documented in webgl spec
            // https://registry.khronos.org/webgl/specs/latest/1.0/
            if (this.transparency) {
                this.bufferFormat = gl.RGBA8;
            }
            else {
                this.bufferFormat = gl.RGB8;
            }
        }
        this._setupRenderBuffer();
        this._setupFramebuffer();
    }
    setResolution(width, height) {
        const gl = this._gl;
        this.width = width;
        this.height = height;
        // update backing texture size
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // update render buffer size
        if (this._renderBuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.min(this.samples, gl.getParameter(gl.MAX_SAMPLES)), this.bufferFormat, this.width, this.height);
        }
    }
    get renderBuffer() {
        return this._renderBuffer;
    }
    get renderFrameBuffer() {
        return this._renderFrameBuffer;
    }
    get frameBuffer() {
        return this._frameBuffer;
    }
    get frameTexture() {
        return this._frameTexture;
    }
    _setupRenderBuffer() {
        if (this.antialias) {
            const gl = this._gl;
            // Render buffers can be used as an input to a shader
            this._renderBuffer = gl.createRenderbuffer();
            this._renderFrameBuffer = gl.createFramebuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.min(this.samples, gl.getParameter(gl.MAX_SAMPLES)), this.bufferFormat, this.width, this.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderFrameBuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._renderBuffer);
        }
    }
    _setupFramebuffer() {
        // Allocates frame buffer
        const gl = this._gl;
        this._frameTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // set the filtering so we don't need mips
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // attach the texture as the first color attachment
        const attachmentPoint = gl.COLOR_ATTACHMENT0;
        // After this bind all draw calls will draw to this framebuffer texture
        this._frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);
        // Reset after initialized
        this.disable();
    }
    toRenderSource() {
        if (this.renderBuffer) {
            this.blitRenderBufferToFrameBuffer();
        }
        const source = new _render_source__WEBPACK_IMPORTED_MODULE_0__.RenderSource(this._gl, this._frameTexture);
        return source;
    }
    blitToScreen() {
        const gl = this._gl;
        // set to size of canvas's drawingBuffer
        if (this._renderBuffer) {
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.renderFrameBuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 1.0, 1.0]);
            gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
        }
        else {
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 1.0, 1.0]);
            gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
        }
    }
    blitRenderBufferToFrameBuffer() {
        if (this._renderBuffer) {
            const gl = this._gl;
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.renderFrameBuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
            gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 1.0, 1.0]);
            gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
        }
    }
    copyToTexture(texture) {
        const gl = this._gl;
        if (this._renderBuffer) {
            this.blitRenderBufferToFrameBuffer();
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, this.width, this.height, 0);
    }
    /**
     * When called, all drawing gets redirected to this render target
     */
    use() {
        const gl = this._gl;
        if (this.antialias) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderFrameBuffer);
        }
        else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        }
        // very important to set the viewport to the size of the framebuffer texture
        gl.viewport(0, 0, this.width, this.height);
    }
    /**
     * When called, all drawing is sent back to the canvas
     */
    disable() {
        const gl = this._gl;
        // passing null switches rendering back to the canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}


/***/ }),

/***/ "./Graphics/Context/screen-pass-painter/screen-pass-painter.ts":
/*!*********************************************************************!*\
  !*** ./Graphics/Context/screen-pass-painter/screen-pass-painter.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_986652__) => {

__nested_webpack_require_986652__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_986652__.d(__nested_webpack_exports__, {
/* harmony export */   ScreenPassPainter: () => (/* binding */ ScreenPassPainter)
/* harmony export */ });
/* harmony import */ var _screen_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_986652__(/*! ./screen-vertex.glsl */ "./Graphics/Context/screen-pass-painter/screen-vertex.glsl");
/* harmony import */ var _screen_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_986652__(/*! ./screen-fragment.glsl */ "./Graphics/Context/screen-pass-painter/screen-fragment.glsl");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_986652__(/*! ../shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_986652__(/*! ../vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _vertex_layout__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_986652__(/*! ../vertex-layout */ "./Graphics/Context/vertex-layout.ts");





/**
 * This is responsible for painting the entire screen during the render passes
 */
class ScreenPassPainter {
    constructor(gl) {
        this._gl = gl;
        this._shader = new _shader__WEBPACK_IMPORTED_MODULE_0__.Shader({
            gl,
            vertexSource: _screen_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
            fragmentSource: _screen_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__["default"]
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__.VertexBuffer({
            gl,
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0, -1, 1, 0, 1, 1, -1, 1, 0,
                1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1
            ])
        });
        this._layout = new _vertex_layout__WEBPACK_IMPORTED_MODULE_4__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_texcoord', 2]
            ]
        });
        this._buffer.upload();
    }
    renderWithPostProcessor(postprocessor) {
        const gl = this._gl;
        postprocessor.getShader().use();
        postprocessor.getLayout().use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    renderToScreen() {
        const gl = this._gl;
        this._shader.use();
        this._layout.use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
}


/***/ }),

/***/ "./Graphics/Context/shader.ts":
/*!************************************!*\
  !*** ./Graphics/Context/shader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_989518__) => {

__nested_webpack_require_989518__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_989518__.d(__nested_webpack_exports__, {
/* harmony export */   Shader: () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_989518__(/*! ../.. */ "./Util/Log.ts");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_989518__(/*! ./webgl-util */ "./Graphics/Context/webgl-util.ts");


class Shader {
    get compiled() {
        return this._compiled;
    }
    /**
     * Create a shader program in excalibur
     * @param options specify shader vertex and fragment source
     */
    constructor(options) {
        this._logger = ___WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this.uniforms = {};
        this.attributes = {};
        this._compiled = false;
        const { gl, vertexSource, fragmentSource, onPreLink, onPostCompile } = options;
        this._gl = gl;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
        this._onPreLink = onPreLink;
        this._onPostCompile = onPostCompile;
    }
    dispose() {
        const gl = this._gl;
        gl.deleteProgram(this.program);
        this._gl = null;
    }
    /**
     * Binds the shader program
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        Shader._ACTIVE_SHADER_INSTANCE = this;
    }
    isCurrentlyBound() {
        return Shader._ACTIVE_SHADER_INSTANCE === this;
    }
    /**
     * Compile the current shader against a webgl context
     */
    compile() {
        const gl = this._gl;
        const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);
        this.program = this._createProgram(gl, vertexShader, fragmentShader);
        const attributes = this.getAttributes();
        for (const attribute of attributes) {
            this.attributes[attribute.name] = attribute;
        }
        const uniforms = this.getUniforms();
        for (const uniform of uniforms) {
            this.uniforms[uniform.name] = uniform;
        }
        this._compiled = true;
        if (this._onPostCompile) {
            this._onPostCompile(this);
        }
        return this.program;
    }
    getUniforms() {
        const gl = this._gl;
        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        const uniforms = [];
        for (let i = 0; i < uniformCount; i++) {
            const uniform = gl.getActiveUniform(this.program, i);
            const uniformLocation = gl.getUniformLocation(this.program, uniform.name);
            uniforms.push({
                name: uniform.name,
                glType: uniform.type,
                location: uniformLocation
            });
        }
        return uniforms;
    }
    getAttributes() {
        const gl = this._gl;
        const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
        const attributes = [];
        for (let i = 0; i < attributeCount; i++) {
            const attribute = gl.getActiveAttrib(this.program, i);
            const attributeLocation = gl.getAttribLocation(this.program, attribute.name);
            attributes.push({
                name: attribute.name,
                glType: (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getAttributePointerType)(gl, attribute.type),
                size: (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getAttributeComponentSize)(gl, attribute.type),
                location: attributeLocation,
                normalized: false
            });
        }
        return attributes;
    }
    /**
     * Set a texture in a gpu texture slot
     * @param slotNumber
     * @param texture
     */
    setTexture(slotNumber, texture) {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0 + slotNumber);
        gl.bindTexture(gl.TEXTURE_2D, texture);
    }
    /**
     * Set an integer uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformInt(name, value) {
        this.setUniform('uniform1i', name, ~~value);
    }
    /**
     * Set an integer uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformInt(name, value) {
        return this.trySetUniform('uniform1i', name, ~~value);
    }
    /**
     * Set an integer array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformIntArray(name, value) {
        this.setUniform('uniform1iv', name, value);
    }
    /**
     * Set an integer array uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformIntArray(name, value) {
        return this.trySetUniform('uniform1iv', name, value);
    }
    /**
     * Set a boolean uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformBoolean(name, value) {
        this.setUniform('uniform1i', name, value ? 1 : 0);
    }
    /**
     * Set a boolean uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformBoolean(name, value) {
        return this.trySetUniform('uniform1i', name, value ? 1 : 0);
    }
    /**
     * Set a float uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformFloat(name, value) {
        this.setUniform('uniform1f', name, value);
    }
    /**
     * Set a float uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformFloat(name, value) {
        return this.trySetUniform('uniform1f', name, value);
    }
    /**
     * Set a float array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformFloatArray(name, value) {
        this.setUniform('uniform1fv', name, value);
    }
    /**
     * Set a float array uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformFloatArray(name, value) {
        return this.trySetUniform('uniform1fv', name, value);
    }
    /**
     * Set a {@apilink Vector} uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformFloatVector(name, value) {
        this.setUniform('uniform2f', name, value.x, value.y);
    }
    /**
     * Set a {@apilink Vector} uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformFloatVector(name, value) {
        return this.trySetUniform('uniform2f', name, value.x, value.y);
    }
    /**
     * Set a {@apilink Color} uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformFloatColor(name, value) {
        this.setUniform('uniform4f', name, value.r / 255, value.g / 255, value.b / 255, value.a);
    }
    /**
     * Set a {@apilink Color} uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformFloatColor(name, value) {
        return this.trySetUniform('uniform4f', name, value.r / 255, value.g / 255, value.b / 255, value.a);
    }
    /**
     * Set an {@apilink Matrix} uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    setUniformMatrix(name, value) {
        this.setUniform('uniformMatrix4fv', name, false, value.data);
    }
    setUniformAffineMatrix(name, value) {
        this.setUniform('uniformMatrix4fv', name, false, [
            value.data[0],
            value.data[1],
            0,
            0,
            value.data[2],
            value.data[3],
            0,
            0,
            0,
            0,
            1,
            0,
            value.data[4],
            value.data[5],
            0,
            1
        ]);
    }
    /**
     * Set an {@apilink Matrix} uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     * @param name
     * @param value
     */
    trySetUniformMatrix(name, value) {
        return this.trySetUniform('uniformMatrix4fv', name, false, value.data);
    }
    /**
     * Set any available uniform type in webgl
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     */
    setUniform(uniformType, name, ...value) {
        if (!this._compiled) {
            throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);
        }
        if (!this.isCurrentlyBound()) {
            throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +
                ' must call `shader.use()` before setting uniforms');
        }
        const gl = this._gl;
        const location = gl.getUniformLocation(this.program, name);
        if (location) {
            const args = [location, ...value];
            this._gl[uniformType].apply(this._gl, args);
        }
        else {
            throw Error(`Uniform ${uniformType}:${name} doesn\'t exist or is not used in the shader source code,` +
                ' unused uniforms are optimized away by most browsers');
        }
    }
    /**
     * Set any available uniform type in webgl. Will try to set the uniform, will return false if the uniform didn't exist,
     * true if it was set.
     *
     * WILL NOT THROW on error
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     *
     */
    trySetUniform(uniformType, name, ...value) {
        if (!this._compiled) {
            this._logger.warn(`Must compile shader before setting a uniform ${uniformType}:${name}`);
            return false;
        }
        if (!this.isCurrentlyBound()) {
            this._logger.warn('Currently accessed shader instance is not the current active shader in WebGL,' +
                ' must call `shader.use()` before setting uniforms');
            return false;
        }
        const gl = this._gl;
        const location = gl.getUniformLocation(this.program, name);
        if (location) {
            const args = [location, ...value];
            this._gl[uniformType].apply(this._gl, args);
        }
        else {
            return false;
        }
        return true;
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        if (this._onPreLink) {
            this._onPreLink(program);
        }
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            const errorInfo = gl.getShaderInfoLog(shader);
            throw Error(`Could not compile ${typeName} shader:\n\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);
        }
        return shader;
    }
    _processSourceForError(source, errorInfo) {
        if (!source) {
            return errorInfo;
        }
        const lines = source.split('\n');
        const errorLineStart = errorInfo.search(/\d:\d/);
        const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);
        const [_, error2] = errorInfo
            .slice(errorLineStart, errorLineEnd)
            .split(':')
            .map((v) => Number(v));
        for (let i = 0; i < lines.length; i++) {
            lines[i] = `${i + 1}: ${lines[i]}${error2 === i + 1 ? ' <----- ERROR!' : ''}`;
        }
        return '\n\nSource:\n' + lines.join('\n');
    }
}
Shader._ACTIVE_SHADER_INSTANCE = null;


/***/ }),

/***/ "./Graphics/Context/state-stack.ts":
/*!*****************************************!*\
  !*** ./Graphics/Context/state-stack.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1003451__) => {

__nested_webpack_require_1003451__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1003451__.d(__nested_webpack_exports__, {
/* harmony export */   ContextState: () => (/* binding */ ContextState),
/* harmony export */   StateStack: () => (/* binding */ StateStack)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1003451__(/*! ../../Color */ "./Color.ts");
/* harmony import */ var _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1003451__(/*! ../../Util/RentalPool */ "./Util/RentalPool.ts");


class ContextState {
    constructor() {
        this.opacity = 1;
        this.z = 0;
        this.tint = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White;
        this.material = null;
    }
}
class StateStack {
    constructor() {
        this._pool = new _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__.RentalPool(() => new ContextState(), (s) => {
            s.opacity = 1;
            s.z = 0;
            s.tint = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White;
            s.material = null;
            return s;
        }, 100);
        this.current = this._pool.rent(true);
        this._states = [];
    }
    _cloneState(dest) {
        var _a;
        dest.opacity = this.current.opacity;
        dest.z = this.current.z;
        dest.tint = (_a = this.current.tint) === null || _a === void 0 ? void 0 : _a.clone();
        dest.material = this.current.material; // TODO is this going to cause problems when cloning
        return dest;
    }
    save() {
        this._states.push(this.current);
        this.current = this._cloneState(this._pool.rent());
    }
    restore() {
        this._pool.return(this.current);
        this.current = this._states.pop();
    }
}


/***/ }),

/***/ "./Graphics/Context/texture-loader.ts":
/*!********************************************!*\
  !*** ./Graphics/Context/texture-loader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1005466__) => {

__nested_webpack_require_1005466__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1005466__.d(__nested_webpack_exports__, {
/* harmony export */   TextureLoader: () => (/* binding */ TextureLoader)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1005466__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1005466__(/*! ../Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1005466__(/*! ../Wrapping */ "./Graphics/Wrapping.ts");



/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    constructor(gl, _garbageCollector) {
        var _a;
        this._garbageCollector = _garbageCollector;
        this._textureMap = new Map();
        /**
         * Looks for textures that haven't been drawn in a while
         */
        this._collect = (image) => {
            var _a;
            if (this._gl) {
                const name = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : image.constructor.name;
                TextureLoader._LOGGER.debug(`WebGL Texture for ${name} collected`);
                this.delete(image);
                return true;
            }
            return false;
        };
        this._gl = gl;
        TextureLoader._MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        if (this._garbageCollector) {
            TextureLoader._LOGGER.debug('WebGL Texture collection interval:', this._garbageCollector.collectionInterval);
            (_a = this._garbageCollector.garbageCollector) === null || _a === void 0 ? void 0 : _a.registerCollector('texture', this._garbageCollector.collectionInterval, this._collect);
        }
    }
    dispose() {
        for (const [image] of this._textureMap) {
            this.delete(image);
        }
        this._textureMap.clear();
        this._gl = null;
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    get(image) {
        return this._textureMap.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    has(image) {
        return this._textureMap.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param options {ImageSourceOptions} Optionally configure the ImageFiltering and ImageWrapping mode to apply to the loaded texture
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    load(image, options, forceUpdate = false) {
        var _a, _b;
        // Ignore loading if webgl is not registered
        const gl = this._gl;
        if (!gl) {
            return null;
        }
        const { filtering, wrapping } = { ...options };
        let tex = null;
        // If reuse the texture if it's from the same source
        if (this.has(image)) {
            tex = this.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            }
            (_a = this._garbageCollector) === null || _a === void 0 ? void 0 : _a.garbageCollector.touch(image);
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        // TODO implement texture gc with weakmap and timer
        TextureLoader.checkImageSizeSupportedAndLog(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        let wrappingConfig;
        if (wrapping) {
            if (typeof wrapping === 'string') {
                wrappingConfig = {
                    x: wrapping,
                    y: wrapping
                };
            }
            else {
                wrappingConfig = {
                    x: wrapping.x,
                    y: wrapping.y
                };
            }
        }
        const { x: xWrap, y: yWrap } = wrappingConfig !== null && wrappingConfig !== void 0 ? wrappingConfig : TextureLoader.wrapping;
        switch (xWrap) {
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Clamp:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                break;
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Repeat:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                break;
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Mirror:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                break;
            default:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        }
        switch (yWrap) {
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Clamp:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                break;
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Repeat:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                break;
            case _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Mirror:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                break;
            default:
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        // NEAREST for pixel art, LINEAR for hi-res
        const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === _Filtering__WEBPACK_IMPORTED_MODULE_1__.ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === _Filtering__WEBPACK_IMPORTED_MODULE_1__.ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        this._textureMap.set(image, tex);
        (_b = this._garbageCollector) === null || _b === void 0 ? void 0 : _b.garbageCollector.addCollectableResource('texture', image);
        return tex;
    }
    delete(image) {
        // Ignore loading if webgl is not registered
        const gl = this._gl;
        if (!gl) {
            return;
        }
        if (this.has(image)) {
            const texture = this.get(image);
            if (texture) {
                this._textureMap.delete(image);
                gl.deleteTexture(texture);
            }
        }
    }
    /**
     * Takes an image and returns if it meets size criteria for hardware
     * @param image
     * @returns if the image will be supported at runtime
     */
    static checkImageSizeSupportedAndLog(image) {
        var _a;
        const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : 'internal canvas bitmap';
        if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {
            TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of ` +
                `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image ` +
                `for excalibur to render properly.\n\nImages will likely render as black rectangles.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
            return false;
        }
        else if (image.width > 4096 || image.height > 4096) {
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits
            TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, ` +
                `it is recommended you resize images to a maximum (4096x4096).\n\n` +
                `Images will likely render as black rectangles on some mobile platforms.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
        }
        return true;
    }
}
TextureLoader._LOGGER = _Util_Log__WEBPACK_IMPORTED_MODULE_2__.Logger.getInstance();
/**
 * Sets the default filtering for the Excalibur texture loader, default {@apilink ImageFiltering.Blended}
 */
TextureLoader.filtering = _Filtering__WEBPACK_IMPORTED_MODULE_1__.ImageFiltering.Blended;
TextureLoader.wrapping = { x: _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Clamp, y: _Wrapping__WEBPACK_IMPORTED_MODULE_0__.ImageWrapping.Clamp };
TextureLoader._MAX_TEXTURE_SIZE = 4096;


/***/ }),

/***/ "./Graphics/Context/transform-stack.ts":
/*!*********************************************!*\
  !*** ./Graphics/Context/transform-stack.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1014915__) => {

__nested_webpack_require_1014915__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1014915__.d(__nested_webpack_exports__, {
/* harmony export */   TransformStack: () => (/* binding */ TransformStack)
/* harmony export */ });
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1014915__(/*! ../../Math/affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _Util_RentalPool__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1014915__(/*! ../../Util/RentalPool */ "./Util/RentalPool.ts");


class TransformStack {
    constructor() {
        this._pool = new _Util_RentalPool__WEBPACK_IMPORTED_MODULE_0__.RentalPool(() => _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__.AffineMatrix.identity(), (mat) => mat.reset(), 100);
        this._transforms = [];
        this._currentTransform = this._pool.rent(true);
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone(this._pool.rent());
    }
    restore() {
        this._pool.return(this._currentTransform);
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    reset() {
        this._currentTransform.reset();
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}


/***/ }),

/***/ "./Graphics/Context/vertex-buffer.ts":
/*!*******************************************!*\
  !*** ./Graphics/Context/vertex-buffer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1016765__) => {

__nested_webpack_require_1016765__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1016765__.d(__nested_webpack_exports__, {
/* harmony export */   VertexBuffer: () => (/* binding */ VertexBuffer)
/* harmony export */ });
/**
 * Helper around vertex buffer to simplify creating and uploading geometry
 *
 * Under the hood uses Float32Array
 */
class VertexBuffer {
    constructor(options) {
        /**
         * If the vertices never change switching 'static' can be more efficient on the gpu
         *
         * Default is 'dynamic'
         */
        this.type = 'dynamic';
        const { gl, size, type, data } = options;
        this._gl = gl;
        this.buffer = this._gl.createBuffer();
        if (!data && !size) {
            throw Error('Must either provide data or a size to the VertexBuffer');
        }
        if (!data) {
            this.bufferData = new Float32Array(size);
        }
        else {
            this.bufferData = data;
        }
        this.type = type !== null && type !== void 0 ? type : this.type;
        // Allocate buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
    }
    /**
     * Bind this vertex buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    }
    unbind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Upload vertex buffer geometry to the GPU
     */
    upload(count) {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        if (count) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);
        }
        else {
            // TODO always use bufferSubData? need to perf test it
            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
        }
    }
    dispose() {
        const gl = this._gl;
        gl.deleteBuffer(this.buffer);
        this._gl = null;
    }
}


/***/ }),

/***/ "./Graphics/Context/vertex-layout.ts":
/*!*******************************************!*\
  !*** ./Graphics/Context/vertex-layout.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1019133__) => {

__nested_webpack_require_1019133__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1019133__.d(__nested_webpack_exports__, {
/* harmony export */   VertexLayout: () => (/* binding */ VertexLayout)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1019133__(/*! ../.. */ "./Util/Log.ts");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1019133__(/*! ./webgl-util */ "./Graphics/Context/webgl-util.ts");


/**
 * Helper around creating vertex attributes in a given {@apilink VertexBuffer}, this is useful for describing
 * the memory layout for your vertices inside a particular buffer
 *
 * Note: This helper assumes interleaved attributes in one {@apilink VertexBuffer}, not many.
 *
 * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you
 */
class VertexLayout {
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get attributes() {
        return this._attributes;
    }
    constructor(options) {
        this._logger = ___WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this._suppressWarnings = false;
        this._layout = [];
        this._attributes = [];
        this._vertexTotalSizeBytes = 0;
        this._initialized = false;
        const { gl, shader, vertexBuffer, attributes, suppressWarnings } = options;
        this._gl = gl;
        this._vertexBuffer = vertexBuffer;
        this._attributes = attributes;
        this._shader = shader;
        this._suppressWarnings = suppressWarnings;
        if (shader) {
            this.initialize();
        }
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        return this._vertexTotalSizeBytes;
    }
    set shader(shader) {
        if (shader && this._shader !== shader) {
            this._shader = shader;
            this.initialize();
        }
    }
    get shader() {
        return this._shader;
    }
    /**
     * Layouts need shader locations and must be bound to a shader
     */
    initialize() {
        if (this._initialized) {
            return;
        }
        if (!this._shader) {
            return;
        }
        if (!this._shader.compiled) {
            throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');
        }
        this._vertexTotalSizeBytes = 0;
        this._layout.length = 0;
        const shaderAttributes = this._shader.attributes;
        for (const attribute of this._attributes) {
            const attrib = shaderAttributes[attribute[0]];
            if (!attrib) {
                if (!(0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isAttributeInSource)(this._shader.vertexSource, attribute[0])) {
                    throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}` +
                        ` not found in the shader source code:\n ${this._shader.vertexSource}`);
                }
                if (!this._suppressWarnings) {
                    this._logger.warn(`The attribute named: ${attribute[0]} size ${attribute[1]}` +
                        ` not found in the compiled shader. This is possibly a bug:\n` +
                        ` 1. Not a bug, but should remove unused code - attribute "${attribute[0]}" is unused in` +
                        ` vertex/fragment and has been automatically removed by glsl compiler.\n` +
                        ` 2. Definitely a bug, attribute "${attribute[0]}" in layout has been mistyped or is missing` +
                        ` in shader, check vertex/fragment source.`);
                }
                const glType = (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getGLTypeFromSource)(this._gl, this._shader.vertexSource, attribute[0]);
                // Unused attribute placeholder
                this._layout.push({
                    name: attribute[0],
                    glType,
                    size: attribute[1],
                    location: -1,
                    normalized: false
                });
            }
            if (attrib) {
                if (attrib.size !== attribute[1]) {
                    throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],` +
                        ` doesn\'t match shader source size ${attrib.size}:\n ${this._shader.vertexSource}`);
                }
                this._layout.push(attrib);
            }
        }
        // calc size
        let componentsPerVertex = 0;
        for (const vertAttribute of this._layout) {
            const typeSize = (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getGlTypeSizeBytes)(this._gl, vertAttribute.glType);
            this._vertexTotalSizeBytes += typeSize * vertAttribute.size;
            componentsPerVertex += vertAttribute.size;
        }
        if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {
            this._logger.warn(`The vertex component size (${componentsPerVertex})  does NOT divide evenly into the specified vertex buffer` +
                ` (${this._vertexBuffer.bufferData.length})`);
        }
        // create VAO
        const gl = this._gl;
        this._vao = gl.createVertexArray();
        gl.bindVertexArray(this._vao);
        this._vertexBuffer.bind();
        let offset = 0;
        for (const vert of this._layout) {
            // skip unused attributes
            if (vert.location !== -1) {
                if (vert.glType === gl.INT) {
                    gl.vertexAttribIPointer(vert.location, vert.size, vert.glType, this.totalVertexSizeBytes, offset);
                }
                else {
                    gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
                }
                gl.enableVertexAttribArray(vert.location);
            }
            offset += (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getGlTypeSizeBytes)(gl, vert.glType) * vert.size;
        }
        gl.bindVertexArray(null);
        this._vertexBuffer.unbind();
        this._initialized = true;
    }
    /**
     * Bind this layout with it's associated vertex buffer
     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
     */
    use(uploadBuffer = false, count) {
        if (!this._shader) {
            throw Error('No shader is associated with this vertex layout, a shader must be set');
        }
        const gl = this._gl;
        if (!this._shader.isCurrentlyBound()) {
            throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');
        }
        this._vertexBuffer.bind();
        if (uploadBuffer) {
            this._vertexBuffer.upload(count);
        }
        gl.bindVertexArray(this._vao);
    }
}


/***/ }),

/***/ "./Graphics/Context/webgl-util.ts":
/*!****************************************!*\
  !*** ./Graphics/Context/webgl-util.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1026253__) => {

__nested_webpack_require_1026253__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1026253__.d(__nested_webpack_exports__, {
/* harmony export */   getAttributeComponentSize: () => (/* binding */ getAttributeComponentSize),
/* harmony export */   getAttributePointerType: () => (/* binding */ getAttributePointerType),
/* harmony export */   getGLTypeFromSource: () => (/* binding */ getGLTypeFromSource),
/* harmony export */   getGlTypeSizeBytes: () => (/* binding */ getGlTypeSizeBytes),
/* harmony export */   getMaxShaderComplexity: () => (/* binding */ getMaxShaderComplexity),
/* harmony export */   isAttributeInSource: () => (/* binding */ isAttributeInSource)
/* harmony export */ });
/**
 * Return the size of the GlType in bytes
 * @param gl
 * @param type
 */
function getGlTypeSizeBytes(gl, type) {
    switch (type) {
        case gl.INT:
        case gl.UNSIGNED_INT:
        case gl.FLOAT:
            return 4;
        case gl.SHORT:
            return 2;
        case gl.UNSIGNED_SHORT:
            return 2;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        default:
            return 1;
    }
}
/**
 * Checks if an attribute is present in vertex source
 */
function isAttributeInSource(source, variable) {
    const attributeRegexTemplate = `(?<type>[a-z0-9]+)\\s+${variable};`;
    const regex = new RegExp(attributeRegexTemplate, 'g');
    const matches = regex.exec(source);
    return (matches === null || matches === void 0 ? void 0 : matches.length) > 0;
}
/**
 * Attempt to discern the glType of an attribute from vertex source
 * @param gl
 * @param source
 * @param variable
 */
function getGLTypeFromSource(gl, source, variable) {
    var _a;
    const attributeRegexTemplate = `(?<type>[a-z0-9]+)\\s+${variable};`;
    const regex = new RegExp(attributeRegexTemplate, 'g');
    const matches = regex.exec(source);
    const type = (_a = matches === null || matches === void 0 ? void 0 : matches.groups) === null || _a === void 0 ? void 0 : _a.type;
    switch (type) {
        case 'float':
        case 'vec2':
        case 'vec3':
        case 'vec4':
            return gl.FLOAT;
        case 'int':
        case 'ivec2':
        case 'ivec3':
        case 'ivec4':
            return gl.INT;
        case 'uint':
        case 'uvec2':
        case 'uvec3':
        case 'uvec4':
            return gl.UNSIGNED_INT;
        case 'bool':
        case 'bvec2':
        case 'bvec3':
        case 'bvec4':
            return gl.BOOL;
        case 'short':
            return gl.SHORT;
        case 'ushort':
            return gl.UNSIGNED_SHORT;
        case 'ubyte':
            return gl.UNSIGNED_BYTE;
        case 'byte':
            return gl.BYTE;
        default:
            return gl.FLOAT;
    }
}
/**
 * Based on the type return the number of attribute components
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 * @param gl
 * @param type
 */
function getAttributeComponentSize(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
            return 1;
        case gl.FLOAT_VEC2:
            return 2;
        case gl.FLOAT_VEC3:
            return 3;
        case gl.FLOAT_VEC4:
            return 4;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        case gl.UNSIGNED_SHORT:
        case gl.SHORT:
            return 1;
        default:
            return 1;
    }
}
/**
 * Based on the attribute return the corresponding supported attrib pointer type
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 * @param gl
 * @param type
 */
function getAttributePointerType(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
        case gl.FLOAT_VEC2:
        case gl.FLOAT_VEC3:
        case gl.FLOAT_VEC4:
            return gl.FLOAT;
        case gl.BYTE:
            return gl.BYTE;
        case gl.UNSIGNED_BYTE:
            return gl.UNSIGNED_BYTE;
        case gl.SHORT:
            return gl.SHORT;
        case gl.UNSIGNED_SHORT:
            return gl.UNSIGNED_SHORT;
        default:
            return gl.FLOAT;
    }
}
/**
 *
 */
function getMaxShaderComplexity(gl, numIfs) {
    const assembleTestShader = (numIfs) => {
        const testShader = `#version 300 es
    precision mediump float;
    out vec4 fragColor;
    void main() {
      float index = 1.01;
      %%complexity%%
    }`;
        let testComplexity = '';
        for (let i = 0; i < numIfs; i++) {
            if (i === 0) {
                testComplexity += `if (index <= ${i}.5) {\n`;
            }
            else {
                testComplexity += `   else if (index <= ${i}.5) {\n`;
            }
            testComplexity += `      fragColor = vec4(1.0);\n`;
            testComplexity += `   }\n`;
        }
        return testShader.replace('%%complexity%%', testComplexity);
    };
    let canCompile = false;
    do {
        const test = assembleTestShader(numIfs);
        const shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shader, test);
        gl.compileShader(shader);
        canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!canCompile) {
            numIfs = (numIfs / 2) | 0;
        }
    } while (!canCompile);
    return numIfs;
}


/***/ }),

/***/ "./Graphics/Debug.ts":
/*!***************************!*\
  !*** ./Graphics/Debug.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1031914__) => {

__nested_webpack_require_1031914__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1031914__.d(__nested_webpack_exports__, {
/* harmony export */   Debug: () => (/* binding */ Debug)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1031914__(/*! ../Color */ "./Color.ts");

class Debug {
    static registerGraphicsContext(ctx) {
        Debug._ctx = ctx;
    }
    static draw(debugDrawCall) {
        this._drawCalls.push(debugDrawCall);
    }
    static drawPoint(point, options) {
        Debug.draw((ctx) => {
            ctx.debug.drawPoint(point, options);
        });
    }
    static drawLine(start, end, options) {
        Debug.draw((ctx) => {
            ctx.debug.drawLine(start, end, options);
        });
    }
    static drawLines(points, options) {
        if (points.length > 1) {
            Debug.draw((ctx) => {
                for (let i = 0; i < points.length - 1; i++) {
                    ctx.debug.drawLine(points[i], points[i + 1], options);
                }
            });
        }
    }
    static drawText(text, pos) {
        Debug.draw((ctx) => {
            ctx.debug.drawText(text, pos);
        });
    }
    static drawPolygon(points, options) {
        if (points.length > 1) {
            Debug.draw((ctx) => {
                const firstPoint = points[0];
                const polygon = [...points, firstPoint];
                for (let i = 0; i < polygon.length - 1; i++) {
                    ctx.debug.drawLine(polygon[i], polygon[i + 1], options);
                }
            });
        }
    }
    static drawCircle(center, radius, options) {
        const { color, strokeColor, width } = {
            color: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Black,
            strokeColor: undefined,
            width: undefined,
            ...options
        };
        Debug.draw((ctx) => {
            ctx.drawCircle(center, radius, color, strokeColor, width);
        });
    }
    static drawBounds(boundingBox, options) {
        Debug.draw((ctx) => {
            ctx.debug.drawRect(boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height, options);
        });
    }
    static drawRay(ray, options) {
        const { distance, color } = {
            color: _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Blue,
            distance: 10,
            ...options
        };
        Debug.draw((ctx) => {
            const start = ray.pos;
            const end = ray.pos.add(ray.dir.scale(distance));
            ctx.debug.drawLine(start, end, { color });
        });
    }
    static flush(ctx) {
        ctx.save();
        ctx.z = Debug.z;
        for (const drawCall of Debug._drawCalls) {
            drawCall(ctx);
        }
        ctx.restore();
        Debug.clear();
    }
    static clear() {
        Debug._drawCalls.length = 0;
    }
}
Debug._drawCalls = [];
Debug.z = Infinity;


/***/ }),

/***/ "./Graphics/DebugGraphicsComponent.ts":
/*!********************************************!*\
  !*** ./Graphics/DebugGraphicsComponent.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1035094__) => {

__nested_webpack_require_1035094__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1035094__.d(__nested_webpack_exports__, {
/* harmony export */   DebugGraphicsComponent: () => (/* binding */ DebugGraphicsComponent)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1035094__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");

/**
 * Provide arbitrary drawing for the purposes of debugging your game
 *
 * Will only show when the Engine is set to debug mode {@apilink Engine.showDebug} or {@apilink Engine.toggleDebug}
 *
 */
class DebugGraphicsComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(draw, useTransform = true) {
        super();
        this.draw = draw;
        this.useTransform = useTransform;
    }
}


/***/ }),

/***/ "./Graphics/Filtering.ts":
/*!*******************************!*\
  !*** ./Graphics/Filtering.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1036199__) => {

__nested_webpack_require_1036199__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1036199__.d(__nested_webpack_exports__, {
/* harmony export */   ImageFiltering: () => (/* binding */ ImageFiltering),
/* harmony export */   parseImageFiltering: () => (/* binding */ parseImageFiltering)
/* harmony export */ });
/**
 * Describes the different image filtering modes
 */
var ImageFiltering;
(function (ImageFiltering) {
    /**
     * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.
     *
     * Useful for Pixel art aesthetics.
     */
    ImageFiltering["Pixel"] = "Pixel";
    /**
     * Blended is useful when you have high resolution artwork and would like it blended and smoothed
     */
    ImageFiltering["Blended"] = "Blended";
})(ImageFiltering || (ImageFiltering = {}));
/**
 * Parse the image filtering attribute value, if it doesn't match returns null
 */
function parseImageFiltering(val) {
    switch (val) {
        case ImageFiltering.Pixel:
            return ImageFiltering.Pixel;
        case ImageFiltering.Blended:
            return ImageFiltering.Blended;
        default:
            return undefined;
    }
}


/***/ }),

/***/ "./Graphics/Font.ts":
/*!**************************!*\
  !*** ./Graphics/Font.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1037578__) => {

__nested_webpack_require_1037578__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1037578__.d(__nested_webpack_exports__, {
/* harmony export */   Font: () => (/* binding */ Font)
/* harmony export */ });
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1037578__(/*! ../Collision/Index */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1037578__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _FontCommon__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1037578__(/*! ./FontCommon */ "./Graphics/FontCommon.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1037578__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1037578__(/*! ./Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _FontTextInstance__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1037578__(/*! ./FontTextInstance */ "./Graphics/FontTextInstance.ts");
/* harmony import */ var _FontCache__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1037578__(/*! ./FontCache */ "./Graphics/FontCache.ts");







/**
 * Represents a system or web font in Excalibur
 *
 * If no options specified, the system sans-serif 10 pixel is used
 *
 * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/
 */
class Font extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        super(options); // <- Graphics properties
        /**
         * Set the font filtering mode, by default set to {@apilink ImageFiltering.Blended} regardless of the engine default smoothing
         *
         * If you have a pixel style font that may be a reason to switch this to {@apilink ImageFiltering.Pixel}
         */
        this.filtering = _Filtering__WEBPACK_IMPORTED_MODULE_1__.ImageFiltering.Blended;
        /**
         * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 2)
         */
        this.quality = 2;
        // Raster properties for fonts
        this.padding = 2;
        this.smoothing = false;
        this.lineWidth = 1;
        this.lineDash = [];
        this.color = _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Black;
        this.family = 'sans-serif';
        this.style = _FontCommon__WEBPACK_IMPORTED_MODULE_3__.FontStyle.Normal;
        this.bold = false;
        this.unit = _FontCommon__WEBPACK_IMPORTED_MODULE_3__.FontUnit.Px;
        this.textAlign = _FontCommon__WEBPACK_IMPORTED_MODULE_3__.TextAlign.Left;
        this.baseAlign = _FontCommon__WEBPACK_IMPORTED_MODULE_3__.BaseAlign.Top;
        this.direction = _FontCommon__WEBPACK_IMPORTED_MODULE_3__.Direction.LeftToRight;
        /**
         * Font line height in pixels, default line height if unset
         */
        this.lineHeight = undefined;
        this.size = 10;
        this._textBounds = new _Collision_Index__WEBPACK_IMPORTED_MODULE_4__.BoundingBox();
        this._textMeasurement = new _FontTextInstance__WEBPACK_IMPORTED_MODULE_5__.FontTextInstance(this, '', _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Black);
        // Raster properties
        this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;
        this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;
        this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;
        this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;
        this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
        this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;
        this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;
        // Font specific properties
        this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;
        this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;
        this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;
        this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;
        this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;
        this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;
        this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;
        this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;
        this.lineHeight = (_r = options === null || options === void 0 ? void 0 : options.lineHeight) !== null && _r !== void 0 ? _r : this.lineHeight;
        this.quality = (_s = options === null || options === void 0 ? void 0 : options.quality) !== null && _s !== void 0 ? _s : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_t = options.shadow.blur) !== null && _t !== void 0 ? _t : this.shadow.blur;
            this.shadow.offset = (_u = options.shadow.offset) !== null && _u !== void 0 ? _u : this.shadow.offset;
            this.shadow.color = (_v = options.shadow.color) !== null && _v !== void 0 ? _v : this.shadow.color;
        }
    }
    clone() {
        return new Font({
            ...this.cloneGraphicOptions(),
            size: this.size,
            unit: this.unit,
            family: this.family,
            style: this.style,
            bold: this.bold,
            textAlign: this.textAlign,
            baseAlign: this.baseAlign,
            direction: this.direction,
            shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : undefined
        });
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(_ex, _x, _y) {
        // TODO weird vestigial drawimage
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    measureTextWithoutCache(text, maxWidth) {
        return this._textMeasurement.measureText(text, maxWidth);
    }
    /**
     * Returns a BoundingBox that is the total size of the text including multiple lines
     *
     * Does not include any padding or adjustment
     * @param text
     * @returns BoundingBox
     */
    measureText(text, maxWidth) {
        return _FontCache__WEBPACK_IMPORTED_MODULE_6__.FontCache.measureText(text, this, maxWidth);
    }
    _postDraw(ex) {
        ex.restore();
    }
    render(ex, text, colorOverride, x, y, maxWidth) {
        const textInstance = _FontCache__WEBPACK_IMPORTED_MODULE_6__.FontCache.getTextInstance(text, this, colorOverride);
        // Apply affine transformations
        this._textBounds = textInstance.dimensions;
        this._preDraw(ex, x, y);
        textInstance.render(ex, x, y, maxWidth);
        this._postDraw(ex);
    }
}


/***/ }),

/***/ "./Graphics/FontCache.ts":
/*!*******************************!*\
  !*** ./Graphics/FontCache.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1046739__) => {

__nested_webpack_require_1046739__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1046739__.d(__nested_webpack_exports__, {
/* harmony export */   FontCache: () => (/* binding */ FontCache)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1046739__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _FontTextInstance__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1046739__(/*! ./FontTextInstance */ "./Graphics/FontTextInstance.ts");


class FontCache {
    static measureText(text, font, maxWidth) {
        const hash = _FontTextInstance__WEBPACK_IMPORTED_MODULE_0__.FontTextInstance.getHashCode(font, text);
        if (FontCache._MEASURE_CACHE.has(hash)) {
            return FontCache._MEASURE_CACHE.get(hash);
        }
        FontCache._LOGGER.debug('Font text measurement cache miss');
        const measurement = font.measureTextWithoutCache(text, maxWidth);
        FontCache._MEASURE_CACHE.set(hash, measurement);
        return measurement;
    }
    static getTextInstance(text, font, color) {
        const hash = _FontTextInstance__WEBPACK_IMPORTED_MODULE_0__.FontTextInstance.getHashCode(font, text, color);
        let textInstance = FontCache._TEXT_CACHE.get(hash);
        if (!textInstance) {
            textInstance = new _FontTextInstance__WEBPACK_IMPORTED_MODULE_0__.FontTextInstance(font, text, color);
            FontCache._TEXT_CACHE.set(hash, textInstance);
            FontCache._LOGGER.debug('Font text instance cache miss');
        }
        // Cache the bitmap for certain amount of time
        FontCache._TEXT_USAGE.set(textInstance, performance.now());
        return textInstance;
    }
    static checkAndClearCache() {
        const deferred = [];
        const currentHashCodes = new Set();
        for (const [textInstance, time] of FontCache._TEXT_USAGE.entries()) {
            // if bitmap hasn't been used in 100 ms clear it
            if (time + FontCache.FONT_TIMEOUT < performance.now()) {
                FontCache._LOGGER.debug(`Text cache entry timed out ${textInstance.text}`);
                deferred.push(textInstance);
                textInstance.dispose();
            }
            else {
                const hash = textInstance.getHashCode(false);
                currentHashCodes.add(hash);
            }
        }
        // Deferred removal of text instances
        deferred.forEach((t) => {
            FontCache._TEXT_USAGE.delete(t);
        });
        // Regenerate text instance cache
        this._TEXT_CACHE.clear();
        for (const [textInstance] of this._TEXT_USAGE.entries()) {
            this._TEXT_CACHE.set(textInstance.getHashCode(), textInstance);
        }
        // Regenerated measurement cache
        const newTextMeasurementCache = new Map();
        for (const current of currentHashCodes) {
            if (FontCache._MEASURE_CACHE.has(current)) {
                newTextMeasurementCache.set(current, FontCache._MEASURE_CACHE.get(current));
            }
        }
        this._MEASURE_CACHE.clear();
        this._MEASURE_CACHE = newTextMeasurementCache;
    }
    static get cacheSize() {
        return FontCache._TEXT_USAGE.size;
    }
    /**
     * Force clear all cached text bitmaps
     */
    static clearCache() {
        for (const [textInstance] of FontCache._TEXT_USAGE.entries()) {
            textInstance.dispose();
        }
        FontCache._TEXT_USAGE.clear();
        FontCache._TEXT_CACHE.clear();
        FontCache._MEASURE_CACHE.clear();
    }
}
FontCache.FONT_TIMEOUT = 500;
FontCache._LOGGER = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
FontCache._TEXT_USAGE = new Map();
FontCache._TEXT_CACHE = new Map();
FontCache._MEASURE_CACHE = new Map();


/***/ }),

/***/ "./Graphics/FontCommon.ts":
/*!********************************!*\
  !*** ./Graphics/FontCommon.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1050714__) => {

__nested_webpack_require_1050714__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1050714__.d(__nested_webpack_exports__, {
/* harmony export */   BaseAlign: () => (/* binding */ BaseAlign),
/* harmony export */   Direction: () => (/* binding */ Direction),
/* harmony export */   FontStyle: () => (/* binding */ FontStyle),
/* harmony export */   FontUnit: () => (/* binding */ FontUnit),
/* harmony export */   TextAlign: () => (/* binding */ TextAlign)
/* harmony export */ });
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
/**
 * Enum representing the text direction, useful for other languages, or writing text in reverse
 */
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));


/***/ }),

/***/ "./Graphics/FontTextInstance.ts":
/*!**************************************!*\
  !*** ./Graphics/FontTextInstance.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1054791__) => {

__nested_webpack_require_1054791__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1054791__.d(__nested_webpack_exports__, {
/* harmony export */   FontTextInstance: () => (/* binding */ FontTextInstance)
/* harmony export */ });
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1054791__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1054791__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1054791__(/*! ../Util/DrawUtil */ "./Util/DrawUtil.ts");
/* harmony import */ var _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1054791__(/*! ./Context/ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");




class FontTextInstance {
    constructor(font, text, color, maxWidth) {
        this.font = font;
        this.text = text;
        this.color = color;
        this.maxWidth = maxWidth;
        this._textFragments = [];
        this.disposed = false;
        this._dirty = true;
        this.canvas = document.createElement('canvas');
        const ctx = this.canvas.getContext('2d');
        if (!ctx) {
            throw new Error('Unable to create FontTextInstance, internal canvas failed to create');
        }
        this.ctx = ctx;
        this.dimensions = this.measureText(text);
        this._setDimension(this.dimensions, this.ctx);
        this._lastHashCode = this.getHashCode();
    }
    measureText(text, maxWidth) {
        if (this.disposed) {
            throw Error('Accessing disposed text instance! ' + this.text);
        }
        let lines = null;
        if (maxWidth != null) {
            lines = this._getLinesFromText(text, maxWidth);
        }
        else {
            lines = text.split('\n');
        }
        const maxWidthLine = lines.reduce((a, b) => {
            return a.length > b.length ? a : b;
        });
        this._applyFont(this.ctx); // font must be applied to the context to measure it
        const metrics = this.ctx.measureText(maxWidthLine);
        let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
        // TODO line height makes the text bounds wonky
        const lineAdjustedHeight = textHeight * lines.length;
        textHeight = lineAdjustedHeight;
        const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
        const x = 0;
        const y = 0;
        const measurement = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({
            left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.font.padding,
            top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.font.padding,
            bottom: y + bottomBounds + this.font.padding,
            right: x + Math.abs(metrics.actualBoundingBoxRight) + this.font.padding
        });
        return measurement;
    }
    _setDimension(textBounds, bitmap) {
        let lineHeightRatio = 1;
        if (this.font.lineHeight) {
            lineHeightRatio = this.font.lineHeight / this.font.size;
        }
        // Changing the width and height clears the context properties
        // We double the bitmap width to account for all possible alignment
        // We scale by "quality" so we render text without jaggies
        bitmap.canvas.width = (textBounds.width + this.font.padding * 2) * 2 * this.font.quality;
        bitmap.canvas.height = (textBounds.height + this.font.padding * 2) * 2 * this.font.quality * lineHeightRatio;
    }
    static getHashCode(font, text, color) {
        var _a;
        const hash = text +
            '__hashcode__' +
            font.fontString +
            font.showDebug +
            font.textAlign +
            font.baseAlign +
            font.direction +
            font.lineHeight +
            JSON.stringify(font.shadow) +
            (font.padding.toString() +
                font.smoothing.toString() +
                font.lineWidth.toString() +
                font.lineDash.toString() +
                ((_a = font.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) +
                (color ? color.toString() : font.color.toString()));
        return hash;
    }
    getHashCode(includeColor = true) {
        return FontTextInstance.getHashCode(this.font, this.text, includeColor ? this.color : undefined);
    }
    _applyRasterProperties(ctx) {
        var _a, _b, _c;
        ctx.translate(this.font.padding, this.font.padding);
        ctx.imageSmoothingEnabled = this.font.smoothing;
        ctx.lineWidth = this.font.lineWidth;
        ctx.setLineDash((_a = this.font.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_c = (_b = this.font.strokeColor) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '';
        ctx.fillStyle = this.color.toString();
    }
    _applyFont(ctx) {
        ctx.resetTransform();
        ctx.translate(this.font.padding + ctx.canvas.width / 2, this.font.padding + ctx.canvas.height / 2);
        ctx.scale(this.font.quality, this.font.quality);
        ctx.textAlign = this.font.textAlign;
        ctx.textBaseline = this.font.baseAlign;
        ctx.font = this.font.fontString;
        ctx.direction = this.font.direction;
        if (this.font.shadow) {
            if (this.font.shadow.color) {
                ctx.shadowColor = this.font.shadow.color.toString();
            }
            if (this.font.shadow.blur) {
                ctx.shadowBlur = this.font.shadow.blur;
            }
            if (this.font.shadow.offset) {
                ctx.shadowOffsetX = this.font.shadow.offset.x;
                ctx.shadowOffsetY = this.font.shadow.offset.y;
            }
        }
    }
    _drawText(ctx, lines, lineHeight) {
        this._applyRasterProperties(ctx);
        this._applyFont(ctx);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (this.color) {
                ctx.fillText(line, 0, i * lineHeight);
            }
            if (this.font.strokeColor) {
                ctx.strokeText(line, 0, i * lineHeight);
            }
        }
        if (this.font.showDebug) {
            // Horizontal line
            /* istanbul ignore next */
            (0,_Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Green, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);
            // Vertical line
            /* istanbul ignore next */
            (0,_Util_DrawUtil__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);
        }
    }
    _splitTextBitmap(bitmap) {
        const textImages = [];
        let currentX = 0;
        let currentY = 0;
        // 4k is the max for mobile devices
        const width = Math.min(4096, bitmap.canvas.width);
        const height = Math.min(4096, bitmap.canvas.height);
        // Splits the original bitmap into 4k max chunks
        while (currentX < bitmap.canvas.width) {
            while (currentY < bitmap.canvas.height) {
                // create new bitmap
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw new Error('Unable to split internal FontTextInstance bitmap, failed to create internal canvas');
                }
                // draw current slice to new bitmap in < 4k chunks
                ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);
                textImages.push({ x: currentX, y: currentY, canvas });
                currentY += height;
            }
            currentX += width;
            currentY = 0;
        }
        return textImages;
    }
    flagDirty() {
        this._dirty = true;
    }
    render(ex, x, y, maxWidth) {
        var _a;
        if (this.disposed) {
            throw Error('Accessing disposed text instance! ' + this.text);
        }
        this._ex = ex;
        const hashCode = this.getHashCode();
        if (this._lastHashCode !== hashCode) {
            this._dirty = true;
        }
        // Calculate image chunks
        if (this._dirty) {
            this.dimensions = this.measureText(this.text, maxWidth);
            this._setDimension(this.dimensions, this.ctx);
            const lines = this._getLinesFromText(this.text, maxWidth);
            const lineHeight = (_a = this.font.lineHeight) !== null && _a !== void 0 ? _a : this.dimensions.height / lines.length;
            // draws the text to the main bitmap
            this._drawText(this.ctx, lines, lineHeight);
            // clear any out old fragments
            if (ex instanceof _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_3__.ExcaliburGraphicsContextWebGL) {
                for (const frag of this._textFragments) {
                    ex.textureLoader.delete(frag.canvas);
                }
            }
            // splits to < 4k fragments for large text
            this._textFragments = this._splitTextBitmap(this.ctx);
            if (ex instanceof _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_3__.ExcaliburGraphicsContextWebGL) {
                for (const frag of this._textFragments) {
                    ex.textureLoader.load(frag.canvas, { filtering: this.font.filtering }, true);
                }
            }
            this._lastHashCode = hashCode;
            this._dirty = false;
        }
        // draws the bitmap fragments to excalibur graphics context
        for (const frag of this._textFragments) {
            ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.font.quality + x - this.ctx.canvas.width / this.font.quality / 2, frag.y / this.font.quality + y - this.ctx.canvas.height / this.font.quality / 2, frag.canvas.width / this.font.quality, frag.canvas.height / this.font.quality);
        }
    }
    dispose() {
        this.disposed = true;
        this.dimensions = undefined;
        this.canvas = undefined;
        this.ctx = undefined;
        if (this._ex instanceof _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_3__.ExcaliburGraphicsContextWebGL) {
            for (const frag of this._textFragments) {
                this._ex.textureLoader.delete(frag.canvas);
            }
        }
        this._textFragments.length = 0;
    }
    _getLinesFromText(text, maxWidth) {
        var _a;
        if (this._cachedText === text && this._cachedRenderWidth === maxWidth && ((_a = this._cachedLines) === null || _a === void 0 ? void 0 : _a.length)) {
            return this._cachedLines;
        }
        const lines = text.split('\n');
        if (maxWidth == null) {
            return lines;
        }
        // If the current line goes past the maxWidth, append a new line without modifying the underlying text.
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            let newLine = '';
            if (this.measureText(line).width > maxWidth) {
                while (this.measureText(line).width > maxWidth) {
                    newLine = line[line.length - 1] + newLine;
                    line = line.slice(0, -1); // Remove last character from line
                }
                // Update the array with our new values
                lines[i] = line;
                lines[i + 1] = newLine;
            }
        }
        this._cachedText = text;
        this._cachedLines = lines;
        this._cachedRenderWidth = maxWidth;
        return lines;
    }
}


/***/ }),

/***/ "./Graphics/Graphic.ts":
/*!*****************************!*\
  !*** ./Graphics/Graphic.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1066891__) => {

__nested_webpack_require_1066891__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1066891__.d(__nested_webpack_exports__, {
/* harmony export */   Graphic: () => (/* binding */ Graphic)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1066891__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1066891__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Watch__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1066891__(/*! ../Util/Watch */ "./Util/Watch.ts");
/* harmony import */ var _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1066891__(/*! ../Math/affine-matrix */ "./Math/affine-matrix.ts");




/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the {@apilink ExcaliburGraphicsContext}.
 * {@apilink Sprite}, {@apilink Animation}, {@apilink GraphicsGroup}, {@apilink Canvas}, {@apilink Rectangle}, {@apilink Circle}, and {@apilink Polygon} all derive from the
 * {@apilink Graphic} abstract class.
 *
 * Implementors of a Graphic must override the abstract {@apilink Graphic._drawImage} method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in {@apilink Graphic._preDraw} and {@apilink Graphic._postDraw}
 */
class Graphic {
    isStale() {
        return this._transformStale;
    }
    /**
     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
     */
    get flipHorizontal() {
        return this._flipHorizontal;
    }
    set flipHorizontal(value) {
        this._flipHorizontal = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
     */
    get flipVertical() {
        return this._flipVertical;
    }
    set flipVertical(value) {
        this._flipVertical = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the rotation of the graphic
     */
    get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        this._rotation = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the scale of the graphic, this affects the width and
     */
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_0__.watch)(value, () => {
            this._transformStale = true;
        });
        this._transformStale = true;
    }
    /**
     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
     */
    get origin() {
        return this._origin;
    }
    set origin(value) {
        if (value) {
            this._origin = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_0__.watch)(value, () => {
                this._transformStale = true;
            });
        }
        this._transformStale = true;
    }
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.id = Graphic._ID++;
        this.transform = _Math_affine_matrix__WEBPACK_IMPORTED_MODULE_1__.AffineMatrix.identity();
        this._transformStale = true;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        this._flipHorizontal = false;
        this._flipVertical = false;
        this._rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        this._scale = _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.One;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
            this.tint = (_g = options.tint) !== null && _g !== void 0 ? _g : this.tint;
            if (options.width) {
                this._width = options.width;
            }
            if (options.height) {
                this._height = options.height;
            }
        }
    }
    cloneGraphicOptions() {
        return {
            width: this.width / this.scale.x,
            height: this.height / this.scale.y,
            origin: this.origin ? this.origin.clone() : undefined,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : undefined,
            tint: this.tint ? this.tint.clone() : undefined
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
        this._transformStale = true;
    }
    set height(value) {
        this._height = value;
        this._transformStale = true;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_3__.BoundingBox.fromDimension(this.width, this.height, _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before {@apilink Graphic._drawImage}
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        if (this._transformStale) {
            this.transform.reset();
            this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
            this._rotate(this.transform);
            this._flip(this.transform);
            this._transformStale = false;
        }
        ex.multiply(this.transform);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
        if (this.tint) {
            ex.tint = this.tint;
        }
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any additional work after {@apilink Graphic._drawImage} and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;


/***/ }),

/***/ "./Graphics/GraphicsComponent.ts":
/*!***************************************!*\
  !*** ./Graphics/GraphicsComponent.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1075449__) => {

__nested_webpack_require_1075449__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1075449__.d(__nested_webpack_exports__, {
/* harmony export */   GraphicsComponent: () => (/* binding */ GraphicsComponent),
/* harmony export */   hasGraphicsTick: () => (/* binding */ hasGraphicsTick)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1075449__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1075449__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1075449__(/*! ../Collision/Index */ "./Collision/BoundingBox.ts");
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1075449__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1075449__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_watch_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1075449__(/*! ../Math/watch-vector */ "./Math/watch-vector.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1075449__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Graphics_GraphicsGroup__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1075449__(/*! ../Graphics/GraphicsGroup */ "./Graphics/GraphicsGroup.ts");
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1075449__(/*! ./Raster */ "./Graphics/Raster.ts");
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1075449__(/*! ./Text */ "./Graphics/Text.ts");










/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    /**
     * Sets or gets wether any drawing should be visible in this component
     * @deprecated use isVisible
     */
    get visible() {
        return this.isVisible;
    }
    /**
     * Sets or gets wether any drawing should be visible in this component
     * @deprecated use isVisible
     */
    set visible(val) {
        this.isVisible = val;
    }
    /**
     * Offset to apply to graphics by default
     */
    get offset() {
        return this._offset;
    }
    set offset(value) {
        this._offset = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_1__.WatchVector(value, () => this.recalculateBounds());
        this.recalculateBounds();
    }
    /**
     * Anchor to apply to graphics by default
     */
    get anchor() {
        return this._anchor;
    }
    set anchor(value) {
        this._anchor = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_1__.WatchVector(value, () => this.recalculateBounds());
        this.recalculateBounds();
    }
    /**
     * Sets the color of the actor's current graphic
     */
    get color() {
        return this._color;
    }
    set color(v) {
        if (v) {
            this._color = v.clone();
            const currentGraphic = this.graphics.current;
            if (currentGraphic instanceof _Raster__WEBPACK_IMPORTED_MODULE_2__.Raster || currentGraphic instanceof _Text__WEBPACK_IMPORTED_MODULE_3__.Text) {
                currentGraphic.color = this._color;
            }
        }
    }
    constructor(options) {
        super();
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance();
        this._current = 'default';
        this._graphics = {};
        this._options = {};
        this.material = null;
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.isVisible = true;
        /**
         * Optionally force the graphic onscreen, default false. Not recommend to use for perf reasons, only if you known what you're doing.
         */
        this.forceOnScreen = false;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        this._offset = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_1__.WatchVector(_Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Zero, () => this.recalculateBounds());
        this._anchor = new _Math_watch_vector__WEBPACK_IMPORTED_MODULE_1__.WatchVector(_Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Half, () => this.recalculateBounds());
        /**
         * Flip all graphics horizontally along the y-axis
         */
        this.flipHorizontal = false;
        /**
         * Flip all graphics vertically along the x-axis
         */
        this.flipVertical = false;
        /**
         * If set to true graphics added to the component will be copied. This can effect performance, but is useful if you don't want
         * changes to a graphic to effect all the places it is used.
         */
        this.copyGraphics = false;
        // Defaults
        options = {
            visible: this.isVisible,
            graphics: {},
            ...options
        };
        const { current, anchor, color, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw, onPreTransformDraw, onPostTransformDraw } = options;
        for (const [key, graphicOrOptions] of Object.entries(graphics)) {
            if (graphicOrOptions instanceof _Graphic__WEBPACK_IMPORTED_MODULE_6__.Graphic) {
                this._graphics[key] = graphicOrOptions;
            }
            else {
                this._graphics[key] = graphicOrOptions.graphic;
                this._options[key] = graphicOrOptions.options;
            }
        }
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.color = color !== null && color !== void 0 ? color : this.color;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.onPreDraw = onPreTransformDraw !== null && onPreTransformDraw !== void 0 ? onPreTransformDraw : this.onPreTransformDraw;
        this.onPostTransformDraw = onPostTransformDraw !== null && onPostTransformDraw !== void 0 ? onPostTransformDraw : this.onPostTransformDraw;
        this.isVisible = !!visible;
        this._current = current !== null && current !== void 0 ? current : this._current;
        if (current && this._graphics[current]) {
            this.use(current);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    getOptions(name) {
        return this._options[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphic
     */
    get current() {
        return this._graphics[this._current];
    }
    /**
     * Returns the currently displayed graphic offsets
     */
    get currentOptions() {
        return this._options[this._current];
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    /**
     * Returns all graphics options associated with this component
     */
    get options() {
        return this._options;
    }
    add(nameOrGraphic, graphicOrOptions, options) {
        let name = 'default';
        let graphicToSet = null;
        let optionsToSet = undefined;
        if (typeof nameOrGraphic === 'string' && graphicOrOptions instanceof _Graphic__WEBPACK_IMPORTED_MODULE_6__.Graphic) {
            name = nameOrGraphic;
            graphicToSet = graphicOrOptions;
            optionsToSet = options;
        }
        if (nameOrGraphic instanceof _Graphic__WEBPACK_IMPORTED_MODULE_6__.Graphic && !(graphicOrOptions instanceof _Graphic__WEBPACK_IMPORTED_MODULE_6__.Graphic)) {
            graphicToSet = nameOrGraphic;
            optionsToSet = graphicOrOptions;
        }
        if (!graphicToSet) {
            throw new Error('Need to provide a graphic or valid graphic string');
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        this._options[name] = this.copyGraphics ? { ...optionsToSet } : optionsToSet;
        if (name === 'default') {
            this.use('default');
        }
        return graphicToSet;
    }
    /**
     * Removes a registered graphic, if the removed graphic is the current it will switch to the default
     * @param name
     */
    remove(name) {
        delete this._graphics[name];
        delete this._options[name];
        if (this._current === name) {
            this._current = 'default';
            this.recalculateBounds();
        }
    }
    /**
     * Use a graphic only, will set the default graphic. Returns the new {@apilink Graphic}
     *
     * Optionally override the stored options
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        var _a;
        if (nameOrGraphic instanceof _Graphic__WEBPACK_IMPORTED_MODULE_6__.Graphic) {
            let graphic = nameOrGraphic;
            if (this.copyGraphics) {
                graphic = nameOrGraphic.clone();
            }
            this._current = 'default';
            this._graphics[this._current] = graphic;
            this._options[this._current] = options;
        }
        else {
            this._current = nameOrGraphic;
            this._options[this._current] = options;
            if (!(this._current in this._graphics)) {
                this._logger.warn(`Graphic ${this._current} is not registered with the graphics component owned by ${(_a = this.owner) === null || _a === void 0 ? void 0 : _a.name}. Nothing will be drawn.`);
            }
        }
        this.recalculateBounds();
        return this.current;
    }
    /**
     * Hide currently shown graphic
     */
    hide() {
        this._current = 'ex.none';
    }
    set localBounds(bounds) {
        this._localBounds = bounds;
    }
    recalculateBounds() {
        let bb = new _Collision_Index__WEBPACK_IMPORTED_MODULE_7__.BoundingBox();
        const graphic = this._graphics[this._current];
        const options = this._options[this._current];
        if (!graphic) {
            this._localBounds = bb;
            return;
        }
        let anchor = this.anchor;
        let offset = this.offset;
        if (options === null || options === void 0 ? void 0 : options.anchor) {
            anchor = options.anchor;
        }
        if (options === null || options === void 0 ? void 0 : options.offset) {
            offset = options.offset;
        }
        const bounds = graphic.localBounds;
        const offsetX = -bounds.width * anchor.x + offset.x;
        const offsetY = -bounds.height * anchor.y + offset.y;
        if (graphic instanceof _Graphics_GraphicsGroup__WEBPACK_IMPORTED_MODULE_8__.GraphicsGroup && !graphic.useAnchor) {
            bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.combine(bb);
        }
        else {
            bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate((0,_Math_vector__WEBPACK_IMPORTED_MODULE_5__.vec)(offsetX, offsetY)).combine(bb);
        }
        this._localBounds = bb;
    }
    /**
     * Get local bounds of graphics component
     */
    get localBounds() {
        if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
            this.recalculateBounds();
        }
        return this._localBounds; // recalc guarantees type
    }
    /**
     * Get world bounds of graphics component
     */
    get bounds() {
        let bounds = this.localBounds;
        if (this.owner) {
            const tx = this.owner.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_9__.TransformComponent);
            if (tx) {
                bounds = bounds.transform(tx.get().matrix);
            }
        }
        return bounds;
    }
    /**
     * Update underlying graphics if necessary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        const graphic = this.current;
        if (graphic && hasGraphicsTick(graphic)) {
            graphic.tick(elapsed, idempotencyToken);
        }
    }
    clone() {
        const graphics = new GraphicsComponent();
        graphics._graphics = { ...this._graphics };
        graphics._options = { ...this._options };
        graphics.offset = this.offset.clone();
        if (this.color) {
            graphics.color = this.color.clone();
        }
        graphics.opacity = this.opacity;
        graphics.anchor = this.anchor.clone();
        graphics.copyGraphics = this.copyGraphics;
        graphics.onPreDraw = this.onPreDraw;
        graphics.onPostDraw = this.onPostDraw;
        graphics.isVisible = this.isVisible;
        return graphics;
    }
}


/***/ }),

/***/ "./Graphics/GraphicsDiagnostics.ts":
/*!*****************************************!*\
  !*** ./Graphics/GraphicsDiagnostics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1089173__) => {

__nested_webpack_require_1089173__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1089173__.d(__nested_webpack_exports__, {
/* harmony export */   GraphicsDiagnostics: () => (/* binding */ GraphicsDiagnostics)
/* harmony export */ });
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;


/***/ }),

/***/ "./Graphics/GraphicsGroup.ts":
/*!***********************************!*\
  !*** ./Graphics/GraphicsGroup.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1089882__) => {

__nested_webpack_require_1089882__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1089882__.d(__nested_webpack_exports__, {
/* harmony export */   GraphicsGroup: () => (/* binding */ GraphicsGroup)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1089882__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1089882__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1089882__(/*! ./Animation */ "./Graphics/Animation.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1089882__(/*! ../Collision/Index */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1089882__(/*! ../Util/Log */ "./Util/Log.ts");





class GraphicsGroup extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        var _a;
        super(options);
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this.useAnchor = true;
        this.members = [];
        this.members = options.members;
        this.useAnchor = (_a = options.useAnchor) !== null && _a !== void 0 ? _a : this.useAnchor;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup({
            members: [...this.members],
            ...this.cloneGraphicOptions()
        });
    }
    _updateDimensions() {
        const bb = this.localBounds;
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        const bb = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();
        for (const member of this.members) {
            if (member instanceof _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic) {
                member.localBounds.combine(bb, bb);
            }
            else {
                const { graphic, offset: pos, useBounds } = member;
                const shouldUseBounds = useBounds === undefined ? true : useBounds;
                if (graphic) {
                    if (shouldUseBounds) {
                        graphic.localBounds.translate(pos).combine(bb, bb);
                    }
                }
                else {
                    this._logger.warnOnce(`Graphics group member has an null or undefined graphic, member definition: ${JSON.stringify(member)}.`);
                }
            }
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof _Animation__WEBPACK_IMPORTED_MODULE_3__.Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsed, idempotencyToken) {
        for (const member of this.members) {
            let graphic;
            if (member instanceof _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
            }
            if (this._isAnimationOrGroup(graphic)) {
                graphic.tick(elapsed, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            let graphic;
            if (member instanceof _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
            }
            if (this._isAnimationOrGroup(graphic)) {
                graphic.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, this.useAnchor ? x : 0, this.useAnchor ? y : 0);
    }
    _drawImage(ex, x, y) {
        const pos = _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.Zero;
        for (const member of this.members) {
            let graphic;
            if (member instanceof _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic) {
                graphic = member;
            }
            else {
                graphic = member.graphic;
                member.offset.clone(pos);
            }
            if (!graphic) {
                continue;
            }
            ex.save();
            ex.translate(x, y);
            graphic.draw(ex, pos.x, pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}


/***/ }),

/***/ "./Graphics/GraphicsSystem.ts":
/*!************************************!*\
  !*** ./Graphics/GraphicsSystem.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1094637__) => {

__nested_webpack_require_1094637__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1094637__.d(__nested_webpack_exports__, {
/* harmony export */   GraphicsSystem: () => (/* binding */ GraphicsSystem)
/* harmony export */ });
/* harmony import */ var _GraphicsComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1094637__(/*! ./GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1094637__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1094637__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1094637__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1094637__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _GraphicsGroup__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1094637__(/*! ./GraphicsGroup */ "./Graphics/GraphicsGroup.ts");
/* harmony import */ var _ParallaxComponent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1094637__(/*! ./ParallaxComponent */ "./Graphics/ParallaxComponent.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1094637__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1094637__(/*! ../Collision/BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _FontCache__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1094637__(/*! ./FontCache */ "./Graphics/FontCache.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1094637__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Math_transform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1094637__(/*! ../Math/transform */ "./Math/transform.ts");
/* harmony import */ var _TransformInterpolation__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1094637__(/*! ./TransformInterpolation */ "./Graphics/TransformInterpolation.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1094637__(/*! ./Graphic */ "./Graphics/Graphic.ts");













class GraphicsSystem extends _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__.System {
    get sortedTransforms() {
        return this._sortedTransforms;
    }
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__.SystemType.Draw;
        this._token = 0;
        this._sortedTransforms = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
        this._targetInterpolationTransform = new _Math_transform__WEBPACK_IMPORTED_MODULE_1__.Transform();
        this.query = this.world.query([_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent, _GraphicsComponent__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent]);
        this.query.entityAdded$.subscribe((e) => {
            const tx = e.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
            this._sortedTransforms.push(tx);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        });
        this.query.entityRemoved$.subscribe((e) => {
            const tx = e.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
            }
        });
    }
    initialize(world, scene) {
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    preupdate() {
        // Graphics context could be switched to fallback in a new frame
        this._graphicsContext = this._engine.graphicsContext;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return a.globalZ - b.globalZ;
            });
            this._zHasChanged = false;
        }
    }
    update(elapsed) {
        this._token++;
        let graphics;
        _FontCache__WEBPACK_IMPORTED_MODULE_4__.FontCache.checkAndClearCache();
        // This is a performance enhancement, most things are in world space
        // so if we can only do this once saves a ton of transform updates
        this._graphicsContext.save();
        if (this._camera) {
            this._camera.draw(this._graphicsContext);
        }
        for (let transformIndex = 0; transformIndex < this._sortedTransforms.length; transformIndex++) {
            const transform = this._sortedTransforms[transformIndex];
            const entity = transform.owner;
            // If the entity is offscreen skip
            if (entity.hasTag('ex.offscreen')) {
                continue;
            }
            graphics = entity.get(_GraphicsComponent__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent);
            // Exit if graphics set to not visible
            if (!graphics.isVisible) {
                continue;
            }
            // Optionally run the onPreTransformDraw graphics lifecycle draw
            if (graphics.onPreTransformDraw) {
                graphics.onPreTransformDraw(this._graphicsContext, elapsed);
            }
            entity.events.emit('pretransformdraw', new _Events__WEBPACK_IMPORTED_MODULE_5__.PreTransformDrawEvent(this._graphicsContext, elapsed, entity));
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.Screen) {
                this._graphicsContext.restore();
            }
            this._graphicsContext.save();
            if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.Screen) {
                this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
            }
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(elapsed, this._token);
            // Apply parallax
            const parallax = entity.get(_ParallaxComponent__WEBPACK_IMPORTED_MODULE_7__.ParallaxComponent);
            if (parallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.One.sub(parallax.parallaxFactor);
                const parallaxOffset = this._camera.drawPos.scale(oneMinusFactor);
                this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);
            }
            // Position the entity + estimate lag
            this._applyTransform(entity);
            // If there is a material enable it on the context
            if (graphics.material) {
                this._graphicsContext.material = graphics.material;
            }
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, elapsed);
            }
            entity.events.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_5__.PreDrawEvent(this._graphicsContext, elapsed, entity));
            // this._graphicsContext.opacity *= graphics.opacity;
            this._applyOpacity(entity);
            // Draw the graphics component
            this._drawGraphicsComponent(graphics, transform);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, elapsed);
            }
            entity.events.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_5__.PostDrawEvent(this._graphicsContext, elapsed, entity));
            this._graphicsContext.restore();
            // Reset the transform back to the original world space
            if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.Screen) {
                this._graphicsContext.save();
                if (this._camera) {
                    this._camera.draw(this._graphicsContext);
                }
            }
            // Optionally run the onPreTransformDraw graphics lifecycle draw
            if (graphics.onPostTransformDraw) {
                graphics.onPostTransformDraw(this._graphicsContext, elapsed);
            }
            entity.events.emit('posttransformdraw', new _Events__WEBPACK_IMPORTED_MODULE_5__.PostTransformDrawEvent(this._graphicsContext, elapsed, entity));
        }
        this._graphicsContext.restore();
    }
    _drawGraphicsComponent(graphicsComponent, transformComponent) {
        var _a, _b;
        if (graphicsComponent.isVisible) {
            const flipHorizontal = graphicsComponent.flipHorizontal;
            const flipVertical = graphicsComponent.flipVertical;
            const graphic = graphicsComponent.current;
            const options = (_a = graphicsComponent.currentOptions) !== null && _a !== void 0 ? _a : {};
            if (graphic) {
                let anchor = graphicsComponent.anchor;
                let offset = graphicsComponent.offset;
                let scaleX = 1;
                let scaleY = 1;
                // handle specific overrides
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const globalScale = transformComponent.globalScale;
                scaleX *= graphic.scale.x * globalScale.x;
                scaleY *= graphic.scale.y * globalScale.y;
                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                const offsetX = -graphic.width * anchor.x + offset.x * scaleX;
                const offsetY = -graphic.height * anchor.y + offset.y * scaleY;
                const oldFlipHorizontal = graphic.flipHorizontal;
                const oldFlipVertical = graphic.flipVertical;
                if (flipHorizontal || flipVertical) {
                    // flip any currently flipped graphics
                    graphic.flipHorizontal = flipHorizontal ? !oldFlipHorizontal : oldFlipHorizontal;
                    graphic.flipVertical = flipVertical ? !oldFlipVertical : oldFlipVertical;
                }
                graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX, offsetY);
                if (flipHorizontal || flipVertical) {
                    graphic.flipHorizontal = oldFlipHorizontal;
                    graphic.flipVertical = oldFlipVertical;
                }
                // TODO move debug code out?
                if (((_b = this._engine) === null || _b === void 0 ? void 0 : _b.isDebug) && this._engine.debug.graphics.showBounds) {
                    const offset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_8__.vec)(offsetX, offsetY);
                    if (graphic instanceof _GraphicsGroup__WEBPACK_IMPORTED_MODULE_9__.GraphicsGroup) {
                        for (const member of graphic.members) {
                            let g;
                            let pos = _Math_vector__WEBPACK_IMPORTED_MODULE_8__.Vector.Zero;
                            if (member instanceof _Graphic__WEBPACK_IMPORTED_MODULE_10__.Graphic) {
                                g = member;
                            }
                            else {
                                g = member.graphic;
                                pos = member.offset;
                            }
                            if (graphic.useAnchor) {
                                g === null || g === void 0 ? void 0 : g.localBounds.translate(offset.add(pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                            else {
                                g === null || g === void 0 ? void 0 : g.localBounds.translate(pos).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                    }
                    else {
                        /* istanbul ignore next */
                        graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (let i = 0; i < ancestors.length; i++) {
            const ancestor = ancestors[i];
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
            const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(_Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_11__.BodyComponent);
            if (transform) {
                let tx = transform.get();
                if (optionalBody) {
                    if (this._engine.fixedUpdateTimestep && optionalBody.__oldTransformCaptured && optionalBody.enableFixedUpdateInterpolate) {
                        // Interpolate graphics if needed
                        const blend = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep;
                        tx = (0,_TransformInterpolation__WEBPACK_IMPORTED_MODULE_12__.blendTransform)(optionalBody.oldTransform, transform.get(), blend, this._targetInterpolationTransform);
                    }
                }
                this._graphicsContext.z = transform.globalZ;
                this._graphicsContext.translate(tx.pos.x, tx.pos.y);
                this._graphicsContext.scale(tx.scale.x, tx.scale.y);
                this._graphicsContext.rotate(tx.rotation);
            }
        }
    }
    _applyOpacity(entity) {
        var _a;
        const ancestors = entity.getAncestors();
        for (let i = 0; i < ancestors.length; i++) {
            const ancestor = ancestors[i];
            const maybeGraphics = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(_GraphicsComponent__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent);
            this._graphicsContext.opacity *= (_a = maybeGraphics === null || maybeGraphics === void 0 ? void 0 : maybeGraphics.opacity) !== null && _a !== void 0 ? _a : 1;
        }
    }
}
GraphicsSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_13__.SystemPriority.Average;


/***/ }),

/***/ "./Graphics/ImageSource.ts":
/*!*********************************!*\
  !*** ./Graphics/ImageSource.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1110314__) => {

__nested_webpack_require_1110314__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1110314__.d(__nested_webpack_exports__, {
/* harmony export */   ImageSource: () => (/* binding */ ImageSource),
/* harmony export */   ImageSourceAttributeConstants: () => (/* binding */ ImageSourceAttributeConstants)
/* harmony export */ });
/* harmony import */ var _Resources_Resource__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1110314__(/*! ../Resources/Resource */ "./Resources/Resource.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1110314__(/*! ./Sprite */ "./Graphics/Sprite.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1110314__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1110314__(/*! ./Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1110314__(/*! ../Util/Future */ "./Util/Future.ts");
/* harmony import */ var _Graphics_Context_texture_loader__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1110314__(/*! ../Graphics/Context/texture-loader */ "./Graphics/Context/texture-loader.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1110314__(/*! ./Wrapping */ "./Graphics/Wrapping.ts");







const ImageSourceAttributeConstants = {
    Filtering: 'filtering',
    WrappingX: 'wrapping-x',
    WrappingY: 'wrapping-y'
};
class ImageSource {
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        if (!this._src) {
            // this boosts speed of access
            this._src = this.data.src;
        }
        return !!this._src;
    }
    get image() {
        return this.data;
    }
    constructor(pathOrBase64, bustCacheOrOptions, filtering) {
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        /**
         * Access to the underlying html image element
         */
        this.data = new Image();
        this._readyFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_1__.Future();
        /**
         * Promise the resolves when the image is loaded and ready for use, does not initiate loading
         */
        this.ready = this._readyFuture.promise;
        this.path = pathOrBase64;
        let bustCache = false;
        let wrapping;
        if (typeof bustCacheOrOptions === 'boolean') {
            bustCache = bustCacheOrOptions;
        }
        else {
            ({ filtering, wrapping, bustCache } = { ...bustCacheOrOptions });
        }
        this._resource = new _Resources_Resource__WEBPACK_IMPORTED_MODULE_2__.Resource(pathOrBase64, 'blob', bustCache);
        this.filtering = filtering !== null && filtering !== void 0 ? filtering : this.filtering;
        if (typeof wrapping === 'string') {
            this.wrapping = {
                x: wrapping,
                y: wrapping
            };
        }
        else {
            this.wrapping = wrapping !== null && wrapping !== void 0 ? wrapping : this.wrapping;
        }
        if (pathOrBase64.endsWith('.gif')) {
            this._logger.warn(`Use the ex.Gif type to load gifs, you may have mixed results with ${pathOrBase64} in ex.ImageSource. Fully supported: svg, jpg, bmp, and png`);
        }
    }
    /**
     * Create an ImageSource from and HTML <image> tag element
     * @param image
     */
    static fromHtmlImageElement(image, options) {
        const imageSource = new ImageSource('');
        imageSource._src = 'image-element';
        imageSource.data = image;
        imageSource.data.setAttribute('data-original-src', 'image-element');
        if (options === null || options === void 0 ? void 0 : options.filtering) {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, options === null || options === void 0 ? void 0 : options.filtering);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, _Filtering__WEBPACK_IMPORTED_MODULE_3__.ImageFiltering.Blended);
        }
        if (options === null || options === void 0 ? void 0 : options.wrapping) {
            let wrapping;
            if (typeof options.wrapping === 'string') {
                wrapping = {
                    x: options.wrapping,
                    y: options.wrapping
                };
            }
            else {
                wrapping = {
                    x: options.wrapping.x,
                    y: options.wrapping.y
                };
            }
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, wrapping.x);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, wrapping.y);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
        }
        _Graphics_Context_texture_loader__WEBPACK_IMPORTED_MODULE_5__.TextureLoader.checkImageSizeSupportedAndLog(image);
        imageSource._readyFuture.resolve(image);
        return imageSource;
    }
    static fromHtmlCanvasElement(image, options) {
        const imageSource = new ImageSource('');
        imageSource._src = 'canvas-element-blob';
        imageSource.data.setAttribute('data-original-src', 'canvas-element-blob');
        if (options === null || options === void 0 ? void 0 : options.filtering) {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, options === null || options === void 0 ? void 0 : options.filtering);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, _Filtering__WEBPACK_IMPORTED_MODULE_3__.ImageFiltering.Blended);
        }
        if (options === null || options === void 0 ? void 0 : options.wrapping) {
            let wrapping;
            if (typeof options.wrapping === 'string') {
                wrapping = {
                    x: options.wrapping,
                    y: options.wrapping
                };
            }
            else {
                wrapping = {
                    x: options.wrapping.x,
                    y: options.wrapping.y
                };
            }
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, wrapping.x);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, wrapping.y);
        }
        else {
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
            imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
        }
        _Graphics_Context_texture_loader__WEBPACK_IMPORTED_MODULE_5__.TextureLoader.checkImageSizeSupportedAndLog(image);
        image.toBlob((blob) => {
            // TODO throw? if blob null?
            const url = URL.createObjectURL(blob);
            imageSource.image.onload = () => {
                // no longer need to read the blob so it's revoked
                URL.revokeObjectURL(url);
                imageSource.data = imageSource.image;
                imageSource._readyFuture.resolve(imageSource.image);
            };
            imageSource.image.src = url;
        });
        return imageSource;
    }
    static fromSvgString(svgSource, options) {
        const blob = new Blob([svgSource], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        return new ImageSource(url, options);
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
        return this._resource.bustCache;
    }
    set bustCache(val) {
        this._resource.bustCache = val;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    async load() {
        var _a, _b, _c, _d;
        if (this.isLoaded()) {
            return this.data;
        }
        try {
            // Load base64 or blob if needed
            let url;
            if (!this.path.includes('data:image/')) {
                const blob = await this._resource.load();
                url = URL.createObjectURL(blob);
            }
            else {
                url = this.path;
            }
            // Decode the image
            const image = new Image();
            // Use Image.onload over Image.decode()
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7
            // Otherwise chrome will throw still Image.decode() failures for large textures
            const loadedFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_1__.Future();
            image.onload = () => loadedFuture.resolve();
            image.src = url;
            image.setAttribute('data-original-src', this.path);
            await loadedFuture.promise;
            // Set results
            // We defer loading the texture into webgl until the first draw that way we avoid a singleton
            // and for the multi-engine case the texture needs to be created in EACH webgl context to work
            // See image-renderer.ts draw()
            this.data = image;
            // emit warning if potentially too big
            _Graphics_Context_texture_loader__WEBPACK_IMPORTED_MODULE_5__.TextureLoader.checkImageSizeSupportedAndLog(this.data);
        }
        catch (error) {
            throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
        }
        // Do a bad thing to pass the filtering as an attribute
        this.data.setAttribute(ImageSourceAttributeConstants.Filtering, this.filtering); // TODO fix type
        this.data.setAttribute(ImageSourceAttributeConstants.WrappingX, (_b = (_a = this.wrapping) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
        this.data.setAttribute(ImageSourceAttributeConstants.WrappingY, (_d = (_c = this.wrapping) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : _Wrapping__WEBPACK_IMPORTED_MODULE_4__.ImageWrapping.Clamp);
        // todo emit complete
        this._readyFuture.resolve(this.data);
        return this.data;
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite(options) {
        return _Sprite__WEBPACK_IMPORTED_MODULE_6__.Sprite.from(this, options);
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}


/***/ }),

/***/ "./Graphics/Line.ts":
/*!**************************!*\
  !*** ./Graphics/Line.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1121639__) => {

__nested_webpack_require_1121639__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1121639__.d(__nested_webpack_exports__, {
/* harmony export */   Line: () => (/* binding */ Line)
/* harmony export */ });
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1121639__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1121639__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1121639__(/*! ./Graphic */ "./Graphics/Graphic.ts");



class Line extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        super();
        this.color = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.Black;
        this.thickness = 1;
        const { start, end, color, thickness } = options;
        this.start = start;
        this.end = end;
        this.color = color !== null && color !== void 0 ? color : this.color;
        this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;
        this._localBounds = this._calculateBounds();
        const { width, height } = this._localBounds;
        this.width = width;
        this.height = height;
    }
    get localBounds() {
        return this._localBounds;
    }
    _calculateBounds() {
        const lineNormal = this.end.sub(this.start).normal();
        const halfThickness = this.thickness / 2;
        const points = [
            this.start.add(lineNormal.scale(halfThickness)),
            this.end.add(lineNormal.scale(halfThickness)),
            this.end.add(lineNormal.scale(-halfThickness)),
            this.start.add(lineNormal.scale(-halfThickness))
        ];
        return _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromPoints(points);
    }
    _drawImage(ctx, _x, _y) {
        ctx.drawLine(this.start, this.end, this.color, this.thickness);
    }
    clone() {
        return new Line({
            start: this.start,
            end: this.end,
            color: this.color,
            thickness: this.thickness
        });
    }
}


/***/ }),

/***/ "./Graphics/NineSlice.ts":
/*!*******************************!*\
  !*** ./Graphics/NineSlice.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1124017__) => {

__nested_webpack_require_1124017__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1124017__.d(__nested_webpack_exports__, {
/* harmony export */   NineSlice: () => (/* binding */ NineSlice),
/* harmony export */   NineSliceStretch: () => (/* binding */ NineSliceStretch)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1124017__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1124017__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1124017__(/*! ../Math/vector */ "./Math/vector.ts");



/**
 * Nine slice stretch mode
 */
var NineSliceStretch;
(function (NineSliceStretch) {
    /**
     * Stretch the image across a dimension
     */
    NineSliceStretch["Stretch"] = "stretch";
    /**
     * Tile the image across a dimension
     */
    NineSliceStretch["Tile"] = "tile";
    /**
     * Tile the image across a dimension but only by whole image amounts
     */
    NineSliceStretch["TileFit"] = "tile-fit";
})(NineSliceStretch || (NineSliceStretch = {}));
class NineSlice extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(config) {
        super(config);
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._config = config;
        this._imgSource = config.source;
        this._canvasA = document.createElement('canvas');
        this._canvasB = document.createElement('canvas');
        this._canvasC = document.createElement('canvas');
        this._canvasD = document.createElement('canvas');
        this._canvasE = document.createElement('canvas');
        this._canvasF = document.createElement('canvas');
        this._canvasG = document.createElement('canvas');
        this._canvasH = document.createElement('canvas');
        this._canvasI = document.createElement('canvas');
        this._initialize();
        this._imgSource.ready.then(() => {
            this._initialize();
        });
    }
    /**
     * Sets the target width of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
     * @param newWidth
     * @param auto
     */
    setTargetWidth(newWidth, auto = false) {
        this._config.width = newWidth;
        if (auto) {
            this._initialize();
        }
    }
    /**
     * Sets the target height of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
     * @param newHeight
     * @param auto
     */
    setTargetHeight(newHeight, auto = false) {
        this._config.height = newHeight;
        if (auto) {
            this._initialize();
        }
    }
    /**
     *  Sets the 9 slice margins (pixels), and recalculates the 9 slice if desired (auto)
     */
    setMargins(left, top, right, bottom, auto = false) {
        this._config.sourceConfig.leftMargin = left;
        this._config.sourceConfig.topMargin = top;
        this._config.sourceConfig.rightMargin = right;
        this._config.sourceConfig.bottomMargin = bottom;
        if (auto) {
            this._initialize();
        }
    }
    /**
     *  Sets the stretching strategy for the 9 slice, and recalculates the 9 slice if desired (auto)
     *
     */
    setStretch(type, stretch, auto = false) {
        if (type === 'horizontal') {
            this._config.destinationConfig.horizontalStretch = stretch;
        }
        else if (type === 'vertical') {
            this._config.destinationConfig.verticalStretch = stretch;
        }
        else {
            this._config.destinationConfig.horizontalStretch = stretch;
            this._config.destinationConfig.verticalStretch = stretch;
        }
        if (auto) {
            this._initialize();
        }
    }
    /**
     *  Returns the config of the 9 slice
     */
    getConfig() {
        return this._config;
    }
    /**
     * Draws 1 of the 9 tiles based on parameters passed in
     * context is the ExcaliburGraphicsContext from the _drawImage function
     * destinationSize is the size of the destination image as a vector (width,height)
     * targetCanvas is the canvas to draw to
     * horizontalStretch and verticalStretch are the horizontal and vertical stretching strategies
     * marginW and marginH are optional margins for the 9 slice for positioning
     * @param context
     * @param targetCanvas
     * @param destinationSize
     * @param horizontalStretch
     * @param verticalStretch
     * @param marginWidth
     * @param marginHeight
     */
    _drawTile(context, targetCanvas, destinationSize, horizontalStretch, verticalStretch, marginWidth, marginHeight) {
        const tempMarginW = marginWidth || 0;
        const tempMarginH = marginHeight || 0;
        let tempSizeX, tempPositionX, tempSizeY, tempPositionY;
        const numTilesX = this._getNumberOfTiles(targetCanvas.width, destinationSize.x, horizontalStretch);
        const numTilesY = this._getNumberOfTiles(targetCanvas.height, destinationSize.y, verticalStretch);
        for (let i = 0; i < numTilesX; i++) {
            for (let j = 0; j < numTilesY; j++) {
                let { tempSize, tempPosition } = this._calculateParams(i, numTilesX, targetCanvas.width, destinationSize.x, this._config.destinationConfig.horizontalStretch);
                tempSizeX = tempSize;
                tempPositionX = tempPosition;
                ({ tempSize, tempPosition } = this._calculateParams(j, numTilesY, targetCanvas.height, destinationSize.y, this._config.destinationConfig.verticalStretch));
                tempSizeY = tempSize;
                tempPositionY = tempPosition;
                context.drawImage(targetCanvas, 0, 0, targetCanvas.width, targetCanvas.height, tempMarginW + tempPositionX, tempMarginH + tempPositionY, tempSizeX, tempSizeY);
            }
        }
    }
    /**
     *  Draws the 9 slices to the canvas
     */
    _drawImage(ex, x, y) {
        if (this._imgSource.isLoaded()) {
            // Top left, no stretching
            this._drawTile(ex, this._canvasA, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.leftMargin, this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch);
            // Top, middle, horizontal stretching
            this._drawTile(ex, this._canvasB, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.sourceConfig.leftMargin, 0);
            // Top right, no stretching
            this._drawTile(ex, this._canvasC, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.width - this._config.sourceConfig.rightMargin, 0);
            // middle, left, vertical stretching
            this._drawTile(ex, this._canvasD, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.leftMargin, this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, 0, this._config.sourceConfig.topMargin);
            // center, both stretching
            if (this._config.destinationConfig.drawCenter) {
                this._drawTile(ex, this._canvasE, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.sourceConfig.leftMargin, this._config.sourceConfig.topMargin);
            }
            // middle, right, vertical stretching
            this._drawTile(ex, this._canvasF, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.rightMargin, this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.width - this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin);
            // bottom left, no stretching
            this._drawTile(ex, this._canvasG, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.leftMargin, this._config.sourceConfig.bottomMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, 0, this._config.height - this._config.sourceConfig.bottomMargin);
            // bottom middle, horizontal stretching
            this._drawTile(ex, this._canvasH, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._config.sourceConfig.bottomMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.sourceConfig.leftMargin, this._config.height - this._config.sourceConfig.bottomMargin);
            // bottom right, no stretching
            this._drawTile(ex, this._canvasI, new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._config.sourceConfig.rightMargin, this._config.sourceConfig.bottomMargin), this._config.destinationConfig.horizontalStretch, this._config.destinationConfig.verticalStretch, this._config.width - this._config.sourceConfig.rightMargin, this._config.height - this._config.sourceConfig.bottomMargin);
        }
        else {
            this._logger.warnOnce(`NineSlice ImageSource ${this._imgSource.path}` +
                ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\n\n` +
                `Read https://excaliburjs.com/docs/imagesource for more information.`);
        }
    }
    /**
     * Slices the source sprite into the 9 slice canvases internally
     */
    _initialize() {
        this._sourceSprite = this._imgSource.image;
        // top left slice
        this._canvasA.width = this._config.sourceConfig.leftMargin;
        this._canvasA.height = this._config.sourceConfig.topMargin;
        const aCtx = this._canvasA.getContext('2d');
        aCtx === null || aCtx === void 0 ? void 0 : aCtx.drawImage(this._sourceSprite, 0, 0, this._canvasA.width, this._canvasA.height, 0, 0, this._canvasA.width, this._canvasA.height);
        // top slice
        this._canvasB.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
        this._canvasB.height = this._config.sourceConfig.topMargin;
        const bCtx = this._canvasB.getContext('2d');
        bCtx === null || bCtx === void 0 ? void 0 : bCtx.drawImage(this._sourceSprite, this._config.sourceConfig.leftMargin, 0, this._canvasB.width, this._canvasB.height, 0, 0, this._canvasB.width, this._canvasB.height);
        // top right slice
        this._canvasC.width = this._config.sourceConfig.rightMargin;
        this._canvasC.height = this._config.sourceConfig.topMargin;
        const cCtx = this._canvasC.getContext('2d');
        cCtx === null || cCtx === void 0 ? void 0 : cCtx.drawImage(this._sourceSprite, this._sourceSprite.width - this._config.sourceConfig.rightMargin, 0, this._canvasC.width, this._canvasC.height, 0, 0, this._canvasC.width, this._canvasC.height);
        // middle left slice
        this._canvasD.width = this._config.sourceConfig.leftMargin;
        this._canvasD.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
        const dCtx = this._canvasD.getContext('2d');
        dCtx === null || dCtx === void 0 ? void 0 : dCtx.drawImage(this._sourceSprite, 0, this._config.sourceConfig.topMargin, this._canvasD.width, this._canvasD.height, 0, 0, this._canvasD.width, this._canvasD.height);
        // middle slice
        this._canvasE.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
        this._canvasE.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
        const eCtx = this._canvasE.getContext('2d');
        eCtx === null || eCtx === void 0 ? void 0 : eCtx.drawImage(this._sourceSprite, this._config.sourceConfig.leftMargin, this._config.sourceConfig.topMargin, this._canvasE.width, this._canvasE.height, 0, 0, this._canvasE.width, this._canvasE.height);
        // middle right slice
        this._canvasF.width = this._config.sourceConfig.rightMargin;
        this._canvasF.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
        const fCtx = this._canvasF.getContext('2d');
        fCtx === null || fCtx === void 0 ? void 0 : fCtx.drawImage(this._sourceSprite, this._config.sourceConfig.width - this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin, this._canvasF.width, this._canvasF.height, 0, 0, this._canvasF.width, this._canvasF.height);
        // bottom left slice
        this._canvasG.width = this._config.sourceConfig.leftMargin;
        this._canvasG.height = this._config.sourceConfig.bottomMargin;
        const gCtx = this._canvasG.getContext('2d');
        gCtx === null || gCtx === void 0 ? void 0 : gCtx.drawImage(this._sourceSprite, 0, this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin, this._canvasG.width, this._canvasG.height, 0, 0, this._canvasG.width, this._canvasG.height);
        // bottom slice
        this._canvasH.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
        this._canvasH.height = this._config.sourceConfig.bottomMargin;
        const hCtx = this._canvasH.getContext('2d');
        hCtx === null || hCtx === void 0 ? void 0 : hCtx.drawImage(this._sourceSprite, this._config.sourceConfig.leftMargin, this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin, this._canvasH.width, this._canvasH.height, 0, 0, this._canvasH.width, this._canvasH.height);
        // bottom right slice
        this._canvasI.width = this._config.sourceConfig.rightMargin;
        this._canvasI.height = this._config.sourceConfig.bottomMargin;
        const iCtx = this._canvasI.getContext('2d');
        iCtx === null || iCtx === void 0 ? void 0 : iCtx.drawImage(this._sourceSprite, this._sourceSprite.width - this._config.sourceConfig.rightMargin, this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin, this._canvasI.width, this._canvasI.height, 0, 0, this._canvasI.width, this._canvasI.height);
    }
    /**
     * Clones the 9 slice
     */
    clone() {
        return new NineSlice(this._config);
    }
    /**
     * Returns the number of tiles
     */
    _getNumberOfTiles(tileSize, destinationSize, strategy) {
        switch (strategy) {
            case NineSliceStretch.Stretch:
                return 1;
            case NineSliceStretch.Tile:
                return Math.ceil(destinationSize / tileSize);
            case NineSliceStretch.TileFit:
                return Math.ceil(destinationSize / tileSize);
        }
    }
    /**
     * Returns the position and size of the tile
     */
    _calculateParams(tileNum, numTiles, tileSize, destinationSize, strategy) {
        switch (strategy) {
            case NineSliceStretch.Stretch:
                return {
                    tempPosition: 0,
                    tempSize: destinationSize
                };
            case NineSliceStretch.Tile:
                // if last tile, adjust size
                if (tileNum === numTiles - 1) {
                    //last tile
                    return {
                        tempPosition: tileNum * tileSize,
                        tempSize: tileSize - (numTiles * tileSize - destinationSize)
                    };
                }
                else {
                    return {
                        tempPosition: tileNum * tileSize,
                        tempSize: tileSize
                    };
                }
            case NineSliceStretch.TileFit:
                const reducedTileSize = destinationSize / numTiles;
                const position = tileNum * reducedTileSize;
                return {
                    tempPosition: position,
                    tempSize: reducedTileSize
                };
        }
    }
}


/***/ }),

/***/ "./Graphics/OffscreenSystem.ts":
/*!*************************************!*\
  !*** ./Graphics/OffscreenSystem.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1141150__) => {

__nested_webpack_require_1141150__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1141150__.d(__nested_webpack_exports__, {
/* harmony export */   OffscreenSystem: () => (/* binding */ OffscreenSystem)
/* harmony export */ });
/* harmony import */ var _GraphicsComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1141150__(/*! ./GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1141150__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1141150__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1141150__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _ParallaxComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1141150__(/*! ./ParallaxComponent */ "./Graphics/ParallaxComponent.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1141150__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1141150__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1141150__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");








class OffscreenSystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Draw;
        this.query = this.world.query([_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent, _GraphicsComponent__WEBPACK_IMPORTED_MODULE_2__.GraphicsComponent]);
    }
    initialize(world, scene) {
        this._camera = scene.camera;
        this._screen = scene.engine.screen;
    }
    update() {
        this._worldBounds = this._screen.getWorldBounds();
        let transform;
        let graphics;
        let maybeParallax;
        for (let i = 0; i < this.query.entities.length; i++) {
            const entity = this.query.entities[i];
            graphics = entity.get(_GraphicsComponent__WEBPACK_IMPORTED_MODULE_2__.GraphicsComponent);
            transform = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
            maybeParallax = entity.get(_ParallaxComponent__WEBPACK_IMPORTED_MODULE_3__.ParallaxComponent);
            let parallaxOffset;
            if (maybeParallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector.One.sub(maybeParallax.parallaxFactor);
                parallaxOffset = this._camera.pos.scale(oneMinusFactor);
            }
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
            if (entityOffscreen && !entity.hasTag('ex.offscreen')) {
                entity.events.emit('exitviewport', new _Events__WEBPACK_IMPORTED_MODULE_5__.ExitViewPortEvent(entity));
                entity.addTag('ex.offscreen');
            }
            if (!entityOffscreen && entity.hasTag('ex.offscreen')) {
                entity.events.emit('enterviewport', new _Events__WEBPACK_IMPORTED_MODULE_5__.EnterViewPortEvent(entity));
                entity.removeTag('ex.offscreen');
            }
        }
    }
    _isOffscreen(transform, graphics, parallaxOffset) {
        if (graphics.forceOnScreen) {
            return false;
        }
        if (transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_6__.CoordPlane.World) {
            let bounds = graphics.localBounds;
            if (parallaxOffset) {
                bounds = bounds.translate(parallaxOffset);
            }
            const transformedBounds = bounds.transform(transform.get().matrix);
            const graphicsOffscreen = !this._worldBounds.overlaps(transformedBounds);
            return graphicsOffscreen;
        }
        else {
            // TODO screen coordinates
            return false;
        }
    }
}
OffscreenSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_7__.SystemPriority.Higher;


/***/ }),

/***/ "./Graphics/ParallaxComponent.ts":
/*!***************************************!*\
  !*** ./Graphics/ParallaxComponent.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1146107__) => {

__nested_webpack_require_1146107__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1146107__.d(__nested_webpack_exports__, {
/* harmony export */   ParallaxComponent: () => (/* binding */ ParallaxComponent)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1146107__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1146107__(/*! ../Math/vector */ "./Math/vector.ts");


class ParallaxComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(parallaxFactor) {
        super();
        this.parallaxFactor = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1.0, 1.0);
        this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;
    }
}


/***/ }),

/***/ "./Graphics/Polygon.ts":
/*!*****************************!*\
  !*** ./Graphics/Polygon.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1147258__) => {

__nested_webpack_require_1147258__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1147258__.d(__nested_webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1147258__(/*! ./Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1147258__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1147258__(/*! ./Raster */ "./Graphics/Raster.ts");



/**
 * A polygon {@apilink Graphic} for drawing arbitrary polygons to the {@apilink ExcaliburGraphicsContext}
 *
 * Polygons default to {@apilink ImageFiltering.Blended}
 */
class Polygon extends _Raster__WEBPACK_IMPORTED_MODULE_0__.Raster {
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(minX, minY);
    }
    constructor(options) {
        super(options);
        this._points = [];
        this.points = options.points;
        this.filtering = _Filtering__WEBPACK_IMPORTED_MODULE_2__.ImageFiltering.Blended;
        this.rasterize();
    }
    clone() {
        return new Polygon({
            points: this.points.map((p) => p.clone()),
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}


/***/ }),

/***/ "./Graphics/PostProcessor/ColorBlindnessMode.ts":
/*!******************************************************!*\
  !*** ./Graphics/PostProcessor/ColorBlindnessMode.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1150182__) => {

__nested_webpack_require_1150182__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1150182__.d(__nested_webpack_exports__, {
/* harmony export */   ColorBlindnessMode: () => (/* binding */ ColorBlindnessMode)
/* harmony export */ });
var ColorBlindnessMode;
(function (ColorBlindnessMode) {
    ColorBlindnessMode["Protanope"] = "Protanope";
    ColorBlindnessMode["Deuteranope"] = "Deuteranope";
    ColorBlindnessMode["Tritanope"] = "Tritanope";
})(ColorBlindnessMode || (ColorBlindnessMode = {}));


/***/ }),

/***/ "./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts":
/*!***************************************************************!*\
  !*** ./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1151033__) => {

__nested_webpack_require_1151033__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1151033__.d(__nested_webpack_exports__, {
/* harmony export */   ColorBlindnessPostProcessor: () => (/* binding */ ColorBlindnessPostProcessor)
/* harmony export */ });
/* harmony import */ var _color_blind_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1151033__(/*! ./color-blind-fragment.glsl */ "./Graphics/PostProcessor/color-blind-fragment.glsl");
/* harmony import */ var _ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1151033__(/*! ./ColorBlindnessMode */ "./Graphics/PostProcessor/ColorBlindnessMode.ts");
/* harmony import */ var _ScreenShader__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1151033__(/*! ./ScreenShader */ "./Graphics/PostProcessor/ScreenShader.ts");



class ColorBlindnessPostProcessor {
    constructor(_colorBlindnessMode, simulate = false) {
        this._colorBlindnessMode = _colorBlindnessMode;
        this._simulate = false;
        this._simulate = simulate;
    }
    initialize(gl) {
        this._shader = new _ScreenShader__WEBPACK_IMPORTED_MODULE_0__.ScreenShader(gl, _color_blind_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.simulate = this._simulate;
        this.colorBlindnessMode = this._colorBlindnessMode;
    }
    getShader() {
        return this._shader.getShader();
    }
    getLayout() {
        return this._shader.getLayout();
    }
    set colorBlindnessMode(colorBlindMode) {
        this._colorBlindnessMode = colorBlindMode;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            if (this._colorBlindnessMode === _ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_2__.ColorBlindnessMode.Protanope) {
                shader.setUniformInt('u_type', 0);
            }
            else if (this._colorBlindnessMode === _ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_2__.ColorBlindnessMode.Deuteranope) {
                shader.setUniformInt('u_type', 1);
            }
            else if (this._colorBlindnessMode === _ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_2__.ColorBlindnessMode.Tritanope) {
                shader.setUniformInt('u_type', 2);
            }
        }
    }
    get colorBlindnessMode() {
        return this._colorBlindnessMode;
    }
    set simulate(value) {
        this._simulate = value;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            shader.setUniformBoolean('u_simulate', value);
        }
    }
    get simulate() {
        return this._simulate;
    }
}


/***/ }),

/***/ "./Graphics/PostProcessor/ScreenShader.ts":
/*!************************************************!*\
  !*** ./Graphics/PostProcessor/ScreenShader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1153920__) => {

__nested_webpack_require_1153920__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1153920__.d(__nested_webpack_exports__, {
/* harmony export */   ScreenShader: () => (/* binding */ ScreenShader)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1153920__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Context_shader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1153920__(/*! ../Context/shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _Context_vertex_buffer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1153920__(/*! ../Context/vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _Context_vertex_layout__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1153920__(/*! ../Context/vertex-layout */ "./Graphics/Context/vertex-layout.ts");




/**
 * Helper that defines a whole screen renderer, just provide a fragment source!
 *
 * Currently supports 1 varying
 * - vec2 a_texcoord between 0-1 which corresponds to screen position
 */
class ScreenShader {
    constructor(gl, fragmentSource) {
        if (true) {
            if (fragmentSource.includes('v_texcoord')) {
                _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance().warn(`ScreenShader: "v_texcoord" is deprecated in postprocessing fragment shaders will be removed in v1.0,` +
                    ` use "v_uv" instead. Source [${fragmentSource}]`);
            }
        }
        this._shader = new _Context_shader__WEBPACK_IMPORTED_MODULE_1__.Shader({
            gl,
            vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_uv;
      out vec2 v_texcoord;
      out vec2 v_uv;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_uv;
        v_uv = a_uv;
      }`,
            fragmentSource: fragmentSource
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new _Context_vertex_buffer__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer({
            gl,
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0, -1, 1, 0, 1, 1, -1, 1, 0,
                1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1
            ])
        });
        this._layout = new _Context_vertex_layout__WEBPACK_IMPORTED_MODULE_3__.VertexLayout({
            gl,
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2]
            ]
        });
        this._buffer.upload();
    }
    getShader() {
        return this._shader;
    }
    getLayout() {
        return this._layout;
    }
}


/***/ }),

/***/ "./Graphics/Raster.ts":
/*!****************************!*\
  !*** ./Graphics/Raster.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1156950__) => {

__nested_webpack_require_1156950__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1156950__.d(__nested_webpack_exports__, {
/* harmony export */   Raster: () => (/* binding */ Raster)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1156950__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1156950__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1156950__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1156950__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Watch__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1156950__(/*! ../Util/Watch */ "./Util/Watch.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1156950__(/*! ../Util/Util */ "./Util/Util.ts");






/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * {@apilink ExcaliburGraphicsContext}. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implement the {@apilink Raster.execute} method to rasterize their drawing.
 */
class Raster extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super((0,_Util_Util__WEBPACK_IMPORTED_MODULE_1__.omit)({ ...options }, ['width', 'height'])); // rasters do some special sauce with width/height
        this.lineCap = 'butt';
        this.quality = 1;
        this._dirty = true;
        this._smoothing = false;
        this._color = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(_Color__WEBPACK_IMPORTED_MODULE_3__.Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;
            this.color = (_b = options.color) !== null && _b !== void 0 ? _b : _Color__WEBPACK_IMPORTED_MODULE_3__.Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;
            this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;
            this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
            this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;
            this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;
            this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;
        const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;
        this.width = bitmapWidth;
        this.height = bitmapHeight;
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : undefined,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : undefined,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            lineCap: this.lineCap,
            quality: this.quality,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputted drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s or `quality` set will be factored into the width
     */
    get width() {
        return Math.abs(this._getTotalWidth() * this.scale.x);
    }
    set width(value) {
        value /= Math.abs(this.scale.x);
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` or `quality` set will be factored into the height
     */
    get height() {
        return Math.abs(this._getTotalHeight() * this.scale.y);
    }
    set height(value) {
        value /= Math.abs(this.scale.y);
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;
    }
    _getTotalHeight() {
        var _a;
        return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_4__.BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, _Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        this.flagDirty();
        this._color = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        this.flagDirty();
        if (value) {
            this._strokeColor = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_2__.watch)(value, () => this.flagDirty());
        }
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
     * the graphic is {@apilink Raster.dirty} on the next {@apilink Graphic.draw} call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperties(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
    }
    _applyRasterProperties(ctx) {
        var _a, _b, _c, _d;
        this._bitmap.width = this._getTotalWidth() * this.quality;
        this._bitmap.height = this._getTotalHeight() * this.quality;
        // Do a bad thing to pass the filtering as an attribute
        this._bitmap.setAttribute('filtering', this.filtering);
        this._bitmap.setAttribute('forceUpload', 'true');
        ctx.scale(this.quality, this.quality);
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.lineCap = this.lineCap;
        ctx.strokeStyle = (_c = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '';
        ctx.fillStyle = (_d = this.color) === null || _d === void 0 ? void 0 : _d.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.scale(1 / this.quality, 1 / this.quality);
        ex.drawImage(this._bitmap, x, y);
    }
}


/***/ }),

/***/ "./Graphics/Rectangle.ts":
/*!*******************************!*\
  !*** ./Graphics/Rectangle.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1166938__) => {

__nested_webpack_require_1166938__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1166938__.d(__nested_webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle)
/* harmony export */ });
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1166938__(/*! ./Raster */ "./Graphics/Raster.ts");

/**
 * A Rectangle {@apilink Graphic} for drawing rectangles to the {@apilink ExcaliburGraphicsContext}
 */
class Rectangle extends _Raster__WEBPACK_IMPORTED_MODULE_0__.Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle({
            width: this.width,
            height: this.height,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}


/***/ }),

/***/ "./Graphics/Sprite.ts":
/*!****************************!*\
  !*** ./Graphics/Sprite.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1168257__) => {

__nested_webpack_require_1168257__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1168257__.d(__nested_webpack_exports__, {
/* harmony export */   Sprite: () => (/* binding */ Sprite)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1168257__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1168257__(/*! ../Util/Log */ "./Util/Log.ts");


class Sprite extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    static from(image, options) {
        return new Sprite({
            image,
            ...options
        });
    }
    constructor(options) {
        var _a, _b;
        super(options);
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._dirty = true;
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        // Fire when loaded
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    get width() {
        return Math.abs(this.destSize.width * this.scale.x);
    }
    get height() {
        return Math.abs(this.destSize.height * this.scale.y);
    }
    set width(newWidth) {
        newWidth /= Math.abs(this.scale.x);
        this.destSize.width = newWidth;
        super.width = Math.ceil(this.destSize.width);
    }
    set height(newHeight) {
        newHeight /= Math.abs(this.scale.y);
        this.destSize.height = newHeight;
        super.height = Math.ceil(this.destSize.height);
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width) * this.scale.x;
        this.height = Math.ceil(this.destSize.height) * this.scale.y;
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded() && this._dirty) {
            this._dirty = false;
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
        else {
            this._logger.warnOnce(`ImageSource ${this.image.path}` +
                ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\n\n` +
                `Read https://excaliburjs.com/docs/imagesource for more information.`);
        }
    }
    clone() {
        return new Sprite({
            image: this.image,
            sourceView: { ...this.sourceView },
            destSize: { ...this.destSize },
            ...this.cloneGraphicOptions()
        });
    }
}


/***/ }),

/***/ "./Graphics/SpriteFont.ts":
/*!********************************!*\
  !*** ./Graphics/SpriteFont.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1172661__) => {

__nested_webpack_require_1172661__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1172661__.d(__nested_webpack_exports__, {
/* harmony export */   SpriteFont: () => (/* binding */ SpriteFont)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1172661__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1172661__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1172661__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1172661__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");




class SpriteFont extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this.alphabet = '';
        this.shadow = undefined;
        this.caseInsensitive = false;
        this.spacing = 0;
        this.lineHeight = undefined;
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow, lineHeight } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
        this.lineHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : this.lineHeight;
    }
    _getCharacterSprites(text) {
        const results = [];
        // handle case insensitive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                this._logger.warnOnce(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
                this._logger.warnOnce('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                this._logger.warnOnce(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
                this._logger.warnOnce('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
            }
        }
        return results;
    }
    measureText(text, maxWidth) {
        const lines = this._getLinesFromText(text, maxWidth);
        const maxWidthLine = lines.reduce((a, b) => {
            return a.length > b.length ? a : b;
        });
        const sprites = this._getCharacterSprites(maxWidthLine);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        return _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(width * this.scale.x, height * lines.length * this.scale.y, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
    }
    _drawImage(ex, x, y, maxWidth) {
        var _a;
        let xCursor = 0;
        let yCursor = 0;
        let height = 0;
        const lines = this._getLinesFromText(this._text, maxWidth);
        for (const line of lines) {
            for (const sprite of this._getCharacterSprites(line)) {
                // draw it in the right spot and increase the cursor by sprite width
                sprite.draw(ex, x + xCursor, y + yCursor);
                xCursor += sprite.width + this.spacing;
                height = Math.max(height, sprite.height);
            }
            xCursor = 0;
            yCursor += (_a = this.lineHeight) !== null && _a !== void 0 ? _a : height;
        }
    }
    render(ex, text, _color, x, y, maxWidth) {
        // SpriteFont doesn't support _color, yet...
        this._text = text;
        const bounds = this.measureText(text, maxWidth);
        this.width = bounds.width;
        this.height = bounds.height;
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this._preDraw(ex, x, y);
            this._drawImage(ex, 0, 0, maxWidth);
            this._postDraw(ex);
            ex.restore();
        }
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0, maxWidth);
        this._postDraw(ex);
    }
    clone() {
        return new SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
    _getLinesFromText(text, maxWidth) {
        var _a;
        if (this._cachedText === text && this._cachedRenderWidth === maxWidth && ((_a = this._cachedLines) === null || _a === void 0 ? void 0 : _a.length)) {
            return this._cachedLines;
        }
        const lines = text.split('\n');
        if (maxWidth == null) {
            return lines;
        }
        // If the current line goes past the maxWidth, append a new line without modifying the underlying text.
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            let newLine = '';
            // Note: we subtract the spacing to counter the initial padding on the left side.
            if (this.measureText(line).width > maxWidth) {
                while (this.measureText(line).width > maxWidth) {
                    newLine = line[line.length - 1] + newLine;
                    line = line.slice(0, -1); // Remove last character from line
                }
                // Update the array with our new values
                lines[i] = line;
                lines[i + 1] = newLine;
            }
        }
        this._cachedText = text;
        this._cachedLines = lines;
        this._cachedRenderWidth = maxWidth;
        return lines;
    }
}


/***/ }),

/***/ "./Graphics/SpriteSheet.ts":
/*!*********************************!*\
  !*** ./Graphics/SpriteSheet.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1179578__) => {

__nested_webpack_require_1179578__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1179578__.d(__nested_webpack_exports__, {
/* harmony export */   SpriteSheet: () => (/* binding */ SpriteSheet)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1179578__(/*! ./Sprite */ "./Graphics/Sprite.ts");
/* harmony import */ var _TiledSprite__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1179578__(/*! ./TiledSprite */ "./Graphics/TiledSprite.ts");


/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use {@apilink SpriteSheet.fromImageSource} to create a SpriteSheet from an {@apilink ImageSource} organized in a grid
     * @param options
     */
    constructor(options) {
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y integer coordinates in the SpriteSheet, for example `getSprite(0, 0)` is the {@apilink Sprite} in the top-left
     * and `getSprite(1, 0)` is the sprite one to the right.
     * @param x
     * @param y
     */
    getSprite(x, y, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (x >= this.columns || x < 0) {
            throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1} columns`);
        }
        if (y >= this.rows || y < 0) {
            throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1} rows`);
        }
        const spriteIndex = x + y * this.columns;
        const sprite = this.sprites[spriteIndex];
        if (sprite) {
            if (options) {
                const spriteWithOptions = sprite.clone();
                spriteWithOptions.flipHorizontal = (_a = options.flipHorizontal) !== null && _a !== void 0 ? _a : spriteWithOptions.flipHorizontal;
                spriteWithOptions.flipVertical = (_b = options.flipVertical) !== null && _b !== void 0 ? _b : spriteWithOptions.flipVertical;
                spriteWithOptions.width = (_c = options.width) !== null && _c !== void 0 ? _c : spriteWithOptions.width;
                spriteWithOptions.height = (_d = options.height) !== null && _d !== void 0 ? _d : spriteWithOptions.height;
                spriteWithOptions.rotation = (_e = options.rotation) !== null && _e !== void 0 ? _e : spriteWithOptions.rotation;
                spriteWithOptions.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : spriteWithOptions.scale;
                spriteWithOptions.opacity = (_g = options.opacity) !== null && _g !== void 0 ? _g : spriteWithOptions.opacity;
                spriteWithOptions.tint = (_h = options.tint) !== null && _h !== void 0 ? _h : spriteWithOptions.tint;
                spriteWithOptions.origin = (_j = options.origin) !== null && _j !== void 0 ? _j : spriteWithOptions.origin;
                return spriteWithOptions;
            }
            return sprite;
        }
        throw Error(`Invalid sprite coordinates (${x}, ${y})`);
    }
    /**
     * Find a sprite by their x/y integer coordinates in the SpriteSheet and configures tiling to repeat by default,
     * for example `getTiledSprite(0, 0)` is the {@apilink TiledSprite} in the top-left
     * and `getTiledSprite(1, 0)` is the sprite one to the right.
     *
     * Example:
     *
     * ```typescript
     * spriteSheet.getTiledSprite(1, 0, {
     * width: game.screen.width,
     * height: 200,
     * wrapping: {
     * x: ex.ImageWrapping.Repeat,
     * y: ex.ImageWrapping.Clamp
     * }
     * });
     * ```
     * @param x
     * @param y
     * @param options
     */
    getTiledSprite(x, y, options) {
        if (x >= this.columns || x < 0) {
            throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1} columns`);
        }
        if (y >= this.rows || y < 0) {
            throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1} rows`);
        }
        const spriteIndex = x + y * this.columns;
        const sprite = this.sprites[spriteIndex];
        if (sprite) {
            return _TiledSprite__WEBPACK_IMPORTED_MODULE_0__.TiledSprite.fromSprite(sprite, options);
        }
        throw Error(`Invalid sprite coordinates (${x}, ${y})`);
    }
    /**
     * Create a sprite sheet from a sparse set of {@apilink SourceView} rectangles
     * @param options
     */
    static fromImageSourceWithSourceViews(options) {
        const sprites = options.sourceViews.map((sourceView) => {
            return new _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite({
                image: options.image,
                sourceView
            });
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Create a SpriteSheet from an {@apilink ImageSource} organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = { x: 0, y: 0, ...originOffset };
        const marginDefaults = { x: 0, y: 0, ...margin };
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
    clone() {
        return new SpriteSheet({
            sprites: this.sprites.map((sprite) => sprite.clone()),
            rows: this.rows,
            columns: this.columns
        });
    }
}


/***/ }),

/***/ "./Graphics/Text.ts":
/*!**************************!*\
  !*** ./Graphics/Text.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1187066__) => {

__nested_webpack_require_1187066__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1187066__.d(__nested_webpack_exports__, {
/* harmony export */   Text: () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1187066__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1187066__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1187066__(/*! ./Font */ "./Graphics/Font.ts");



/**
 * Represent Text graphics in excalibur
 *
 * Useful for in game labels, ui, or overlays
 */
class Text extends _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        this._textWidth = 0;
        this._textHeight = 0;
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new _Font__WEBPACK_IMPORTED_MODULE_1__.Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
        this.maxWidth = options.maxWidth;
    }
    clone() {
        var _a, _b;
        return new Text({
            text: this.text.slice(),
            color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Black,
            font: this.font.clone(),
            maxWidth: this.maxWidth
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this._calculateDimension();
    }
    get font() {
        return this._font;
    }
    set font(font) {
        this._font = font;
    }
    get width() {
        if (this._textWidth === 0) {
            this._calculateDimension();
        }
        return this._textWidth * this.scale.x;
    }
    get height() {
        if (this._textHeight === 0) {
            this._calculateDimension();
        }
        return this._textHeight * this.scale.y;
    }
    _calculateDimension() {
        const { width, height } = this.font.measureText(this._text, this.maxWidth);
        this._textWidth = width;
        this._textHeight = height;
    }
    get localBounds() {
        return this.font.measureText(this._text, this.maxWidth).scale(this.scale);
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _preDraw(ex, x, y) {
        if (this.isStale() || this.font.isStale()) {
            this.font.flipHorizontal = this.flipHorizontal;
            this.font.flipVertical = this.flipVertical;
            this.font.rotation = this.rotation;
            this.font.origin = this.origin;
            this.font.opacity = this.opacity;
        }
        this.font.tint = this.tint;
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        var _a;
        let color = _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Black;
        if (this.font instanceof _Font__WEBPACK_IMPORTED_MODULE_1__.Font) {
            color = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;
        }
        const { width, height } = this.font.measureText(this._text, this.maxWidth);
        this._textWidth = width;
        this._textHeight = height;
        this.font.render(ex, this._text, color, x, y, this.maxWidth);
        if (this.font.showDebug) {
            ex.debug.drawRect(x - width, y - height, width * 2, height * 2);
            if (this.maxWidth != null) {
                ex.debug.drawRect(x, y, this.maxWidth, this.height, {
                    color: _Color__WEBPACK_IMPORTED_MODULE_2__.Color.Yellow
                });
            }
        }
    }
}


/***/ }),

/***/ "./Graphics/TiledAnimation.ts":
/*!************************************!*\
  !*** ./Graphics/TiledAnimation.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1191285__) => {

__nested_webpack_require_1191285__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1191285__.d(__nested_webpack_exports__, {
/* harmony export */   TiledAnimation: () => (/* binding */ TiledAnimation)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1191285__(/*! ./Sprite */ "./Graphics/Sprite.ts");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1191285__(/*! ./Animation */ "./Graphics/Animation.ts");
/* harmony import */ var _TiledSprite__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1191285__(/*! ./TiledSprite */ "./Graphics/TiledSprite.ts");
/* harmony import */ var _Util_Watch__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1191285__(/*! ../Util/Watch */ "./Util/Watch.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1191285__(/*! ../Util/Future */ "./Util/Future.ts");





class TiledAnimation extends _Animation__WEBPACK_IMPORTED_MODULE_0__.Animation {
    constructor(options) {
        super({
            ...options,
            frames: options.animation.frames.slice(),
            strategy: options.animation.strategy,
            frameDuration: options.animation.frameDuration,
            speed: options.animation.speed,
            reverse: options.animation.isReversed
        });
        this._ready = new _Util_Future__WEBPACK_IMPORTED_MODULE_1__.Future();
        this.ready = this._ready.promise;
        this._tiledWidth = 0;
        this._tiledHeight = 0;
        this._sourceView = {};
        this._sourceView = { ...options.sourceView };
        this._tiledWidth = options.width;
        this._tiledHeight = options.height;
        const promises = [];
        for (let i = 0; i < this.frames.length; i++) {
            const graphic = this.frames[i].graphic;
            if (graphic && graphic instanceof _Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite) {
                const tiledSprite = new _TiledSprite__WEBPACK_IMPORTED_MODULE_3__.TiledSprite({
                    image: graphic.image,
                    width: options.width,
                    height: options.height,
                    sourceView: { ...graphic.sourceView },
                    wrapping: options.wrapping,
                    filtering: options.filtering
                });
                this.frames[i].graphic = tiledSprite;
                // There is a new calc'd sourceView when ready
                tiledSprite.ready.then(() => {
                    tiledSprite.sourceView = { ...tiledSprite.sourceView, ...this._sourceView };
                });
                promises.push(tiledSprite.ready);
            }
        }
        Promise.all(promises).then(() => this._ready.resolve());
    }
    static fromAnimation(animation, options) {
        return new TiledAnimation({
            width: animation.width,
            height: animation.height,
            ...options,
            animation
        });
    }
    _updateSourceView() {
        for (let i = 0; i < this.frames.length; i++) {
            const graphic = this.frames[i].graphic;
            if (graphic && graphic instanceof _Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite) {
                graphic.sourceView = { ...graphic.sourceView, ...this._sourceView };
            }
        }
    }
    get sourceView() {
        return (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_4__.watch)(this._sourceView, () => this._updateSourceView());
    }
    set sourceView(sourceView) {
        this._sourceView = (0,_Util_Watch__WEBPACK_IMPORTED_MODULE_4__.watch)(sourceView, () => this._updateSourceView());
        this._updateSourceView();
    }
    _updateWidthHeight() {
        for (let i = 0; i < this.frames.length; i++) {
            const graphic = this.frames[i].graphic;
            if (graphic && graphic instanceof _Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite) {
                graphic.sourceView.height = this._tiledHeight || graphic.height;
                graphic.destSize.height = this._tiledHeight || graphic.height;
                graphic.sourceView.width = this._tiledWidth || graphic.width;
                graphic.destSize.width = this._tiledWidth || graphic.width;
            }
        }
    }
    get width() {
        return this._tiledWidth;
    }
    get height() {
        return this._tiledHeight;
    }
    set width(width) {
        this._tiledWidth = width;
        this._updateWidthHeight();
    }
    set height(height) {
        this._tiledHeight = height;
        this._updateWidthHeight();
    }
}


/***/ }),

/***/ "./Graphics/TiledSprite.ts":
/*!*********************************!*\
  !*** ./Graphics/TiledSprite.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1196024__) => {

__nested_webpack_require_1196024__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1196024__.d(__nested_webpack_exports__, {
/* harmony export */   TiledSprite: () => (/* binding */ TiledSprite)
/* harmony export */ });
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1196024__(/*! ../Util/Future */ "./Util/Future.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1196024__(/*! ./ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1196024__(/*! ./Sprite */ "./Graphics/Sprite.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1196024__(/*! ./Wrapping */ "./Graphics/Wrapping.ts");




class TiledSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor(options) {
        super({
            image: options.image,
            sourceView: options.sourceView,
            destSize: { width: options.width, height: options.height },
            flipHorizontal: options.flipHorizontal,
            flipVertical: options.flipVertical,
            rotation: options.rotation,
            scale: options.scale,
            opacity: options.opacity,
            tint: options.tint,
            origin: options.origin
        });
        this._ready = new _Util_Future__WEBPACK_IMPORTED_MODULE_1__.Future();
        this.ready = this._ready.promise;
        this._options = options;
        if (this.image.isLoaded()) {
            this._applyTiling();
        }
        else {
            this.image.ready.then(() => this._applyTiling());
        }
    }
    static fromSprite(sprite, options) {
        return new TiledSprite({
            sourceView: { ...sprite.sourceView },
            width: sprite.width,
            height: sprite.height,
            ...options,
            image: sprite.image
        });
    }
    _applyTiling() {
        const { width, height, filtering, wrapping } = { ...this._options };
        const spriteCanvas = document.createElement('canvas');
        spriteCanvas.width = this.sourceView.width;
        spriteCanvas.height = this.sourceView.height;
        const spriteCtx = spriteCanvas.getContext('2d');
        // prettier-ignore
        spriteCtx.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, 0, 0, this.sourceView.width, this.sourceView.height);
        // prettier-ignore
        const tiledImageSource = _ImageSource__WEBPACK_IMPORTED_MODULE_2__.ImageSource.fromHtmlCanvasElement(spriteCanvas, {
            wrapping: wrapping !== null && wrapping !== void 0 ? wrapping : _Wrapping__WEBPACK_IMPORTED_MODULE_3__.ImageWrapping.Repeat,
            filtering
        });
        if (width) {
            this.destSize.width = width;
            this.sourceView.width = width;
        }
        if (height) {
            this.destSize.height = height;
            this.sourceView.height = height;
        }
        this.sourceView.x = 0;
        this.sourceView.y = 0;
        this.image = tiledImageSource;
        // this._ready.resolve();
        this.image.ready.then(() => this._ready.resolve());
    }
}


/***/ }),

/***/ "./Graphics/TransformInterpolation.ts":
/*!********************************************!*\
  !*** ./Graphics/TransformInterpolation.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1199495__) => {

__nested_webpack_require_1199495__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1199495__.d(__nested_webpack_exports__, {
/* harmony export */   blendGlobalTransform: () => (/* binding */ blendGlobalTransform),
/* harmony export */   blendTransform: () => (/* binding */ blendTransform)
/* harmony export */ });
/* harmony import */ var _Math_transform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1199495__(/*! ../Math/transform */ "./Math/transform.ts");

/**
 * Blend 2 transforms for interpolation, will interpolate from the context of newTx's parent if it exists
 */
function blendTransform(oldTx, newTx, blend, target) {
    if (oldTx.parent !== newTx.parent) {
        // Caller expects a local transform
        // Adjust old tx to be local to the new parent whatever that is
        const oldTxWithNewParent = oldTx.clone();
        const oldGlobalPos = oldTx.globalPos.clone();
        const oldGlobalScale = oldTx.globalScale.clone();
        const oldGlobalRotation = oldTx.globalRotation;
        oldTxWithNewParent.parent = newTx.parent;
        oldTxWithNewParent.globalPos = oldGlobalPos;
        oldTxWithNewParent.globalScale = oldGlobalScale;
        oldTxWithNewParent.globalRotation = oldGlobalRotation;
        oldTx = oldTxWithNewParent;
    }
    let interpolatedPos = newTx.pos;
    let interpolatedScale = newTx.scale;
    let interpolatedRotation = newTx.rotation;
    interpolatedPos = newTx.pos.scale(blend).add(oldTx.pos.scale(1.0 - blend));
    interpolatedScale = newTx.scale.scale(blend).add(oldTx.scale.scale(1.0 - blend));
    // Rotational lerp https://stackoverflow.com/a/30129248
    const cosine = (1.0 - blend) * Math.cos(oldTx.rotation) + blend * Math.cos(newTx.rotation);
    const sine = (1.0 - blend) * Math.sin(oldTx.rotation) + blend * Math.sin(newTx.rotation);
    interpolatedRotation = Math.atan2(sine, cosine);
    const tx = target !== null && target !== void 0 ? target : new _Math_transform__WEBPACK_IMPORTED_MODULE_0__.Transform();
    tx.setTransform(interpolatedPos, interpolatedRotation, interpolatedScale);
    return tx;
}
/**
 *
 */
function blendGlobalTransform(oldTx, newTx, blend, target) {
    let interpolatedPos = newTx.globalPos;
    let interpolatedScale = newTx.globalScale;
    let interpolatedRotation = newTx.globalRotation;
    interpolatedPos = newTx.globalPos.scale(blend).add(oldTx.globalPos.scale(1.0 - blend));
    interpolatedScale = newTx.globalScale.scale(blend).add(oldTx.globalScale.scale(1.0 - blend));
    // Rotational lerp https://stackoverflow.com/a/30129248
    const cosine = (1.0 - blend) * Math.cos(oldTx.globalRotation) + blend * Math.cos(newTx.globalRotation);
    const sine = (1.0 - blend) * Math.sin(oldTx.globalRotation) + blend * Math.sin(newTx.globalRotation);
    interpolatedRotation = Math.atan2(sine, cosine);
    const tx = target !== null && target !== void 0 ? target : new _Math_transform__WEBPACK_IMPORTED_MODULE_0__.Transform();
    tx.setTransform(interpolatedPos, interpolatedRotation, interpolatedScale);
    return tx;
}


/***/ }),

/***/ "./Graphics/Wrapping.ts":
/*!******************************!*\
  !*** ./Graphics/Wrapping.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1202747__) => {

__nested_webpack_require_1202747__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1202747__.d(__nested_webpack_exports__, {
/* harmony export */   ImageWrapping: () => (/* binding */ ImageWrapping),
/* harmony export */   parseImageWrapping: () => (/* binding */ parseImageWrapping)
/* harmony export */ });
/**
 * Describes the different image wrapping modes
 */
var ImageWrapping;
(function (ImageWrapping) {
    ImageWrapping["Clamp"] = "Clamp";
    ImageWrapping["Repeat"] = "Repeat";
    ImageWrapping["Mirror"] = "Mirror";
})(ImageWrapping || (ImageWrapping = {}));
/**
 *
 */
function parseImageWrapping(val) {
    switch (val) {
        case ImageWrapping.Clamp:
            return ImageWrapping.Clamp;
        case ImageWrapping.Repeat:
            return ImageWrapping.Repeat;
        case ImageWrapping.Mirror:
            return ImageWrapping.Mirror;
        default:
            return ImageWrapping.Clamp;
    }
}


/***/ }),

/***/ "./Graphics/index.ts":
/*!***************************!*\
  !*** ./Graphics/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1203882__) => {

__nested_webpack_require_1203882__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1203882__.d(__nested_webpack_exports__, {
/* harmony export */   Animation: () => (/* reexport safe */ _Animation__WEBPACK_IMPORTED_MODULE_5__.Animation),
/* harmony export */   AnimationDirection: () => (/* reexport safe */ _Animation__WEBPACK_IMPORTED_MODULE_5__.AnimationDirection),
/* harmony export */   AnimationEvents: () => (/* reexport safe */ _Animation__WEBPACK_IMPORTED_MODULE_5__.AnimationEvents),
/* harmony export */   AnimationStrategy: () => (/* reexport safe */ _Animation__WEBPACK_IMPORTED_MODULE_5__.AnimationStrategy),
/* harmony export */   BaseAlign: () => (/* reexport safe */ _FontCommon__WEBPACK_IMPORTED_MODULE_17__.BaseAlign),
/* harmony export */   Canvas: () => (/* reexport safe */ _Canvas__WEBPACK_IMPORTED_MODULE_21__.Canvas),
/* harmony export */   Circle: () => (/* reexport safe */ _Circle__WEBPACK_IMPORTED_MODULE_13__.Circle),
/* harmony export */   ColorBlindnessMode: () => (/* reexport safe */ _PostProcessor_ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_31__.ColorBlindnessMode),
/* harmony export */   ColorBlindnessPostProcessor: () => (/* reexport safe */ _PostProcessor_ColorBlindnessPostProcessor__WEBPACK_IMPORTED_MODULE_32__.ColorBlindnessPostProcessor),
/* harmony export */   Debug: () => (/* reexport safe */ _Debug__WEBPACK_IMPORTED_MODULE_41__.Debug),
/* harmony export */   DebugGraphicsComponent: () => (/* reexport safe */ _DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_8__.DebugGraphicsComponent),
/* harmony export */   DebugText: () => (/* reexport safe */ _Context_debug_text__WEBPACK_IMPORTED_MODULE_29__.DebugText),
/* harmony export */   DefaultAntialiasOptions: () => (/* reexport safe */ _Context_ExcaliburGraphicsContext__WEBPACK_IMPORTED_MODULE_25__.DefaultAntialiasOptions),
/* harmony export */   DefaultPixelArtOptions: () => (/* reexport safe */ _Context_ExcaliburGraphicsContext__WEBPACK_IMPORTED_MODULE_25__.DefaultPixelArtOptions),
/* harmony export */   Direction: () => (/* reexport safe */ _FontCommon__WEBPACK_IMPORTED_MODULE_17__.Direction),
/* harmony export */   ExcaliburGraphicsContext2DCanvas: () => (/* reexport safe */ _Context_ExcaliburGraphicsContext2DCanvas__WEBPACK_IMPORTED_MODULE_26__.ExcaliburGraphicsContext2DCanvas),
/* harmony export */   ExcaliburGraphicsContextWebGL: () => (/* reexport safe */ _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_27__.ExcaliburGraphicsContextWebGL),
/* harmony export */   Font: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_18__.Font),
/* harmony export */   FontCache: () => (/* reexport safe */ _FontCache__WEBPACK_IMPORTED_MODULE_19__.FontCache),
/* harmony export */   FontStyle: () => (/* reexport safe */ _FontCommon__WEBPACK_IMPORTED_MODULE_17__.FontStyle),
/* harmony export */   FontUnit: () => (/* reexport safe */ _FontCommon__WEBPACK_IMPORTED_MODULE_17__.FontUnit),
/* harmony export */   Graphic: () => (/* reexport safe */ _Graphic__WEBPACK_IMPORTED_MODULE_0__.Graphic),
/* harmony export */   GraphicsComponent: () => (/* reexport safe */ _GraphicsComponent__WEBPACK_IMPORTED_MODULE_7__.GraphicsComponent),
/* harmony export */   GraphicsGroup: () => (/* reexport safe */ _GraphicsGroup__WEBPACK_IMPORTED_MODULE_3__.GraphicsGroup),
/* harmony export */   GraphicsSystem: () => (/* reexport safe */ _GraphicsSystem__WEBPACK_IMPORTED_MODULE_9__.GraphicsSystem),
/* harmony export */   ImageFiltering: () => (/* reexport safe */ _Filtering__WEBPACK_IMPORTED_MODULE_34__.ImageFiltering),
/* harmony export */   ImageSource: () => (/* reexport safe */ _ImageSource__WEBPACK_IMPORTED_MODULE_4__.ImageSource),
/* harmony export */   ImageSourceAttributeConstants: () => (/* reexport safe */ _ImageSource__WEBPACK_IMPORTED_MODULE_4__.ImageSourceAttributeConstants),
/* harmony export */   ImageWrapping: () => (/* reexport safe */ _Wrapping__WEBPACK_IMPORTED_MODULE_35__.ImageWrapping),
/* harmony export */   Line: () => (/* reexport safe */ _Line__WEBPACK_IMPORTED_MODULE_6__.Line),
/* harmony export */   Material: () => (/* reexport safe */ _Context_material__WEBPACK_IMPORTED_MODULE_40__.Material),
/* harmony export */   NineSlice: () => (/* reexport safe */ _NineSlice__WEBPACK_IMPORTED_MODULE_22__.NineSlice),
/* harmony export */   NineSliceStretch: () => (/* reexport safe */ _NineSlice__WEBPACK_IMPORTED_MODULE_22__.NineSliceStretch),
/* harmony export */   OffscreenSystem: () => (/* reexport safe */ _OffscreenSystem__WEBPACK_IMPORTED_MODULE_10__.OffscreenSystem),
/* harmony export */   ParallaxComponent: () => (/* reexport safe */ _ParallaxComponent__WEBPACK_IMPORTED_MODULE_11__.ParallaxComponent),
/* harmony export */   ParticleRenderer: () => (/* reexport safe */ _Context_particle_renderer_particle_renderer__WEBPACK_IMPORTED_MODULE_28__.ParticleRenderer),
/* harmony export */   Polygon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_15__.Polygon),
/* harmony export */   QuadIndexBuffer: () => (/* reexport safe */ _Context_quad_index_buffer__WEBPACK_IMPORTED_MODULE_39__.QuadIndexBuffer),
/* harmony export */   Raster: () => (/* reexport safe */ _Raster__WEBPACK_IMPORTED_MODULE_12__.Raster),
/* harmony export */   Rectangle: () => (/* reexport safe */ _Rectangle__WEBPACK_IMPORTED_MODULE_14__.Rectangle),
/* harmony export */   ScreenShader: () => (/* reexport safe */ _PostProcessor_ScreenShader__WEBPACK_IMPORTED_MODULE_30__.ScreenShader),
/* harmony export */   Shader: () => (/* reexport safe */ _Context_shader__WEBPACK_IMPORTED_MODULE_36__.Shader),
/* harmony export */   Sprite: () => (/* reexport safe */ _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite),
/* harmony export */   SpriteFont: () => (/* reexport safe */ _SpriteFont__WEBPACK_IMPORTED_MODULE_20__.SpriteFont),
/* harmony export */   SpriteSheet: () => (/* reexport safe */ _SpriteSheet__WEBPACK_IMPORTED_MODULE_2__.SpriteSheet),
/* harmony export */   Text: () => (/* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_16__.Text),
/* harmony export */   TextAlign: () => (/* reexport safe */ _FontCommon__WEBPACK_IMPORTED_MODULE_17__.TextAlign),
/* harmony export */   TextureLoader: () => (/* reexport safe */ _Context_texture_loader__WEBPACK_IMPORTED_MODULE_33__.TextureLoader),
/* harmony export */   TiledAnimation: () => (/* reexport safe */ _TiledAnimation__WEBPACK_IMPORTED_MODULE_24__.TiledAnimation),
/* harmony export */   TiledSprite: () => (/* reexport safe */ _TiledSprite__WEBPACK_IMPORTED_MODULE_23__.TiledSprite),
/* harmony export */   VertexBuffer: () => (/* reexport safe */ _Context_vertex_buffer__WEBPACK_IMPORTED_MODULE_37__.VertexBuffer),
/* harmony export */   VertexLayout: () => (/* reexport safe */ _Context_vertex_layout__WEBPACK_IMPORTED_MODULE_38__.VertexLayout),
/* harmony export */   hasGraphicsTick: () => (/* reexport safe */ _GraphicsComponent__WEBPACK_IMPORTED_MODULE_7__.hasGraphicsTick),
/* harmony export */   parseImageFiltering: () => (/* reexport safe */ _Filtering__WEBPACK_IMPORTED_MODULE_34__.parseImageFiltering),
/* harmony export */   parseImageWrapping: () => (/* reexport safe */ _Wrapping__WEBPACK_IMPORTED_MODULE_35__.parseImageWrapping),
/* harmony export */   pixelSnapEpsilon: () => (/* reexport safe */ _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_27__.pixelSnapEpsilon),
/* harmony export */   webgl: () => (/* reexport module object */ _Context_webgl_util__WEBPACK_IMPORTED_MODULE_42__)
/* harmony export */ });
/* harmony import */ var _Graphic__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1203882__(/*! ./Graphic */ "./Graphics/Graphic.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1203882__(/*! ./Sprite */ "./Graphics/Sprite.ts");
/* harmony import */ var _SpriteSheet__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1203882__(/*! ./SpriteSheet */ "./Graphics/SpriteSheet.ts");
/* harmony import */ var _GraphicsGroup__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1203882__(/*! ./GraphicsGroup */ "./Graphics/GraphicsGroup.ts");
/* harmony import */ var _ImageSource__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1203882__(/*! ./ImageSource */ "./Graphics/ImageSource.ts");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1203882__(/*! ./Animation */ "./Graphics/Animation.ts");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1203882__(/*! ./Line */ "./Graphics/Line.ts");
/* harmony import */ var _GraphicsComponent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1203882__(/*! ./GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1203882__(/*! ./DebugGraphicsComponent */ "./Graphics/DebugGraphicsComponent.ts");
/* harmony import */ var _GraphicsSystem__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1203882__(/*! ./GraphicsSystem */ "./Graphics/GraphicsSystem.ts");
/* harmony import */ var _OffscreenSystem__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1203882__(/*! ./OffscreenSystem */ "./Graphics/OffscreenSystem.ts");
/* harmony import */ var _ParallaxComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1203882__(/*! ./ParallaxComponent */ "./Graphics/ParallaxComponent.ts");
/* harmony import */ var _Raster__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1203882__(/*! ./Raster */ "./Graphics/Raster.ts");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1203882__(/*! ./Circle */ "./Graphics/Circle.ts");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_1203882__(/*! ./Rectangle */ "./Graphics/Rectangle.ts");
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_1203882__(/*! ./Polygon */ "./Graphics/Polygon.ts");
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_1203882__(/*! ./Text */ "./Graphics/Text.ts");
/* harmony import */ var _FontCommon__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_1203882__(/*! ./FontCommon */ "./Graphics/FontCommon.ts");
/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_1203882__(/*! ./Font */ "./Graphics/Font.ts");
/* harmony import */ var _FontCache__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_1203882__(/*! ./FontCache */ "./Graphics/FontCache.ts");
/* harmony import */ var _SpriteFont__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_1203882__(/*! ./SpriteFont */ "./Graphics/SpriteFont.ts");
/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_1203882__(/*! ./Canvas */ "./Graphics/Canvas.ts");
/* harmony import */ var _NineSlice__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_1203882__(/*! ./NineSlice */ "./Graphics/NineSlice.ts");
/* harmony import */ var _TiledSprite__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_1203882__(/*! ./TiledSprite */ "./Graphics/TiledSprite.ts");
/* harmony import */ var _TiledAnimation__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_1203882__(/*! ./TiledAnimation */ "./Graphics/TiledAnimation.ts");
/* harmony import */ var _Context_ExcaliburGraphicsContext__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_1203882__(/*! ./Context/ExcaliburGraphicsContext */ "./Graphics/Context/ExcaliburGraphicsContext.ts");
/* harmony import */ var _Context_ExcaliburGraphicsContext2DCanvas__WEBPACK_IMPORTED_MODULE_26__ = __nested_webpack_require_1203882__(/*! ./Context/ExcaliburGraphicsContext2DCanvas */ "./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts");
/* harmony import */ var _Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_27__ = __nested_webpack_require_1203882__(/*! ./Context/ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _Context_particle_renderer_particle_renderer__WEBPACK_IMPORTED_MODULE_28__ = __nested_webpack_require_1203882__(/*! ./Context/particle-renderer/particle-renderer */ "./Graphics/Context/particle-renderer/particle-renderer.ts");
/* harmony import */ var _Context_debug_text__WEBPACK_IMPORTED_MODULE_29__ = __nested_webpack_require_1203882__(/*! ./Context/debug-text */ "./Graphics/Context/debug-text.ts");
/* harmony import */ var _PostProcessor_ScreenShader__WEBPACK_IMPORTED_MODULE_30__ = __nested_webpack_require_1203882__(/*! ./PostProcessor/ScreenShader */ "./Graphics/PostProcessor/ScreenShader.ts");
/* harmony import */ var _PostProcessor_ColorBlindnessMode__WEBPACK_IMPORTED_MODULE_31__ = __nested_webpack_require_1203882__(/*! ./PostProcessor/ColorBlindnessMode */ "./Graphics/PostProcessor/ColorBlindnessMode.ts");
/* harmony import */ var _PostProcessor_ColorBlindnessPostProcessor__WEBPACK_IMPORTED_MODULE_32__ = __nested_webpack_require_1203882__(/*! ./PostProcessor/ColorBlindnessPostProcessor */ "./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts");
/* harmony import */ var _Context_texture_loader__WEBPACK_IMPORTED_MODULE_33__ = __nested_webpack_require_1203882__(/*! ./Context/texture-loader */ "./Graphics/Context/texture-loader.ts");
/* harmony import */ var _Filtering__WEBPACK_IMPORTED_MODULE_34__ = __nested_webpack_require_1203882__(/*! ./Filtering */ "./Graphics/Filtering.ts");
/* harmony import */ var _Wrapping__WEBPACK_IMPORTED_MODULE_35__ = __nested_webpack_require_1203882__(/*! ./Wrapping */ "./Graphics/Wrapping.ts");
/* harmony import */ var _Context_shader__WEBPACK_IMPORTED_MODULE_36__ = __nested_webpack_require_1203882__(/*! ./Context/shader */ "./Graphics/Context/shader.ts");
/* harmony import */ var _Context_vertex_buffer__WEBPACK_IMPORTED_MODULE_37__ = __nested_webpack_require_1203882__(/*! ./Context/vertex-buffer */ "./Graphics/Context/vertex-buffer.ts");
/* harmony import */ var _Context_vertex_layout__WEBPACK_IMPORTED_MODULE_38__ = __nested_webpack_require_1203882__(/*! ./Context/vertex-layout */ "./Graphics/Context/vertex-layout.ts");
/* harmony import */ var _Context_quad_index_buffer__WEBPACK_IMPORTED_MODULE_39__ = __nested_webpack_require_1203882__(/*! ./Context/quad-index-buffer */ "./Graphics/Context/quad-index-buffer.ts");
/* harmony import */ var _Context_material__WEBPACK_IMPORTED_MODULE_40__ = __nested_webpack_require_1203882__(/*! ./Context/material */ "./Graphics/Context/material.ts");
/* harmony import */ var _Debug__WEBPACK_IMPORTED_MODULE_41__ = __nested_webpack_require_1203882__(/*! ./Debug */ "./Graphics/Debug.ts");
/* harmony import */ var _Context_webgl_util__WEBPACK_IMPORTED_MODULE_42__ = __nested_webpack_require_1203882__(/*! ./Context/webgl-util */ "./Graphics/Context/webgl-util.ts");
// Graphics







// Graphics ECS





// Raster graphics
















// TODO DELETEME


// Post Processor







// Rendering






// Debug

// Util




/***/ }),

/***/ "./Id.ts":
/*!***************!*\
  !*** ./Id.ts ***!
  \***************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1218312__) => {

__nested_webpack_require_1218312__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1218312__.d(__nested_webpack_exports__, {
/* harmony export */   createId: () => (/* binding */ createId)
/* harmony export */ });
/**
 * Create a branded ID type from a number
 */
function createId(type, value) {
    return { type, value };
}


/***/ }),

/***/ "./Input/Gamepad.ts":
/*!**************************!*\
  !*** ./Input/Gamepad.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1218841__) => {

__nested_webpack_require_1218841__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1218841__.d(__nested_webpack_exports__, {
/* harmony export */   Axes: () => (/* binding */ Axes),
/* harmony export */   Buttons: () => (/* binding */ Buttons),
/* harmony export */   Gamepad: () => (/* binding */ Gamepad),
/* harmony export */   GamepadEvents: () => (/* binding */ GamepadEvents),
/* harmony export */   Gamepads: () => (/* binding */ Gamepads)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1218841__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1218841__(/*! ../EventEmitter */ "./EventEmitter.ts");


const GamepadEvents = {
    GamepadConnect: 'connect',
    GamepadDisconnect: 'disconnect',
    GamepadButton: 'button',
    GamepadAxis: 'axis'
};
/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads {
    constructor() {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
        this._enabled = true;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    toggleEnabled(enabled) {
        this._enabled = enabled;
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        this.events.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        if (!this._enabled) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.events.emit('disconnect', new _Events__WEBPACK_IMPORTED_MODULE_1__.GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.events.emit('connect', new _Events__WEBPACK_IMPORTED_MODULE_1__.GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            this.at(i).update();
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).events.emit('button', new _Events__WEBPACK_IMPORTED_MODULE_1__.GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).events.emit('axis', new _Events__WEBPACK_IMPORTED_MODULE_1__.GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See {@apilink Gamepads}
 * for more information on handling controller input.
 */
class Gamepad {
    constructor() {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.connected = false;
        this._axes = new Array(4);
        this._buttons = new Array(16);
        this._buttonsUp = new Array(16);
        this._buttonsDown = new Array(16);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    update() {
        // Reset buttonsDown and buttonsUp after update is complete
        this._buttonsDown = new Array(16);
        this._buttonsUp = new Array(16);
    }
    /**
     * Whether or not the given button is pressed
     * @deprecated will be removed in v0.28.0. Use isButtonHeld instead
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Tests if a certain button is held down. This is persisted between frames.
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonHeld(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Tests if a certain button was just pressed this frame. This is cleared at the end of the update frame.
     * @param button Test whether a button was just pressed
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    wasButtonPressed(button, threshold = 1) {
        return this._buttonsDown[button] >= threshold;
    }
    /**
     * Tests if a certain button was just released this frame. This is cleared at the end of the update frame.
     * @param button  Test whether a button was just released
     */
    wasButtonReleased(button) {
        return Boolean(this._buttonsUp[button]);
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * {@apilink MinAxisMoveThreshold} are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        // button was just released
        if (value === 0 && this._buttons[buttonIndex]) {
            this._buttonsUp[buttonIndex] = 1;
            // button was just pressed
        }
        else {
            this._buttonsDown[buttonIndex] = value;
        }
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));


/***/ }),

/***/ "./Input/InputHost.ts":
/*!****************************!*\
  !*** ./Input/InputHost.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1233630__) => {

__nested_webpack_require_1233630__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1233630__.d(__nested_webpack_exports__, {
/* harmony export */   InputHost: () => (/* binding */ InputHost)
/* harmony export */ });
/* harmony import */ var _Gamepad__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1233630__(/*! ./Gamepad */ "./Input/Gamepad.ts");
/* harmony import */ var _InputMapper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1233630__(/*! ./InputMapper */ "./Input/InputMapper.ts");
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1233630__(/*! ./Keyboard */ "./Input/Keyboard.ts");
/* harmony import */ var _PointerEventReceiver__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1233630__(/*! ./PointerEventReceiver */ "./Input/PointerEventReceiver.ts");




class InputHost {
    constructor(options) {
        this._enabled = true;
        const { pointerTarget, grabWindowFocus, engine } = options;
        this.keyboard = new _Keyboard__WEBPACK_IMPORTED_MODULE_0__.Keyboard();
        this.pointers = new _PointerEventReceiver__WEBPACK_IMPORTED_MODULE_1__.PointerEventReceiver(pointerTarget, engine);
        this.gamepads = new _Gamepad__WEBPACK_IMPORTED_MODULE_2__.Gamepads();
        this.keyboard.init({ grabWindowFocus });
        this.pointers.init({ grabWindowFocus });
        this.gamepads.init();
        this.inputMapper = new _InputMapper__WEBPACK_IMPORTED_MODULE_3__.InputMapper({
            keyboard: this.keyboard,
            pointers: this.pointers,
            gamepads: this.gamepads
        });
    }
    get enabled() {
        return this._enabled;
    }
    toggleEnabled(enabled) {
        this._enabled = enabled;
        this.keyboard.toggleEnabled(this._enabled);
        this.pointers.toggleEnabled(this._enabled);
        this.gamepads.toggleEnabled(this._enabled);
    }
    update() {
        if (this._enabled) {
            this.inputMapper.execute();
            this.keyboard.update();
            this.gamepads.update();
        }
    }
    clear() {
        this.keyboard.clear();
        this.pointers.clear();
        // this.gamepads.clear();
    }
}


/***/ }),

/***/ "./Input/InputMapper.ts":
/*!******************************!*\
  !*** ./Input/InputMapper.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1235959__) => {

__nested_webpack_require_1235959__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1235959__.d(__nested_webpack_exports__, {
/* harmony export */   InputMapper: () => (/* binding */ InputMapper)
/* harmony export */ });
/**
 * This allows you to map multiple inputs to specific commands! This is especially useful when
 * you need to allow multiple input sources to control a specific action.
 */
class InputMapper {
    constructor(inputs) {
        this.inputs = inputs;
        this._handlers = new Map();
    }
    /**
     * Executes the input map, called internally by Excalibur
     */
    execute() {
        for (const [input, command] of this._handlers.entries()) {
            const results = input(this.inputs);
            if (results) {
                command(results);
            }
        }
    }
    /**
     * This allows you to map multiple inputs to specific commands! This is useful
     *
     * The inputHandler should return a truthy value if you wish the commandHandler to fire.
     *
     * Example:
     * ```typescript
     * const moveRight = (amount: number) => { actor.vel.x = 100 * amount }
     * const moveLeft = (amount: number) => { actor.vel.x = -100 * amount }
     * const moveUp = (amount: number) => { actor.vel.y = -100 * amount }
     * const moveDown = (amount: number) => { actor.vel.y = 100 * amount }
     *
     * engine.inputMapper.on(({keyboard}) => keyboard.isHeld(ex.Keys.ArrowRight) ? 1 : 0, moveRight);
     * engine.inputMapper.on(({gamepads}) => gamepads.at(0).isButtonPressed(ex.Buttons.DpadRight) ? 1 : 0, moveRight);
     * engine.inputMapper.on(({gamepads}) => gamepads.at(0).getAxes(ex.Axes.LeftStickX) > 0 ?
     *  gamepads.at(0).getAxes(ex.Axes.LeftStickX) : 0, moveRight);
     * ```
     * @param inputHandler
     * @param commandHandler
     */
    on(inputHandler, commandHandler) {
        this._handlers.set(inputHandler, commandHandler);
    }
}


/***/ }),

/***/ "./Input/Keyboard.ts":
/*!***************************!*\
  !*** ./Input/Keyboard.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1238086__) => {

__nested_webpack_require_1238086__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1238086__.d(__nested_webpack_exports__, {
/* harmony export */   KeyEvent: () => (/* binding */ KeyEvent),
/* harmony export */   KeyEvents: () => (/* binding */ KeyEvents),
/* harmony export */   Keyboard: () => (/* binding */ Keyboard),
/* harmony export */   Keys: () => (/* binding */ Keys)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1238086__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1238086__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _Util_IFrame__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1238086__(/*! ../Util/IFrame */ "./Util/IFrame.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1238086__(/*! ../EventEmitter */ "./EventEmitter.ts");




/**
 * Enum representing physical input key codes
 *
 * Spec: https://w3c.github.io/uievents-code/#key-alphanumeric-section
 */
var Keys;
(function (Keys) {
    // Writing System Keys https://w3c.github.io/uievents-code/#key-alphanumeric-writing-system
    Keys["Backquote"] = "Backquote";
    Keys["Backslash"] = "Backslash";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["BracketRight"] = "BracketRight";
    Keys["Comma"] = "Comma";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    Keys["Equal"] = "Equal";
    Keys["IntlBackslash"] = "IntlBackslash";
    Keys["IntlRo"] = "IntlRo";
    Keys["IntlYen"] = "IntlYen";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Quote"] = "Quote";
    Keys["Semicolon"] = "Semicolon";
    Keys["Slash"] = "Slash";
    // Functional keys https://w3c.github.io/uievents-code/#key-alphanumeric-functional
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    Keys["Alt"] = "Alt";
    Keys["AltGraph"] = "AltGraph";
    Keys["Backspace"] = "Backspace";
    Keys["CapsLock"] = "CapsLock";
    Keys["ContextMenu"] = "ContextMenu";
    Keys["ControlLeft"] = "ControlLeft";
    Keys["ControlRight"] = "ControlRight";
    Keys["Enter"] = "Enter";
    Keys["MetaLeft"] = "MetaLeft";
    Keys["MetaRight"] = "MetaRight";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["Space"] = "Space";
    Keys["Tab"] = "Tab";
    Keys["Convert"] = "Convert";
    Keys["KanaMode"] = "KanaMode";
    Keys["NonConvert"] = "NonConvert";
    // Control Pad https://w3c.github.io/uievents-code/#key-controlpad-section
    Keys["Delete"] = "Delete";
    Keys["End"] = "End";
    Keys["Help"] = "Help";
    Keys["Home"] = "Home";
    Keys["Insert"] = "Insert";
    Keys["PageDown"] = "PageDown";
    Keys["PageUp"] = "PageUp";
    // Arrow Pad https://w3c.github.io/uievents-code/#key-arrowpad-section
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // Numpad Section https://w3c.github.io/uievents-code/#key-numpad-section
    Keys["NumLock"] = "NumLock";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["NumpadDecimal"] = "NumpadDecimal";
    Keys["NumDivide"] = "NumpadDivide";
    Keys["NumpadDivide"] = "NumpadDivide";
    Keys["NumEnter"] = "NumpadEnter";
    Keys["NumpadEnter"] = "NumpadEnter";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    // NumComma = 'NumpadComma', // not x-browser
    // NumpadComma = 'NumpadComma', // not x-browser
    // Function section https://w3c.github.io/uievents-code/#key-function-section
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
    Keys["F1"] = "F1";
    Keys["F2"] = "F2";
    Keys["F3"] = "F3";
    Keys["F4"] = "F4";
    Keys["F5"] = "F5";
    Keys["F6"] = "F6";
    Keys["F7"] = "F7";
    Keys["F8"] = "F8";
    Keys["F9"] = "F9";
    Keys["F10"] = "F10";
    Keys["F11"] = "F11";
    Keys["F12"] = "F12";
    Keys["F13"] = "F13";
    Keys["F14"] = "F14";
    Keys["F15"] = "F15";
    Keys["F16"] = "F16";
    Keys["F17"] = "F17";
    Keys["F18"] = "F18";
    Keys["F19"] = "F19";
    Keys["F20"] = "F20";
    Keys["PrintScreen"] = "PrintScreen";
    Keys["ScrollLock"] = "ScrollLock";
    Keys["Pause"] = "Pause";
    Keys["Unidentified"] = "Unidentified";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends _Events__WEBPACK_IMPORTED_MODULE_0__.GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
const KeyEvents = {
    Press: 'press',
    Hold: 'hold',
    Release: 'release'
};
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard {
    constructor() {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this._enabled = true;
        /**
         * Keys that are currently held down
         */
        this._keys = [];
        /**
         * Keys up in the current frame
         */
        this._keysUp = [];
        /**
         * Keys down in the current frame
         */
        this._keysDown = [];
        this._releaseAllKeys = (ev) => {
            for (const code of this._keys) {
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.events.emit('up', keyEvent);
                this.events.emit('release', keyEvent);
            }
            this._keysUp = Array.from(new Set(this._keys.concat(this._keysUp)));
            this._keys.length = 0;
        };
        this._handleKeyDown = (ev) => {
            if (!this._enabled) {
                return;
            }
            // handle macos meta key issue
            // https://github.com/excaliburjs/Excalibur/issues/2608
            if (!ev.metaKey && (this._keys.includes(Keys.MetaLeft) || this._keys.includes(Keys.MetaRight))) {
                this._releaseAllKeys(ev);
            }
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.events.emit('down', keyEvent);
                this.events.emit('press', keyEvent);
            }
        };
        this._handleKeyUp = (ev) => {
            if (!this._enabled) {
                return;
            }
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.events.emit('up', keyEvent);
            this.events.emit('release', keyEvent);
            // handle macos meta key issue
            // https://github.com/excaliburjs/Excalibur/issues/2608
            if (ev.key === 'Meta') {
                this._releaseAllKeys(ev);
            }
        };
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(keyboardOptions) {
        let { global } = keyboardOptions;
        const { grabWindowFocus } = keyboardOptions;
        if (!global) {
            if ((0,_Util_IFrame__WEBPACK_IMPORTED_MODULE_2__.isCrossOriginIframe)()) {
                global = window;
                // Workaround for iframes like for itch.io or codesandbox
                // https://www.reddit.com/r/gamemaker/comments/kfs5cs/keyboard_inputs_no_longer_working_in_html5_game/
                // https://forum.gamemaker.io/index.php?threads/solved-keyboard-issue-on-itch-io.87336/
                if (grabWindowFocus) {
                    window.focus();
                }
                _Util_Log__WEBPACK_IMPORTED_MODULE_3__.Logger.getInstance().warn('Excalibur might be in a cross-origin iframe, in order to receive keyboard events it must be in focus');
            }
            else {
                global = window.top;
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', this._handleKeyUp);
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', this._handleKeyDown);
    }
    toggleEnabled(enabled) {
        this._enabled = enabled;
    }
    clear() {
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        this._keys.length = 0;
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.events.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        if (!this._enabled) {
            return false;
        }
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        if (!this._enabled) {
            return false;
        }
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        if (!this._enabled) {
            return false;
        }
        return this._keysUp.indexOf(key) > -1;
    }
    /**
     * Trigger a manual key event
     * @param type
     * @param key
     * @param character
     */
    triggerEvent(type, key, character) {
        if (type === 'down') {
            this._handleKeyDown(new KeyboardEvent('keydown', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
        if (type === 'up') {
            this._handleKeyUp(new KeyboardEvent('keyup', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
    }
}


/***/ }),

/***/ "./Input/NativePointerButton.ts":
/*!**************************************!*\
  !*** ./Input/NativePointerButton.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1252314__) => {

__nested_webpack_require_1252314__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1252314__.d(__nested_webpack_exports__, {
/* harmony export */   NativePointerButton: () => (/* binding */ NativePointerButton)
/* harmony export */ });
/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));


/***/ }),

/***/ "./Input/PointerAbstraction.ts":
/*!*************************************!*\
  !*** ./Input/PointerAbstraction.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1253311__) => {

__nested_webpack_require_1253311__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1253311__.d(__nested_webpack_exports__, {
/* harmony export */   PointerAbstraction: () => (/* binding */ PointerAbstraction)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1253311__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1253311__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Math_global_coordinates__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1253311__(/*! ../Math/global-coordinates */ "./Math/global-coordinates.ts");



class PointerAbstraction {
    constructor() {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        this._onPointerMove = (ev) => {
            this.lastPagePos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this._onPointerDown = (ev) => {
            this.lastPagePos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * Called internally by excalibur to keep pointers up to date
     * @internal
     * @param engine
     */
    _updateWorldPosition(engine) {
        const coord = _Math_global_coordinates__WEBPACK_IMPORTED_MODULE_2__.GlobalCoordinates.fromPagePosition(this.lastPagePos, engine);
        this.lastScreenPos = coord.screenPos;
        this.lastWorldPos = coord.worldPos;
    }
}


/***/ }),

/***/ "./Input/PointerButton.ts":
/*!********************************!*\
  !*** ./Input/PointerButton.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1256624__) => {

__nested_webpack_require_1256624__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1256624__.d(__nested_webpack_exports__, {
/* harmony export */   PointerButton: () => (/* binding */ PointerButton)
/* harmony export */ });
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));


/***/ }),

/***/ "./Input/PointerComponent.ts":
/*!***********************************!*\
  !*** ./Input/PointerComponent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1257419__) => {

__nested_webpack_require_1257419__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1257419__.d(__nested_webpack_exports__, {
/* harmony export */   PointerComponent: () => (/* binding */ PointerComponent)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1257419__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");

/**
 * Add this component to optionally configure how the pointer
 * system detects pointer events.
 *
 * By default the collider shape is used and graphics bounds is not.
 *
 * If both collider shape and graphics bounds are enabled it will fire events if either or
 * are intersecting the pointer.
 */
class PointerComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(options) {
        var _a, _b;
        super();
        /**
         * Use any existing Collider component geometry for pointer events. This is useful if you want
         * user pointer events only to trigger on the same collision geometry used in the collider component
         * for collision resolution. Default is `true`.
         */
        this.useColliderShape = true;
        /**
         * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned
         * bounds around the graphic to trigger pointer events. Default is `true`.
         */
        this.useGraphicsBounds = true;
        this.useColliderShape = (_a = options === null || options === void 0 ? void 0 : options.useColliderShape) !== null && _a !== void 0 ? _a : this.useColliderShape;
        this.useGraphicsBounds = (_b = options === null || options === void 0 ? void 0 : options.useGraphicsBounds) !== null && _b !== void 0 ? _b : this.useGraphicsBounds;
        this.localBounds = options === null || options === void 0 ? void 0 : options.localBounds;
    }
}


/***/ }),

/***/ "./Input/PointerEvent.ts":
/*!*******************************!*\
  !*** ./Input/PointerEvent.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1259573__) => {

__nested_webpack_require_1259573__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1259573__.d(__nested_webpack_exports__, {
/* harmony export */   PointerEvent: () => (/* binding */ PointerEvent)
/* harmony export */ });
class PointerEvent {
    cancel() {
        this.active = false;
    }
    get pagePos() {
        return this.coordinates.pagePos;
    }
    get screenPos() {
        return this.coordinates.screenPos;
    }
    get worldPos() {
        return this.coordinates.worldPos;
    }
    constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {
        this.type = type;
        this.pointerId = pointerId;
        this.button = button;
        this.pointerType = pointerType;
        this.coordinates = coordinates;
        this.nativeEvent = nativeEvent;
        this.active = true;
    }
}


/***/ }),

/***/ "./Input/PointerEventReceiver.ts":
/*!***************************************!*\
  !*** ./Input/PointerEventReceiver.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1260657__) => {

__nested_webpack_require_1260657__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1260657__.d(__nested_webpack_exports__, {
/* harmony export */   PointerEventReceiver: () => (/* binding */ PointerEventReceiver),
/* harmony export */   PointerEvents: () => (/* binding */ PointerEvents)
/* harmony export */ });
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1260657__(/*! ../Engine */ "./Engine.ts");
/* harmony import */ var _Math_global_coordinates__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1260657__(/*! ../Math/global-coordinates */ "./Math/global-coordinates.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1260657__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _PointerEvent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1260657__(/*! ./PointerEvent */ "./Input/PointerEvent.ts");
/* harmony import */ var _WheelEvent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1260657__(/*! ./WheelEvent */ "./Input/WheelEvent.ts");
/* harmony import */ var _PointerAbstraction__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1260657__(/*! ./PointerAbstraction */ "./Input/PointerAbstraction.ts");
/* harmony import */ var _WheelDeltaMode__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1260657__(/*! ./WheelDeltaMode */ "./Input/WheelDeltaMode.ts");
/* harmony import */ var _PointerSystem__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1260657__(/*! ./PointerSystem */ "./Input/PointerSystem.ts");
/* harmony import */ var _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1260657__(/*! ./NativePointerButton */ "./Input/NativePointerButton.ts");
/* harmony import */ var _PointerButton__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1260657__(/*! ./PointerButton */ "./Input/PointerButton.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1260657__(/*! ../Util/Util */ "./Util/Util.ts");
/* harmony import */ var _PointerType__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1260657__(/*! ./PointerType */ "./Input/PointerType.ts");
/* harmony import */ var _Util_IFrame__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1260657__(/*! ../Util/IFrame */ "./Util/IFrame.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1260657__(/*! ../EventEmitter */ "./EventEmitter.ts");














const PointerEvents = {
    Move: 'move',
    Down: 'down',
    Up: 'up',
    Wheel: 'wheel'
};
/**
 * Is this event a native touch event?
 */
function isTouchEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;
}
/**
 * Is this event a native pointer event
 */
function isPointerEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;
}
/**
 * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates
 */
class PointerEventReceiver {
    constructor(target, engine) {
        this.target = target;
        this.engine = engine;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.primary = new _PointerAbstraction__WEBPACK_IMPORTED_MODULE_1__.PointerAbstraction();
        this._activeNativePointerIdsToNormalized = new Map();
        this.lastFramePointerCoords = new Map();
        this.currentFramePointerCoords = new Map();
        this.currentFramePointerDown = new Map();
        this.lastFramePointerDown = new Map();
        this.currentFrameDown = [];
        this.currentFrameUp = [];
        this.currentFrameMove = [];
        this.currentFrameCancel = [];
        this.currentFrameWheel = [];
        this._enabled = true;
        this._pointers = [this.primary];
        this._boundHandle = this._handle.bind(this);
        this._boundWheel = this._handleWheel.bind(this);
    }
    toggleEnabled(enabled) {
        this._enabled = enabled;
    }
    /**
     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
     * handlers.
     * @param target
     * @param engine
     */
    recreate(target, engine) {
        const eventReceiver = new PointerEventReceiver(target, engine);
        eventReceiver.primary = this.primary;
        eventReceiver._pointers = this._pointers;
        return eventReceiver;
    }
    /**
     * Locates a specific pointer by id, creates it if it doesn't exist
     * @param index
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new _PointerAbstraction__WEBPACK_IMPORTED_MODULE_1__.PointerAbstraction());
            }
        }
        return this._pointers[index];
    }
    /**
     * The number of pointers currently being tracked by excalibur
     */
    count() {
        return this._pointers.length;
    }
    /**
     * Is the specified pointer id down this frame
     * @param pointerId
     */
    isDown(pointerId) {
        var _a;
        if (!this._enabled) {
            return false;
        }
        return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Was the specified pointer id down last frame
     * @param pointerId
     */
    wasDown(pointerId) {
        var _a;
        if (!this._enabled) {
            return false;
        }
        return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    isDragging(pointerId) {
        if (!this._enabled) {
            return false;
        }
        return this.isDown(pointerId);
    }
    /**
     * Whether the Pointer just started dragging.
     */
    isDragStart(pointerId) {
        if (!this._enabled) {
            return false;
        }
        return this.isDown(pointerId) && !this.wasDown(pointerId);
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    isDragEnd(pointerId) {
        if (!this._enabled) {
            return false;
        }
        return !this.isDown(pointerId) && this.wasDown(pointerId);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * Called internally by excalibur
     *
     * Updates the current frame pointer info and emits raw pointer events
     *
     * This does not emit events to entities, see PointerSystem
     * @internal
     */
    update() {
        this.lastFramePointerDown = new Map(this.currentFramePointerDown);
        this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
        for (const event of this.currentFrameDown) {
            if (!event.active) {
                continue;
            }
            this.emit('down', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('down', event);
            this.primary.emit('pointerdown', event);
        }
        for (const event of this.currentFrameUp) {
            if (!event.active) {
                continue;
            }
            this.emit('up', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('up', event);
        }
        for (const event of this.currentFrameMove) {
            if (!event.active) {
                continue;
            }
            this.emit('move', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('move', event);
        }
        for (const event of this.currentFrameCancel) {
            if (!event.active) {
                continue;
            }
            this.emit('cancel', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('cancel', event);
        }
        for (const event of this.currentFrameWheel) {
            if (!event.active) {
                continue;
            }
            this.emit('pointerwheel', event);
            this.emit('wheel', event);
            this.primary.emit('pointerwheel', event);
            this.primary.emit('wheel', event);
        }
        if (this.engine.currentScene.camera.hasChanged()) {
            for (const pointer of this._pointers) {
                pointer._updateWorldPosition(this.engine);
            }
        }
    }
    /**
     * Clears the current frame event and pointer data
     */
    clear() {
        for (const event of this.currentFrameUp) {
            this.currentFramePointerCoords.delete(event.pointerId);
            const ids = this._activeNativePointerIdsToNormalized.entries();
            for (const [native, normalized] of ids) {
                if (normalized === event.pointerId) {
                    this._activeNativePointerIdsToNormalized.delete(native);
                }
            }
        }
        this.currentFrameDown.length = 0;
        this.currentFrameUp.length = 0;
        this.currentFrameMove.length = 0;
        this.currentFrameCancel.length = 0;
        this.currentFrameWheel.length = 0;
    }
    /**
     * Initializes the pointer event receiver so that it can start listening to native
     * browser events.
     */
    init(options) {
        var _a;
        if (this.engine.isDisposed()) {
            return;
        }
        // Disabling the touch action avoids browser/platform gestures from firing on the canvas
        // It is important on mobile to have touch action 'none'
        // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not
        if (this.target === this.engine.canvas) {
            this.engine.canvas.style.touchAction = 'none';
        }
        else {
            document.body.style.touchAction = 'none';
        }
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.addEventListener('pointerdown', this._boundHandle);
            this.target.addEventListener('pointerup', this._boundHandle);
            this.target.addEventListener('pointermove', this._boundHandle);
            this.target.addEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.addEventListener('touchstart', this._boundHandle);
            this.target.addEventListener('touchend', this._boundHandle);
            this.target.addEventListener('touchmove', this._boundHandle);
            this.target.addEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.addEventListener('mousedown', this._boundHandle);
            this.target.addEventListener('mouseup', this._boundHandle);
            this.target.addEventListener('mousemove', this._boundHandle);
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this.engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_2__.ScrollPreventionMode.All ||
                this.engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_2__.ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.addEventListener('wheel', this._boundWheel, wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);
        }
        const grabWindowFocus = (_a = options === null || options === void 0 ? void 0 : options.grabWindowFocus) !== null && _a !== void 0 ? _a : true;
        // Handle cross origin iframe
        if (grabWindowFocus && (0,_Util_IFrame__WEBPACK_IMPORTED_MODULE_3__.isCrossOriginIframe)()) {
            const grabFocus = () => {
                window.focus();
            };
            // Preferred pointer events
            if (window.PointerEvent) {
                this.target.addEventListener('pointerdown', grabFocus);
            }
            else {
                // Touch Events
                this.target.addEventListener('touchstart', grabFocus);
                // Mouse Events
                this.target.addEventListener('mousedown', grabFocus);
            }
        }
    }
    detach() {
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.removeEventListener('pointerdown', this._boundHandle);
            this.target.removeEventListener('pointerup', this._boundHandle);
            this.target.removeEventListener('pointermove', this._boundHandle);
            this.target.removeEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.removeEventListener('touchstart', this._boundHandle);
            this.target.removeEventListener('touchend', this._boundHandle);
            this.target.removeEventListener('touchmove', this._boundHandle);
            this.target.removeEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.removeEventListener('mousedown', this._boundHandle);
            this.target.removeEventListener('mouseup', this._boundHandle);
            this.target.removeEventListener('mousemove', this._boundHandle);
        }
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.removeEventListener('wheel', this._boundWheel);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel);
        }
    }
    /**
     * Take native pointer id and map it to index in active pointers
     * @param nativePointerId
     */
    _normalizePointerId(nativePointerId) {
        // Add to the the native pointer set id
        this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);
        // Native pointer ids in ascending order
        const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);
        // The index into sorted ids will be the new id, will always have an id
        const id = currentPointerIds.findIndex((p) => p === nativePointerId);
        // Save the mapping so we can reverse it later
        this._activeNativePointerIdsToNormalized.set(nativePointerId, id);
        // ignore pointer because game isn't watching
        return id;
    }
    /**
     * Responsible for handling and parsing pointer events
     */
    _handle(ev) {
        if (!this._enabled) {
            return;
        }
        ev.preventDefault();
        const eventCoords = new Map();
        let button;
        let pointerType;
        if (isTouchEvent(ev)) {
            button = _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.Unknown;
            pointerType = _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Touch;
            // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches[i];
                const coordinates = _Math_global_coordinates__WEBPACK_IMPORTED_MODULE_6__.GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);
                const nativePointerId = i + 1;
                const pointerId = this._normalizePointerId(nativePointerId);
                this.currentFramePointerCoords.set(pointerId, coordinates);
                eventCoords.set(pointerId, coordinates);
            }
        }
        else {
            button = this._nativeButtonToPointerButton(ev.button);
            pointerType = _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Mouse;
            const coordinates = _Math_global_coordinates__WEBPACK_IMPORTED_MODULE_6__.GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);
            let nativePointerId = 1;
            if (isPointerEvent(ev)) {
                nativePointerId = ev.pointerId;
                pointerType = this._stringToPointerType(ev.pointerType);
            }
            const pointerId = this._normalizePointerId(nativePointerId);
            this.currentFramePointerCoords.set(pointerId, coordinates);
            eventCoords.set(pointerId, coordinates);
        }
        for (const [pointerId, coord] of eventCoords.entries()) {
            switch (ev.type) {
                case 'mousedown':
                case 'pointerdown':
                case 'touchstart':
                    this.currentFrameDown.push(new _PointerEvent__WEBPACK_IMPORTED_MODULE_7__.PointerEvent('down', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, true);
                    break;
                case 'mouseup':
                case 'pointerup':
                case 'touchend':
                    this.currentFrameUp.push(new _PointerEvent__WEBPACK_IMPORTED_MODULE_7__.PointerEvent('up', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, false);
                    break;
                case 'mousemove':
                case 'pointermove':
                case 'touchmove':
                    this.currentFrameMove.push(new _PointerEvent__WEBPACK_IMPORTED_MODULE_7__.PointerEvent('move', pointerId, button, pointerType, coord, ev));
                    break;
                case 'touchcancel':
                case 'pointercancel':
                    this.currentFrameCancel.push(new _PointerEvent__WEBPACK_IMPORTED_MODULE_7__.PointerEvent('cancel', pointerId, button, pointerType, coord, ev));
                    break;
            }
        }
    }
    _handleWheel(ev) {
        if (!this._enabled) {
            return;
        }
        // Should we prevent page scroll because of this event
        if (this.engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_2__.ScrollPreventionMode.All ||
            (this.engine.pageScrollPreventionMode === _Engine__WEBPACK_IMPORTED_MODULE_2__.ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)) {
            ev.preventDefault();
        }
        const screen = this.engine.screen.pageToScreenCoordinates((0,_Math_vector__WEBPACK_IMPORTED_MODULE_8__.vec)(ev.pageX, ev.pageY));
        const world = this.engine.screen.screenToWorldCoordinates(screen);
        /**
         * A constant used to normalize wheel events across different browsers
         *
         * This normalization factor is pulled from
         * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
         */
        const ScrollWheelNormalizationFactor = -1 / 40;
        const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
        const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;
        const deltaZ = ev.deltaZ || 0;
        let deltaMode = _WheelDeltaMode__WEBPACK_IMPORTED_MODULE_9__.WheelDeltaMode.Pixel;
        if (ev.deltaMode) {
            if (ev.deltaMode === 1) {
                deltaMode = _WheelDeltaMode__WEBPACK_IMPORTED_MODULE_9__.WheelDeltaMode.Line;
            }
            else if (ev.deltaMode === 2) {
                deltaMode = _WheelDeltaMode__WEBPACK_IMPORTED_MODULE_9__.WheelDeltaMode.Page;
            }
        }
        const we = new _WheelEvent__WEBPACK_IMPORTED_MODULE_10__.WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);
        this.currentFrameWheel.push(we);
    }
    /**
     * Triggers an excalibur pointer event in a world space pos
     *
     * Useful for testing pointers in excalibur
     * @param type
     * @param pos
     */
    triggerEvent(type, pos) {
        const page = this.engine.screen.worldToPageCoordinates(pos);
        // Send an event to the event receiver
        if (window.PointerEvent) {
            this._handle(new window.PointerEvent('pointer' + type, {
                pointerId: 0,
                clientX: page.x,
                clientY: page.y
            }));
        }
        else {
            // Safari hack
            this._handle(new window.MouseEvent('mouse' + type, {
                clientX: page.x,
                clientY: page.y
            }));
        }
        // Force update pointer system
        const pointerSystem = this.engine.currentScene.world.get(_PointerSystem__WEBPACK_IMPORTED_MODULE_11__.PointerSystem);
        pointerSystem.preupdate(this.engine.currentScene, 1);
        pointerSystem.update(1);
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__.NativePointerButton.NoButton:
                return _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.NoButton;
            case _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__.NativePointerButton.Left:
                return _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.Left;
            case _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__.NativePointerButton.Middle:
                return _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.Middle;
            case _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__.NativePointerButton.Right:
                return _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.Right;
            case _NativePointerButton__WEBPACK_IMPORTED_MODULE_12__.NativePointerButton.Unknown:
                return _PointerButton__WEBPACK_IMPORTED_MODULE_4__.PointerButton.Unknown;
            default:
                return (0,_Util_Util__WEBPACK_IMPORTED_MODULE_13__.fail)(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Touch;
            case 'mouse':
                return _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Mouse;
            case 'pen':
                return _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Pen;
            default:
                return _PointerType__WEBPACK_IMPORTED_MODULE_5__.PointerType.Unknown;
        }
    }
}


/***/ }),

/***/ "./Input/PointerEventsToObjectDispatcher.ts":
/*!**************************************************!*\
  !*** ./Input/PointerEventsToObjectDispatcher.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1283814__) => {

__nested_webpack_require_1283814__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1283814__.d(__nested_webpack_exports__, {
/* harmony export */   PointerEventsToObjectDispatcher: () => (/* binding */ PointerEventsToObjectDispatcher),
/* harmony export */   PointerTargetObjectProxy: () => (/* binding */ PointerTargetObjectProxy)
/* harmony export */ });
/* harmony import */ var _Util_RentalPool__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1283814__(/*! ../Util/RentalPool */ "./Util/RentalPool.ts");

/**
 *
 */
function hasNestedEvents(object) {
    return object && object._dispatchPointerEvents && object._processPointerToObject;
}
class PointerTargetObjectProxy {
    get events() {
        return this.object.events;
    }
    init(object, contains, active) {
        this.object = object;
        this.contains = contains;
        this.active = active;
    }
}
class PointerEventsToObjectDispatcher {
    constructor() {
        this._proxyPool = new _Util_RentalPool__WEBPACK_IMPORTED_MODULE_0__.RentalPool(() => new PointerTargetObjectProxy(), (p) => p, 100);
        this._objectToProxy = new Map();
        this._proxies = [];
        this._lastFrameObjectToPointers = new Map();
        this._currentFrameObjectToPointers = new Map();
    }
    /**
     * Tracks an object to associate with pointers and their events
     * @param object
     * @param contains
     * @param active
     */
    addObject(object, contains, active) {
        const proxy = this._proxyPool.rent(false);
        proxy.init(object, contains, active);
        this._proxies.push(proxy);
        this._objectToProxy.set(object, proxy);
    }
    _getProxy(object) {
        const proxy = this._objectToProxy.get(object);
        if (proxy) {
            return proxy;
        }
        throw new Error('No PointerTargetProxy for object');
    }
    /**
     * Untracks an object associated with pointers and their events
     * @param object
     */
    removeObject(object) {
        const proxy = this._objectToProxy.get(object);
        if (proxy) {
            const index = this._proxies.indexOf(proxy);
            if (index > -1) {
                this._proxies.splice(index, 1);
            }
            this._proxyPool.return(proxy);
        }
    }
    _objectCurrentlyUnderPointer(object, pointerId) {
        return !!(this._currentFrameObjectToPointers.has(object) && this._currentFrameObjectToPointers.get(object).includes(pointerId));
    }
    _objectWasUnderPointer(object, pointerId) {
        return !!(this._lastFrameObjectToPointers.has(object) && this._lastFrameObjectToPointers.get(object).includes(pointerId));
    }
    _entered(object, pointerId) {
        return this._objectCurrentlyUnderPointer(object, pointerId) && !this._lastFrameObjectToPointers.has(object);
    }
    _left(object, pointerId) {
        return !this._currentFrameObjectToPointers.has(object) && this._objectWasUnderPointer(object, pointerId);
    }
    /**
     * Manually associate a pointer id with an object.
     *
     * This assumes you've checked that the pointer is indeed over the object.
     */
    addPointerToObject(object, pointerId) {
        const maybeProxy = this._objectToProxy.get(object);
        if (maybeProxy) {
            this._addPointerToProxy(maybeProxy, pointerId);
        }
    }
    _addPointerToProxy(object, pointerId) {
        if (!this._currentFrameObjectToPointers.has(object)) {
            this._currentFrameObjectToPointers.set(object, [pointerId]);
            return;
        }
        const pointers = this._currentFrameObjectToPointers.get(object);
        this._currentFrameObjectToPointers.set(object, pointers.concat(pointerId));
    }
    /**
     * Dispatches the appropriate pointer events in sortedObject order on tracked objects
     * @param receiver
     * @param sortedObjects
     */
    dispatchEvents(receiver, sortedObjects) {
        const lastFrameEntities = new Set(this._lastFrameObjectToPointers.keys());
        const currentFrameEntities = new Set(this._currentFrameObjectToPointers.keys());
        // Filter preserves z order
        let lastMovePerPointer;
        let lastUpPerPointer;
        let lastDownPerPointer;
        // Dispatch events in proxy z order
        for (let i = 0; i < sortedObjects.length; i++) {
            const object = sortedObjects[i];
            const proxy = this._getProxy(object);
            if (hasNestedEvents(object)) {
                object._dispatchPointerEvents(receiver);
            }
            if (lastFrameEntities.has(proxy) || currentFrameEntities.has(proxy)) {
                lastDownPerPointer = this._processDownAndEmit(receiver, proxy);
                lastUpPerPointer = this._processUpAndEmit(receiver, proxy);
                lastMovePerPointer = this._processMoveAndEmit(receiver, proxy);
                const lastUpDownMoveEvents = [...lastMovePerPointer.values(), ...lastDownPerPointer.values(), ...lastUpPerPointer.values()];
                this._processEnterLeaveAndEmit(receiver, proxy, lastUpDownMoveEvents);
                this._processCancelAndEmit(receiver, proxy);
                this._processWheelAndEmit(receiver, proxy);
            }
        }
    }
    /**
     * Given the tracked objects, update pointer containment given the provided contains()
     * @param receiver
     * @param objects
     */
    processPointerToObject(receiver, objects) {
        // Pre-process find entities under pointers
        for (let objectIndex = 0; objectIndex < objects.length; objectIndex++) {
            const object = objects[objectIndex];
            const proxy = this._getProxy(object);
            if (hasNestedEvents(object)) {
                object._processPointerToObject(receiver);
            }
            for (const [pointerId, pos] of receiver.currentFramePointerCoords.entries()) {
                if (proxy.contains(pos)) {
                    this._addPointerToProxy(proxy, pointerId);
                }
            }
        }
    }
    /**
     * Clear current frames pointer-object associations and track last frame pointer-object associations
     */
    clear() {
        this._lastFrameObjectToPointers.clear();
        this._lastFrameObjectToPointers = new Map(this._currentFrameObjectToPointers);
        this._currentFrameObjectToPointers.clear();
    }
    _processDownAndEmit(receiver, object) {
        const lastDownPerPointer = new Map();
        // Loop through down and dispatch to entities
        for (const event of receiver.currentFrameDown) {
            if (event.active && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
                object.events.emit('pointerdown', event);
                if (receiver.isDragStart(event.pointerId)) {
                    object.events.emit('pointerdragstart', event);
                }
            }
            lastDownPerPointer.set(event.pointerId, event);
        }
        return lastDownPerPointer;
    }
    _processUpAndEmit(receiver, object) {
        const lastUpPerPointer = new Map();
        // Loop through up and dispatch to entities
        for (const event of receiver.currentFrameUp) {
            if (event.active && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
                object.events.emit('pointerup', event);
                if (receiver.isDragEnd(event.pointerId)) {
                    object.events.emit('pointerdragend', event);
                }
            }
            lastUpPerPointer.set(event.pointerId, event);
        }
        return lastUpPerPointer;
    }
    _processMoveAndEmit(receiver, object) {
        const lastMovePerPointer = new Map();
        // Loop through move and dispatch to entities
        for (const event of receiver.currentFrameMove) {
            if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
                // move
                object.events.emit('pointermove', event);
                if (receiver.isDragging(event.pointerId)) {
                    object.events.emit('pointerdragmove', event);
                }
            }
            lastMovePerPointer.set(event.pointerId, event);
        }
        return lastMovePerPointer;
    }
    _processEnterLeaveAndEmit(receiver, object, lastUpDownMoveEvents) {
        // up, down, and move are considered for enter and leave
        for (const event of lastUpDownMoveEvents) {
            // enter
            if (event.active && object.active() && this._entered(object, event.pointerId)) {
                object.events.emit('pointerenter', event);
                if (receiver.isDragging(event.pointerId)) {
                    object.events.emit('pointerdragenter', event);
                }
                break;
            }
            if (event.active &&
                object.active() &&
                // leave can happen on move
                (this._left(object, event.pointerId) ||
                    // or leave can happen on pointer up
                    (this._objectCurrentlyUnderPointer(object, event.pointerId) && event.type === 'up'))) {
                object.events.emit('pointerleave', event);
                if (receiver.isDragging(event.pointerId)) {
                    object.events.emit('pointerdragleave', event);
                }
                break;
            }
        }
    }
    _processCancelAndEmit(receiver, object) {
        // cancel
        for (const event of receiver.currentFrameCancel) {
            if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
                object.events.emit('pointercancel', event);
            }
        }
    }
    _processWheelAndEmit(receiver, object) {
        // wheel
        for (const event of receiver.currentFrameWheel) {
            // Currently the wheel only fires under the primary pointer '0'
            if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, 0)) {
                object.events.emit('pointerwheel', event);
            }
        }
    }
}


/***/ }),

/***/ "./Input/PointerScope.ts":
/*!*******************************!*\
  !*** ./Input/PointerScope.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1294084__) => {

__nested_webpack_require_1294084__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1294084__.d(__nested_webpack_exports__, {
/* harmony export */   PointerScope: () => (/* binding */ PointerScope)
/* harmony export */ });
/**
 * Determines the scope of handling mouse/touch events.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));


/***/ }),

/***/ "./Input/PointerSystem.ts":
/*!********************************!*\
  !*** ./Input/PointerSystem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1295002__) => {

__nested_webpack_require_1295002__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1295002__.d(__nested_webpack_exports__, {
/* harmony export */   PointerSystem: () => (/* binding */ PointerSystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1295002__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1295002__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1295002__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1295002__(/*! ../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _PointerComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1295002__(/*! ./PointerComponent */ "./Input/PointerComponent.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1295002__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Collision_Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1295002__(/*! ../Collision/Detection/SparseHashGrid */ "./Collision/Detection/SparseHashGrid.ts");
/* harmony import */ var _PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1295002__(/*! ./PointerEventsToObjectDispatcher */ "./Input/PointerEventsToObjectDispatcher.ts");






/**
 * The PointerSystem is responsible for dispatching pointer events to entities
 * that need them.
 *
 * The PointerSystem can be optionally configured by the {@apilink PointerComponent}, by default Entities use
 * the {@apilink Collider}'s shape for pointer events.
 */
class PointerSystem extends _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_0__.SystemType.Update;
        this._graphicsHashGrid = new _Collision_Detection_SparseHashGrid__WEBPACK_IMPORTED_MODULE_1__.SparseHashGrid({ size: 100 });
        this._graphics = [];
        this._entityToPointer = new Map();
        this._pointerEventDispatcher = new _PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_2__.PointerEventsToObjectDispatcher();
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseColliderShape = false;
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseGraphicsBounds = false;
        this._sortedTransforms = [];
        this._sortedEntities = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
        this.query = this.world.query([_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__.TransformComponent, _PointerComponent__WEBPACK_IMPORTED_MODULE_4__.PointerComponent]);
        this.query.entityAdded$.subscribe((e) => {
            const tx = e.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
            const pointer = e.get(_PointerComponent__WEBPACK_IMPORTED_MODULE_4__.PointerComponent);
            this._pointerEventDispatcher.addObject(e, (pos) => {
                // If pointer bounds defined
                if (pointer && pointer.localBounds) {
                    const pointerBounds = pointer.localBounds.transform(tx.get().matrix);
                    return pointerBounds.contains(tx.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane.World ? pos.worldPos : pos.screenPos);
                }
                return false;
            }, () => e.isActive);
            this._entityToPointer.set(e, pointer);
            const maybeGfx = e.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_6__.GraphicsComponent);
            if (maybeGfx) {
                this._graphics.push(maybeGfx);
                this._graphicsHashGrid.track(maybeGfx);
            }
            this._sortedTransforms.push(tx);
            this._sortedEntities.push(tx.owner);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        });
        this.query.entityRemoved$.subscribe((e) => {
            this._pointerEventDispatcher.removeObject(e);
            const tx = e.get(_EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__.TransformComponent);
            this._entityToPointer.delete(e);
            const maybeGfx = e.get(_Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_6__.GraphicsComponent);
            if (maybeGfx) {
                const index = this._graphics.indexOf(maybeGfx);
                if (index > -1) {
                    this._graphics.splice(index, 1);
                }
                this._graphicsHashGrid.untrack(maybeGfx);
            }
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
                this._sortedEntities.splice(index, 1);
            }
        });
    }
    initialize(world, scene) {
        this._engine = scene.engine;
        this._scene = scene;
    }
    preupdate() {
        if (this._scene.camera.hasChanged()) {
            // if the camera has changed we want to force a transform update so pointers can be correctly calc'd
            this._scene.camera.updateTransform(this._scene.camera.pos);
        }
        // event receiver might change per frame
        this._receivers = [this._engine.input.pointers, this._scene.input.pointers];
        this._engineReceiver = this._engine.input.pointers;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return b.z - a.z;
            });
            this._sortedEntities = this._sortedTransforms.map((t) => t.owner);
            this._zHasChanged = false;
        }
    }
    update() {
        // Update graphics
        this._graphicsHashGrid.update(this._graphics);
        // Locate all the pointer/entity mappings
        for (const [pointerId, pos] of this._engineReceiver.currentFramePointerCoords.entries()) {
            const colliders = this._scene.physics.query(pos.worldPos);
            for (let i = 0; i < colliders.length; i++) {
                const collider = colliders[i];
                const maybePointer = this._entityToPointer.get(collider.owner);
                if (maybePointer && (maybePointer.useColliderShape || this.overrideUseColliderShape)) {
                    this._pointerEventDispatcher.addPointerToObject(collider.owner, pointerId);
                }
            }
            const graphics = this._graphicsHashGrid.query(pos.worldPos);
            for (let i = 0; i < graphics.length; i++) {
                const graphic = graphics[i];
                const maybePointer = this._entityToPointer.get(graphic.owner);
                if (maybePointer && (maybePointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {
                    this._pointerEventDispatcher.addPointerToObject(graphic.owner, pointerId);
                }
            }
        }
        this._pointerEventDispatcher.processPointerToObject(this._engineReceiver, this._sortedEntities);
        // Dispatch pointer events on entities
        this._pointerEventDispatcher.dispatchEvents(this._engineReceiver, this._sortedEntities);
        // Dispatch pointer events on top level pointers
        this._receivers.forEach((r) => r.update());
        // Clear last frame's events
        this._pointerEventDispatcher.clear();
        this._receivers.forEach((r) => r.clear());
    }
}
PointerSystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_7__.SystemPriority.Higher;


/***/ }),

/***/ "./Input/PointerType.ts":
/*!******************************!*\
  !*** ./Input/PointerType.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1303249__) => {

__nested_webpack_require_1303249__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1303249__.d(__nested_webpack_exports__, {
/* harmony export */   PointerType: () => (/* binding */ PointerType)
/* harmony export */ });
/**
 * The type of pointer for a {@apilink PointerEvent}.
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));


/***/ }),

/***/ "./Input/WheelDeltaMode.ts":
/*!*********************************!*\
  !*** ./Input/WheelDeltaMode.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1303987__) => {

__nested_webpack_require_1303987__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1303987__.d(__nested_webpack_exports__, {
/* harmony export */   WheelDeltaMode: () => (/* binding */ WheelDeltaMode)
/* harmony export */ });
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));


/***/ }),

/***/ "./Input/WheelEvent.ts":
/*!*****************************!*\
  !*** ./Input/WheelEvent.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1304634__) => {

__nested_webpack_require_1304634__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1304634__.d(__nested_webpack_exports__, {
/* harmony export */   WheelEvent: () => (/* binding */ WheelEvent)
/* harmony export */ });
class WheelEvent {
    cancel() {
        this.active = false;
    }
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this.active = true;
    }
}


/***/ }),

/***/ "./Interfaces/AudioImplementation.ts":
/*!*******************************************!*\
  !*** ./Interfaces/AudioImplementation.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1305665__) => {

__nested_webpack_require_1305665__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1305665__.d(__nested_webpack_exports__, {
/* harmony export */   ExResponse: () => (/* binding */ ExResponse)
/* harmony export */ });
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};


/***/ }),

/***/ "./Interfaces/Index.ts":
/*!*****************************!*\
  !*** ./Interfaces/Index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1306265__) => {

__nested_webpack_require_1306265__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1306265__.d(__nested_webpack_exports__, {
/* harmony export */   ExResponse: () => (/* reexport safe */ _AudioImplementation__WEBPACK_IMPORTED_MODULE_0__.ExResponse),
/* harmony export */   hasOnAdd: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasOnAdd),
/* harmony export */   hasOnInitialize: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasOnInitialize),
/* harmony export */   hasOnPostUpdate: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasOnPostUpdate),
/* harmony export */   hasOnPreUpdate: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasOnPreUpdate),
/* harmony export */   hasOnRemove: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasOnRemove),
/* harmony export */   hasPostDraw: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasPostDraw),
/* harmony export */   hasPreDraw: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.hasPreDraw),
/* harmony export */   has_add: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.has_add),
/* harmony export */   has_initialize: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.has_initialize),
/* harmony export */   has_postupdate: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.has_postupdate),
/* harmony export */   has_preupdate: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.has_preupdate),
/* harmony export */   has_remove: () => (/* reexport safe */ _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__.has_remove)
/* harmony export */ });
/* harmony import */ var _AudioImplementation__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1306265__(/*! ./AudioImplementation */ "./Interfaces/AudioImplementation.ts");
/* harmony import */ var _LifecycleEvents__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1306265__(/*! ./LifecycleEvents */ "./Interfaces/LifecycleEvents.ts");









/***/ }),

/***/ "./Interfaces/LifecycleEvents.ts":
/*!***************************************!*\
  !*** ./Interfaces/LifecycleEvents.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1308616__) => {

__nested_webpack_require_1308616__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1308616__.d(__nested_webpack_exports__, {
/* harmony export */   hasOnAdd: () => (/* binding */ hasOnAdd),
/* harmony export */   hasOnInitialize: () => (/* binding */ hasOnInitialize),
/* harmony export */   hasOnPostUpdate: () => (/* binding */ hasOnPostUpdate),
/* harmony export */   hasOnPreUpdate: () => (/* binding */ hasOnPreUpdate),
/* harmony export */   hasOnRemove: () => (/* binding */ hasOnRemove),
/* harmony export */   hasPostDraw: () => (/* binding */ hasPostDraw),
/* harmony export */   hasPreDraw: () => (/* binding */ hasPreDraw),
/* harmony export */   has_add: () => (/* binding */ has_add),
/* harmony export */   has_initialize: () => (/* binding */ has_initialize),
/* harmony export */   has_postupdate: () => (/* binding */ has_postupdate),
/* harmony export */   has_preupdate: () => (/* binding */ has_preupdate),
/* harmony export */   has_remove: () => (/* binding */ has_remove)
/* harmony export */ });
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function has_add(a) {
    return !!a.onAdd;
}
/**
 *
 */
function has_remove(a) {
    return !!a.onRemove;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnAdd(a) {
    return !!a.onAdd;
}
/**
 *
 */
function hasOnRemove(a) {
    return !!a.onRemove;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}


/***/ }),

/***/ "./Label.ts":
/*!******************!*\
  !*** ./Label.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1310678__) => {

__nested_webpack_require_1310678__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1310678__.d(__nested_webpack_exports__, {
/* harmony export */   Label: () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1310678__(/*! ./Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Graphics_Text__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1310678__(/*! ./Graphics/Text */ "./Graphics/Text.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1310678__(/*! ./Graphics */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Graphics_Font__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1310678__(/*! ./Graphics/Font */ "./Graphics/Font.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1310678__(/*! ./Actor */ "./Actor.ts");





/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label extends _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor {
    set maxWidth(width) {
        this._text.maxWidth = width;
    }
    get maxWidth() {
        return this._text.maxWidth;
    }
    get font() {
        return this._font;
    }
    set font(newFont) {
        this._font = newFont;
        this._text.font = newFont;
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        if (this._text) {
            this._text.color = color;
        }
    }
    get opacity() {
        return this.graphics.opacity;
    }
    set opacity(opacity) {
        this.graphics.opacity = opacity;
    }
    /**
     * The {@apilink SpriteFont} to use, if any. Overrides {@apilink Font | `font`} if present.
     */
    get spriteFont() {
        return this._spriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this._font = new _Graphics_Font__WEBPACK_IMPORTED_MODULE_1__.Font();
        this._text = new _Graphics_Text__WEBPACK_IMPORTED_MODULE_2__.Text({ text: '', font: this._font });
        const { text, pos, x, y, spriteFont, font, color, maxWidth } = { text: '', ...options };
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.maxWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : this.maxWidth;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this._text.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(_Graphics__WEBPACK_IMPORTED_MODULE_4__.GraphicsComponent);
        gfx.anchor = _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero;
        gfx.use(this._text);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
}


/***/ }),

/***/ "./Math/Random.ts":
/*!************************!*\
  !*** ./Math/Random.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1314362__) => {

__nested_webpack_require_1314362__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1314362__.d(__nested_webpack_exports__, {
/* harmony export */   Random: () => (/* binding */ Random)
/* harmony export */ });
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}


/***/ }),

/***/ "./Math/affine-matrix.ts":
/*!*******************************!*\
  !*** ./Math/affine-matrix.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1323143__) => {

__nested_webpack_require_1323143__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1323143__.d(__nested_webpack_exports__, {
/* harmony export */   AffineMatrix: () => (/* binding */ AffineMatrix)
/* harmony export */ });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1323143__(/*! ./matrix */ "./Math/matrix.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1323143__(/*! ./util */ "./Math/util.ts");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1323143__(/*! ./vector */ "./Math/vector.ts");



class AffineMatrix {
    constructor() {
        /**
         * |         |         |          |
         * | ------- | ------- | -------- |
         * | data[0] | data[2] | data[4]  |
         * | data[1] | data[3] | data[5]  |
         * |   0     |    0    |    1     |
         */
        this.data = new Float64Array(6);
        this._scale = new Float64Array([1, 1]);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static identity() {
        const mat = new AffineMatrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = AffineMatrix.identity();
        mat.data[4] = x;
        mat.data[5] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = AffineMatrix.identity();
        mat.data[0] = sx;
        mat.data[3] = sy;
        mat._scale[0] = sx;
        mat._scale[1] = sy;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle in radians
     * @param angle
     */
    static rotation(angle) {
        const mat = AffineMatrix.identity();
        mat.data[0] = Math.cos(angle);
        mat.data[1] = Math.sin(angle);
        mat.data[2] = -Math.sin(angle);
        mat.data[3] = Math.cos(angle);
        return mat;
    }
    setPosition(x, y) {
        this.data[4] = x;
        this.data[5] = y;
    }
    getPosition() {
        return (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[4], this.data[5]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a12 - sine * a11;
        this.data[3] = cosine * a22 - sine * a21;
        return this;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        // const a31 = 0;
        const a12 = this.data[2];
        const a22 = this.data[3];
        // const a32 = 0;
        const a13 = this.data[4];
        const a23 = this.data[5];
        // const a33 = 1;
        // Doesn't change z
        this.data[4] = a11 * x + a12 * y + a13;
        this.data[5] = a21 * x + a22 * y + a23;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a12 * y;
        this.data[3] = a22 * y;
        this._scale[0] = x;
        this._scale[1] = y;
        this._scaleSignX = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(x);
        this._scaleSignY = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(y);
        return this;
    }
    determinant() {
        return this.data[0] * this.data[3] - this.data[1] * this.data[2];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    inverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.determinant();
        let inverseDet = det; // default to a zero matrix if we have a singular matrix
        if (det !== 0) {
            inverseDet = 1 / det;
        }
        const a = this.data[0];
        const b = this.data[2];
        const c = this.data[1];
        const d = this.data[3];
        const m = target || AffineMatrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[2] = -b * inverseDet;
        m.data[3] = a * inverseDet;
        const tx = this.data[4];
        const ty = this.data[5];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[4] = -(tx * m.data[0] + ty * m.data[2]);
        m.data[5] = -(tx * m.data[1] + ty * m.data[3]);
        return m;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof _vector__WEBPACK_IMPORTED_MODULE_0__.Vector) {
            const result = dest || new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];
            const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new AffineMatrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            //  const a31 = 0;
            const a12 = this.data[2];
            const a22 = this.data[3];
            //  const a32 = 0;
            const a13 = this.data[4];
            const a23 = this.data[5];
            //  const a33 = 1;
            const b11 = other.data[0];
            const b21 = other.data[1];
            //  const b31 = 0;
            const b12 = other.data[2];
            const b22 = other.data[3];
            //  const b32 = 0;
            const b13 = other.data[4];
            const b23 = other.data[5];
            //  const b33 = 1;
            result.data[0] = a11 * b11 + a12 * b21; // + a13 * b31; // zero
            result.data[1] = a21 * b11 + a22 * b21; // + a23 * b31; // zero
            result.data[2] = a11 * b12 + a12 * b22; // + a13 * b32; // zero
            result.data[3] = a21 * b12 + a22 * b22; // + a23 * b32; // zero
            result.data[4] = a11 * b13 + a12 * b23 + a13; // * b33; // one
            result.data[5] = a21 * b13 + a22 * b23 + a23; // * b33; // one
            const signX = this._scaleSignX;
            const signY = this._scaleSignY;
            result._scaleSignX = signX * (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(result._scaleSignX);
            result._scaleSignY = signY * (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(result._scaleSignY);
            return result;
        }
    }
    /**
     * Packed array of length 8, that contains 4 vertices, with 2 components each
     * So: [x0, y0, x1, y1, x2, y2, x3, y3]
     * @param quad
     */
    multiplyQuadInPlace(quad) {
        const resultTopLeftX = quad[0] * this.data[0] + quad[1] * this.data[2] + this.data[4];
        const resultTopLeftY = quad[0] * this.data[1] + quad[1] * this.data[3] + this.data[5];
        quad[0] = resultTopLeftX;
        quad[1] = resultTopLeftY;
        const resultTopRightX = quad[2] * this.data[0] + quad[3] * this.data[2] + this.data[4];
        const resultTopRightY = quad[2] * this.data[1] + quad[3] * this.data[3] + this.data[5];
        quad[2] = resultTopRightX;
        quad[3] = resultTopRightY;
        const resultBottomLeftX = quad[4] * this.data[0] + quad[5] * this.data[2] + this.data[4];
        const resultBottomLeftY = quad[4] * this.data[1] + quad[5] * this.data[3] + this.data[5];
        quad[4] = resultBottomLeftX;
        quad[5] = resultBottomLeftY;
        const resultBottomRightX = quad[6] * this.data[0] + quad[7] * this.data[2] + this.data[4];
        const resultBottomRightY = quad[6] * this.data[1] + quad[7] * this.data[3] + this.data[5];
        quad[6] = resultBottomRightX;
        quad[7] = resultBottomRightY;
    }
    to4x4() {
        const mat = new _matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = this.data[2];
        mat.data[5] = this.data[3];
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = this.data[4];
        mat.data[13] = this.data[5];
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[2] = -sine * currentScale.x;
        this.data[3] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.canonicalizeAngle)(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xScaleSq = this.data[0] * this.data[0] + this.data[2] * this.data[2];
        if (xScaleSq === 1.0) {
            // usually there isn't scale so we can avoid a sqrt
            return this._scaleSignX;
        }
        return this._scaleSignX * Math.sqrt(xScaleSq);
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yScaleSq = this.data[1] * this.data[1] + this.data[3] * this.data[3];
        if (yScaleSq === 1.0) {
            // usually there isn't scale so we can avoid a sqrt
            return this._scaleSignY;
        }
        return this._scaleSignY * Math.sqrt(yScaleSq);
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (val === this._scale[0]) {
            return;
        }
        this._scaleSignX = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[2] = xscale.y * val;
        this._scale[0] = val;
    }
    setScaleY(val) {
        if (val === this._scale[1]) {
            return;
        }
        this._scaleSignY = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[3] = yscale.y * val;
        this._scale[1] = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    isIdentity() {
        return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 1 && this.data[4] === 0 && this.data[5] === 0;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {AffineMatrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current {@apilink AffineMatrix}
     */
    clone(dest) {
        const mat = dest || new AffineMatrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat._scaleSignX = this._scaleSignX;
        mat._scaleSignY = this._scaleSignY;
        return mat;
    }
    toString() {
        return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
    }
}


/***/ }),

/***/ "./Math/bezier-curve.ts":
/*!******************************!*\
  !*** ./Math/bezier-curve.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1337081__) => {

__nested_webpack_require_1337081__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1337081__.d(__nested_webpack_exports__, {
/* harmony export */   BezierCurve: () => (/* binding */ BezierCurve)
/* harmony export */ });
/* harmony import */ var _lerp__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1337081__(/*! ./lerp */ "./Math/lerp.ts");

/**
 * BezierCurve that supports cubic Bezier curves.
 */
class BezierCurve {
    constructor(options) {
        var _a;
        // Thanks Freya! https://www.youtube.com/watch?v=aVwxzDHniEw
        this._distLookup = [];
        this.quality = 4;
        if (options.controlPoints.length !== 4) {
            throw new Error('Only cubic bezier curves are supported');
        }
        this._controlPoints = [...options.controlPoints];
        this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;
        this._calculateLookup();
    }
    get arcLength() {
        return this._arcLength;
    }
    get controlPoints() {
        return this._controlPoints;
    }
    set controlPoints(points) {
        this._controlPoints = [...points];
        this._calculateLookup();
    }
    setControlPoint(index, point) {
        this._controlPoints[index] = point;
        this._calculateLookup();
    }
    _calculateLookup() {
        let totalLength = 0;
        this._distLookup.length = 0;
        let prev = this.controlPoints[0];
        const n = this.controlPoints.length * this.quality;
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const pt = this.getPoint(t);
            const diff = prev.distance(pt);
            totalLength += diff;
            this._distLookup.push(totalLength);
            prev = pt;
        }
        this._arcLength = totalLength;
    }
    _getTimeGivenDistance(distance) {
        const n = this._distLookup.length;
        const arcLength = this.arcLength;
        if (distance >= 0 && distance < arcLength) {
            for (let i = 0; i < n - 1; i++) {
                if (this._distLookup[i] <= distance && distance < this._distLookup[i + 1]) {
                    return (0,_lerp__WEBPACK_IMPORTED_MODULE_0__.remap)(this._distLookup[i], this._distLookup[i + 1], i / (n - 1), (i + 1) / (n - 1), distance);
                }
            }
        }
        return distance / arcLength;
    }
    /**
     * Get the point on the Bezier curve at a certain time
     * @param time Between 0-1
     */
    getPoint(time) {
        const points = [...this.controlPoints];
        for (let r = 1; r < points.length; r++) {
            for (let i = 0; i < points.length - r; i++) {
                points[i] = (0,_lerp__WEBPACK_IMPORTED_MODULE_0__.lerpVector)(points[i], points[i + 1], time);
            }
        }
        return points[0];
    }
    /**
     * Get the tangent of the Bezier curve at a certain time
     * @param time Between 0-1
     */
    getTangent(time) {
        const timeSquared = time * time;
        const p0 = this.controlPoints[0];
        const p1 = this.controlPoints[1];
        const p2 = this.controlPoints[2];
        const p3 = this.controlPoints[3];
        // Derivative of Bernstein polynomial
        const pPrime = p0
            .scale(-3 * timeSquared + 6 * time - 3)
            .add(p1.scale(9 * timeSquared - 12 * time + 3).add(p2.scale(-9 * timeSquared + 6 * time).add(p3.scale(3 * timeSquared))));
        return pPrime.normalize();
    }
    /**
     * Get the tangent of the Bezier curve where the distance is uniformly distributed over time
     * @param time
     */
    getUniformTangent(time) {
        const desiredDistance = time * this.arcLength;
        const uniformTime = this._getTimeGivenDistance(desiredDistance);
        return this.getTangent(uniformTime);
    }
    /**
     * Get the normal of the Bezier curve at a certain time
     * @param time Between 0-1
     */
    getNormal(time) {
        return this.getTangent(time).normal();
    }
    /**
     * Get the normal of the Bezier curve where the distance is uniformly distributed over time
     * @param time
     */
    getUniformNormal(time) {
        return this.getUniformTangent(time).normal();
    }
    /**
     * Points are spaced uniformly across the length of the curve over time
     * @param time
     */
    getUniformPoint(time) {
        const desiredDistance = time * this.arcLength;
        const uniformTime = this._getTimeGivenDistance(desiredDistance);
        return this.getPoint(uniformTime);
    }
    clone() {
        return new BezierCurve({
            controlPoints: [...this.controlPoints],
            quality: this.quality
        });
    }
}


/***/ }),

/***/ "./Math/coord-plane.ts":
/*!*****************************!*\
  !*** ./Math/coord-plane.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1341933__) => {

__nested_webpack_require_1341933__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1341933__.d(__nested_webpack_exports__, {
/* harmony export */   CoordPlane: () => (/* binding */ CoordPlane)
/* harmony export */ });
/**
 * Enum representing the coordinate plane for the position 2D vector in the {@apilink TransformComponent}
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));


/***/ }),

/***/ "./Math/global-coordinates.ts":
/*!************************************!*\
  !*** ./Math/global-coordinates.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1342980__) => {

__nested_webpack_require_1342980__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1342980__.d(__nested_webpack_exports__, {
/* harmony export */   GlobalCoordinates: () => (/* binding */ GlobalCoordinates)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1342980__(/*! ./vector */ "./Math/vector.ts");

class GlobalCoordinates {
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
}


/***/ }),

/***/ "./Math/index.ts":
/*!***********************!*\
  !*** ./Math/index.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1344460__) => {

__nested_webpack_require_1344460__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1344460__.d(__nested_webpack_exports__, {
/* harmony export */   AffineMatrix: () => (/* reexport safe */ _affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix),
/* harmony export */   BezierCurve: () => (/* reexport safe */ _bezier_curve__WEBPACK_IMPORTED_MODULE_12__.BezierCurve),
/* harmony export */   CoordPlane: () => (/* reexport safe */ _coord_plane__WEBPACK_IMPORTED_MODULE_5__.CoordPlane),
/* harmony export */   GlobalCoordinates: () => (/* reexport safe */ _global_coordinates__WEBPACK_IMPORTED_MODULE_7__.GlobalCoordinates),
/* harmony export */   LineSegment: () => (/* reexport safe */ _line_segment__WEBPACK_IMPORTED_MODULE_8__.LineSegment),
/* harmony export */   Matrix: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix),
/* harmony export */   MatrixLocations: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixLocations),
/* harmony export */   Projection: () => (/* reexport safe */ _projection__WEBPACK_IMPORTED_MODULE_9__.Projection),
/* harmony export */   Random: () => (/* reexport safe */ _Random__WEBPACK_IMPORTED_MODULE_6__.Random),
/* harmony export */   Ray: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_10__.Ray),
/* harmony export */   RotationType: () => (/* reexport safe */ _rotation_type__WEBPACK_IMPORTED_MODULE_14__.RotationType),
/* harmony export */   Transform: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_4__.Transform),
/* harmony export */   TwoPI: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.TwoPI),
/* harmony export */   Vector: () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_0__.Vector),
/* harmony export */   VectorView: () => (/* reexport safe */ _vector_view__WEBPACK_IMPORTED_MODULE_1__.VectorView),
/* harmony export */   approximatelyEqual: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.approximatelyEqual),
/* harmony export */   canonicalizeAngle: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.canonicalizeAngle),
/* harmony export */   clamp: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.clamp),
/* harmony export */   frac: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.frac),
/* harmony export */   inverseLerp: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.inverseLerp),
/* harmony export */   inverseLerpVector: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.inverseLerpVector),
/* harmony export */   lerp: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.lerp),
/* harmony export */   lerpAngle: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.lerpAngle),
/* harmony export */   lerpVector: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.lerpVector),
/* harmony export */   randomInRange: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.randomInRange),
/* harmony export */   randomIntInRange: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.randomIntInRange),
/* harmony export */   range: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.range),
/* harmony export */   remap: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.remap),
/* harmony export */   remapVector: () => (/* reexport safe */ _lerp__WEBPACK_IMPORTED_MODULE_11__.remapVector),
/* harmony export */   sign: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.sign),
/* harmony export */   toDegrees: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.toDegrees),
/* harmony export */   toRadians: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_13__.toRadians),
/* harmony export */   vec: () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_0__.vec)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1344460__(/*! ./vector */ "./Math/vector.ts");
/* harmony import */ var _vector_view__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1344460__(/*! ./vector-view */ "./Math/vector-view.ts");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1344460__(/*! ./matrix */ "./Math/matrix.ts");
/* harmony import */ var _affine_matrix__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1344460__(/*! ./affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1344460__(/*! ./transform */ "./Math/transform.ts");
/* harmony import */ var _coord_plane__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1344460__(/*! ./coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Random__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1344460__(/*! ./Random */ "./Math/Random.ts");
/* harmony import */ var _global_coordinates__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1344460__(/*! ./global-coordinates */ "./Math/global-coordinates.ts");
/* harmony import */ var _line_segment__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1344460__(/*! ./line-segment */ "./Math/line-segment.ts");
/* harmony import */ var _projection__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1344460__(/*! ./projection */ "./Math/projection.ts");
/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1344460__(/*! ./ray */ "./Math/ray.ts");
/* harmony import */ var _lerp__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1344460__(/*! ./lerp */ "./Math/lerp.ts");
/* harmony import */ var _bezier_curve__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1344460__(/*! ./bezier-curve */ "./Math/bezier-curve.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1344460__(/*! ./util */ "./Math/util.ts");
/* harmony import */ var _rotation_type__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_1344460__(/*! ./rotation-type */ "./Math/rotation-type.ts");

















/***/ }),

/***/ "./Math/lerp.ts":
/*!**********************!*\
  !*** ./Math/lerp.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1350473__) => {

__nested_webpack_require_1350473__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1350473__.d(__nested_webpack_exports__, {
/* harmony export */   inverseLerp: () => (/* binding */ inverseLerp),
/* harmony export */   inverseLerpVector: () => (/* binding */ inverseLerpVector),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   lerpAngle: () => (/* binding */ lerpAngle),
/* harmony export */   lerpVector: () => (/* binding */ lerpVector),
/* harmony export */   remap: () => (/* binding */ remap),
/* harmony export */   remapVector: () => (/* binding */ remapVector)
/* harmony export */ });
/* harmony import */ var _rotation_type__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1350473__(/*! ./rotation-type */ "./Math/rotation-type.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1350473__(/*! ./util */ "./Math/util.ts");


/**
 * Linear interpolation between `a` and `b`, at `time = 0` the value will be `a` at `time = 1` the value will be `b`
 * @param a
 * @param b
 * @param time
 */
function lerp(a, b, time) {
    return (1 - time) * a + b * time;
}
/**
 * Linear interpolation between angles in radians
 * @param startAngle
 * @param endAngle
 * @param rotationType
 * @param time
 */
function lerpAngle(startAngle, endAngle, rotationType, time) {
    const shortestPathIsPositive = (startAngle - endAngle + _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI) % _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI >= Math.PI;
    const distance1 = Math.abs(endAngle - startAngle);
    const distance2 = _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI - distance1;
    let shortDistance = 0;
    let longDistance = 0;
    if (distance1 > distance2) {
        shortDistance = distance2;
        longDistance = distance1;
    }
    else {
        shortDistance = distance1;
        longDistance = distance2;
    }
    let distance = 0;
    let direction = 1;
    switch (rotationType) {
        case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.ShortestPath:
            distance = shortDistance;
            direction = shortestPathIsPositive ? 1 : -1;
            break;
        case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.LongestPath:
            distance = longDistance;
            direction = shortestPathIsPositive ? -1 : 1;
            break;
        case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.Clockwise:
            direction = 1;
            distance = shortestPathIsPositive ? shortDistance : longDistance;
            break;
        case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.CounterClockwise:
            direction = -1;
            distance = shortestPathIsPositive ? longDistance : shortDistance;
            break;
    }
    return startAngle + direction * (distance * time);
}
/**
 * Linear interpolation between `a` and `b`, at `time = 0` the value will be `a` at `time = 1` the value will be `b`
 * @param a
 * @param b
 * @param time
 */
function lerpVector(a, b, time) {
    return a.scale(1 - time).add(b.scale(time));
}
/**
 * Inverse of a linear interpolation, given a `value` in between `a` and `b` return how close to `a` or `b` the `value` is.
 *
 * Example: `a=1`, `b=5`, `value=4` will return `.75`
 * @param a
 * @param b
 * @param value
 */
function inverseLerp(a, b, value) {
    return (value - a) / (b - a);
}
/**
 * Inverse of a linear interpolation, given a `value` in between `a` and `b` return how close to `a` or `b` the `value` is.
 *
 * **Warning** assumes that the `value` vector is co-linear with vector `a` and `b`
 *
 * Example: `a=1`, `b=5`, `value=4` will return `.75`
 * @param a
 * @param b
 * @param value
 */
function inverseLerpVector(a, b, value) {
    const numerator = value.sub(a);
    const denominator = b.sub(a);
    const x = numerator.x / denominator.x;
    const y = numerator.y / denominator.y;
    return Math.min(x, y);
}
/**
 * Remaps a value from a source domain to a destination
 * @param minSource
 * @param maxSource
 * @param minDestination
 * @param maxDestination
 * @param value
 */
function remap(minSource, maxSource, minDestination, maxDestination, value) {
    const time = inverseLerp(minSource, maxSource, value);
    return lerp(minDestination, maxDestination, time);
}
/**
 * Remaps a value from a source domain to a destination
 *
 * **Warning** assumes that the `value` vector is co-linear with vector `minSource` and `maxSource`
 * @param minSource
 * @param maxSource
 * @param minDestination
 * @param maxDestination
 * @param value
 */
function remapVector(minSource, maxSource, minDestination, maxDestination, value) {
    const time = inverseLerpVector(minSource, maxSource, value);
    return lerpVector(minDestination, maxDestination, time);
}


/***/ }),

/***/ "./Math/line-segment.ts":
/*!******************************!*\
  !*** ./Math/line-segment.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1355432__) => {

__nested_webpack_require_1355432__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1355432__.d(__nested_webpack_exports__, {
/* harmony export */   LineSegment: () => (/* binding */ LineSegment)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1355432__(/*! ./vector */ "./Math/vector.ts");

/**
 * A 2D line segment
 */
class LineSegment {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    clone(dest) {
        const result = dest || new LineSegment(this.begin.clone(), this.end.clone());
        result.begin = this.begin.clone(result.begin);
        result.end = this.end.clone(result.end);
        return result;
    }
    transform(matrix, dest) {
        const result = dest || new LineSegment(_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero, _vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero);
        result.begin = matrix.multiply(this.begin, result.begin);
        result.end = matrix.multiply(this.end, result.end);
        return result;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        if (this._normal) {
            return this._normal;
        }
        return (this._normal = this.end.sub(this.begin).normal());
    }
    dir() {
        if (this._dir) {
            return this._dir;
        }
        return (this._dir = this.end.sub(this.begin));
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        if (this._slope) {
            return this._slope;
        }
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return (this._slope = end.sub(begin).scale(1 / distance));
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new LineSegment(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length, normalize = true) {
        let dir = sideVector;
        if (normalize) {
            dir = dir.normalize();
        }
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new LineSegment(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof _vector__WEBPACK_IMPORTED_MODULE_0__.Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}


/***/ }),

/***/ "./Math/matrix.ts":
/*!************************!*\
  !*** ./Math/matrix.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1363243__) => {

__nested_webpack_require_1363243__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1363243__.d(__nested_webpack_exports__, {
/* harmony export */   Matrix: () => (/* binding */ Matrix),
/* harmony export */   MatrixLocations: () => (/* binding */ MatrixLocations)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1363243__(/*! ./util */ "./Math/util.ts");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1363243__(/*! ./vector */ "./Math/vector.ts");



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- | -------- |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleX = 1;
        this._scaleSignX = 1;
        this._scaleY = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
        const mat = dest || new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static fromFloat32Array(data) {
        const matrix = new Matrix();
        matrix.data = data;
        return matrix;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {Matrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle in radians
     * @param angle
     */
    static rotation(angle) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angle);
        mat.data[4] = -Math.sin(angle);
        mat.data[1] = Math.sin(angle);
        mat.data[5] = Math.cos(angle);
        return mat;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof _vector__WEBPACK_IMPORTED_MODULE_0__.Vector) {
            const result = dest || new _vector__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];
            const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new Matrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            const a31 = this.data[2];
            const a41 = this.data[3];
            const a12 = this.data[4];
            const a22 = this.data[5];
            const a32 = this.data[6];
            const a42 = this.data[7];
            const a13 = this.data[8];
            const a23 = this.data[9];
            const a33 = this.data[10];
            const a43 = this.data[11];
            const a14 = this.data[12];
            const a24 = this.data[13];
            const a34 = this.data[14];
            const a44 = this.data[15];
            const b11 = other.data[0];
            const b21 = other.data[1];
            const b31 = other.data[2];
            const b41 = other.data[3];
            const b12 = other.data[4];
            const b22 = other.data[5];
            const b32 = other.data[6];
            const b42 = other.data[7];
            const b13 = other.data[8];
            const b23 = other.data[9];
            const b33 = other.data[10];
            const b43 = other.data[11];
            const b14 = other.data[12];
            const b24 = other.data[13];
            const b34 = other.data[14];
            const b44 = other.data[15];
            result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            const s = this.getScale();
            result._scaleSignX = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(s.x) * (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(result._scaleSignX);
            result._scaleSignY = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(s.y) * (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(result._scaleSignY);
            return result;
        }
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.canonicalizeAngle)(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[0], this.data[4]).magnitude;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[1], this.data[5]).magnitude;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (this._scaleX === val) {
            return;
        }
        this._scaleSignX = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
        this._scaleX = val;
    }
    setScaleY(val) {
        if (this._scaleY === val) {
            return;
        }
        this._scaleSignY = (0,_util__WEBPACK_IMPORTED_MODULE_1__.sign)(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = (0,_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
        this._scaleY = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    getAffineInverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = target || Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}


/***/ }),

/***/ "./Math/projection.ts":
/*!****************************!*\
  !*** ./Math/projection.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1380168__) => {

__nested_webpack_require_1380168__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1380168__.d(__nested_webpack_exports__, {
/* harmony export */   Projection: () => (/* binding */ Projection)
/* harmony export */ });
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}


/***/ }),

/***/ "./Math/ray.ts":
/*!*********************!*\
  !*** ./Math/ray.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1381143__) => {

__nested_webpack_require_1381143__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1381143__.d(__nested_webpack_exports__, {
/* harmony export */   Ray: () => (/* binding */ Ray)
/* harmony export */ });
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}


/***/ }),

/***/ "./Math/rotation-type.ts":
/*!*******************************!*\
  !*** ./Math/rotation-type.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1383143__) => {

__nested_webpack_require_1383143__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1383143__.d(__nested_webpack_exports__, {
/* harmony export */   RotationType: () => (/* binding */ RotationType)
/* harmony export */ });
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType["ShortestPath"] = "shortest-path";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType["LongestPath"] = "longest-path";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType["Clockwise"] = "clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType["CounterClockwise"] = "counter-clockwise";
})(RotationType || (RotationType = {}));


/***/ }),

/***/ "./Math/transform.ts":
/*!***************************!*\
  !*** ./Math/transform.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1384524__) => {

__nested_webpack_require_1384524__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1384524__.d(__nested_webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _affine_matrix__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1384524__(/*! ./affine-matrix */ "./Math/affine-matrix.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1384524__(/*! ./util */ "./Math/util.ts");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1384524__(/*! ./vector */ "./Math/vector.ts");
/* harmony import */ var _vector_view__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1384524__(/*! ./vector-view */ "./Math/vector-view.ts");
/* harmony import */ var _watch_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1384524__(/*! ./watch-vector */ "./Math/watch-vector.ts");





class Transform {
    constructor() {
        this._parent = null;
        this._children = [];
        this._pos = new _watch_vector__WEBPACK_IMPORTED_MODULE_0__.WatchVector((0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0), () => {
            this.flagDirty();
        });
        this._globalPos = new _vector_view__WEBPACK_IMPORTED_MODULE_2__.VectorView({
            getX: () => this.matrix.data[4],
            getY: () => this.matrix.data[5],
            setX: (x) => {
                if (this.parent) {
                    const { x: newX } = this.parent.inverse.multiply((0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(x, this.pos.y));
                    this.pos.x = newX;
                }
                else {
                    this.pos.x = x;
                }
                if (x !== this.matrix.data[4]) {
                    this.flagDirty();
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const { y: newY } = this.parent.inverse.multiply((0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this.pos.x, y));
                    this.pos.y = newY;
                }
                else {
                    this.pos.y = y;
                }
                if (y !== this.matrix.data[5]) {
                    this.flagDirty();
                }
            }
        });
        this._rotation = 0;
        this._scale = new _watch_vector__WEBPACK_IMPORTED_MODULE_0__.WatchVector((0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1), () => {
            this.flagDirty();
        });
        this._globalScale = new _vector_view__WEBPACK_IMPORTED_MODULE_2__.VectorView({
            getX: () => (this.parent ? this.matrix.getScaleX() : this.scale.x),
            getY: () => (this.parent ? this.matrix.getScaleY() : this.scale.y),
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.scale.x = x / globalScaleX;
                }
                else {
                    this.scale.x = x;
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.scale.y = y / globalScaleY;
                }
                else {
                    this.scale.y = y;
                }
            }
        });
        this._z = 0;
        this._isDirty = false;
        this._isInverseDirty = false;
        this._matrix = _affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
        this._inverse = _affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
        this._scratch = _affine_matrix__WEBPACK_IMPORTED_MODULE_3__.AffineMatrix.identity();
    }
    get parent() {
        return this._parent;
    }
    set parent(transform) {
        if (this._parent) {
            const index = this._parent._children.indexOf(this);
            if (index > -1) {
                this._parent._children.splice(index, 1);
            }
        }
        this._parent = transform;
        if (this._parent) {
            this._parent._children.push(this);
        }
        this.flagDirty();
    }
    get children() {
        return this._children;
    }
    set pos(v) {
        this._pos.x = v.x;
        this._pos.y = v.y;
    }
    get pos() {
        return this._pos;
    }
    set globalPos(v) {
        let localPos = v.clone();
        if (this.parent) {
            localPos = this.parent.inverse.multiply(v);
        }
        if (!localPos.equals(this._pos)) {
            this._pos = localPos;
            this.flagDirty();
        }
    }
    get globalPos() {
        return this._globalPos;
    }
    set rotation(rotation) {
        const canonRotation = (0,_util__WEBPACK_IMPORTED_MODULE_4__.canonicalizeAngle)(rotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get rotation() {
        return this._rotation;
    }
    set globalRotation(rotation) {
        let inverseRotation = 0;
        if (this.parent) {
            inverseRotation = this.parent.globalRotation;
        }
        const canonRotation = (0,_util__WEBPACK_IMPORTED_MODULE_4__.canonicalizeAngle)(rotation + inverseRotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get globalRotation() {
        if (this.parent) {
            return this.matrix.getRotation();
        }
        return this.rotation;
    }
    set scale(v) {
        this._scale.x = v.x;
        this._scale.y = v.y;
    }
    get scale() {
        return this._scale;
    }
    set globalScale(v) {
        let inverseScale = (0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 1);
        if (this.parent) {
            inverseScale = this.parent.globalScale;
        }
        this.scale = v.scale((0,_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(1 / inverseScale.x, 1 / inverseScale.y));
    }
    get globalScale() {
        return this._globalScale;
    }
    set z(z) {
        this._z = z;
        this.flagDirty();
    }
    get z() {
        return this._z;
    }
    set globalZ(z) {
        if (this.parent) {
            this.z = z - this.parent.globalZ;
        }
        else {
            this.z = z;
        }
    }
    get globalZ() {
        if (this.parent) {
            return this.z + this.parent.globalZ;
        }
        return this.z;
    }
    /**
     * Calculates and returns the matrix representation of this transform
     *
     * Avoid mutating the matrix to update the transform, it is not the source of truth.
     * Update the transform pos, rotation, scale.
     */
    get matrix() {
        if (this._isDirty) {
            if (this.parent === null) {
                this._calculateMatrix().clone(this._matrix);
            }
            else {
                this.parent.matrix.multiply(this._calculateMatrix()).clone(this._matrix);
            }
            this._isDirty = false;
        }
        return this._matrix;
    }
    /**
     * Calculates and returns the inverse matrix representation of this transform
     */
    get inverse() {
        if (this._isInverseDirty) {
            this.matrix.inverse(this._inverse);
            this._isInverseDirty = false;
        }
        return this._inverse;
    }
    _calculateMatrix() {
        this._scratch.data[0] = Math.cos(this._rotation);
        this._scratch.data[1] = Math.sin(this._rotation);
        this._scratch.data[2] = -Math.sin(this._rotation);
        this._scratch.data[3] = Math.cos(this.rotation);
        this._scratch.data[4] = this._pos.x;
        this._scratch.data[5] = this._pos.y;
        this._scratch.scale(this._scale.x, this._scale.y);
        return this._scratch;
    }
    flagDirty() {
        this._isDirty = true;
        this._isInverseDirty = true;
        for (let i = 0; i < this._children.length; i++) {
            this._children[i].flagDirty();
        }
    }
    apply(point) {
        return this.matrix.multiply(point);
    }
    applyInverse(point) {
        return this.inverse.multiply(point);
    }
    setTransform(pos, rotation, scale) {
        this._pos.x = pos.x;
        this._pos.y = pos.y;
        this._rotation = (0,_util__WEBPACK_IMPORTED_MODULE_4__.canonicalizeAngle)(rotation);
        this._scale.x = scale.x;
        this._scale.y = scale.y;
        this.flagDirty();
    }
    /**
     * Returns true if the transform has a negative x scale or y scale, but not both
     */
    isMirrored() {
        const signBitX = (0,_util__WEBPACK_IMPORTED_MODULE_4__.sign)(this.scale.x) >>> 31;
        const signBitY = (0,_util__WEBPACK_IMPORTED_MODULE_4__.sign)(this.scale.y) >>> 31;
        const mirrored = signBitX ^ signBitY;
        return !!mirrored;
    }
    /**
     * Clones the current transform
     * **Warning does not clone the parent**
     * @param dest
     */
    clone(dest) {
        const target = dest !== null && dest !== void 0 ? dest : new Transform();
        this._pos.clone(target._pos);
        target._z = this._z;
        target._rotation = this._rotation;
        this._scale.clone(target._scale);
        target.flagDirty();
        return target;
    }
    /**
     * Clones but keeps the same parent reference
     */
    cloneWithParent(dest) {
        const target = dest !== null && dest !== void 0 ? dest : new Transform();
        this._pos.clone(target._pos);
        target._z = this._z;
        target._rotation = this._rotation;
        this._scale.clone(target._scale);
        target.parent = this.parent;
        target.flagDirty();
        return target;
    }
    toString() {
        return this.matrix.toString();
    }
}


/***/ }),

/***/ "./Math/util.ts":
/*!**********************!*\
  !*** ./Math/util.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1394388__) => {

__nested_webpack_require_1394388__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1394388__.d(__nested_webpack_exports__, {
/* harmony export */   TwoPI: () => (/* binding */ TwoPI),
/* harmony export */   approximatelyEqual: () => (/* binding */ approximatelyEqual),
/* harmony export */   canonicalizeAngle: () => (/* binding */ canonicalizeAngle),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   frac: () => (/* binding */ frac),
/* harmony export */   randomInRange: () => (/* binding */ randomInRange),
/* harmony export */   randomIntInRange: () => (/* binding */ randomIntInRange),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   toDegrees: () => (/* binding */ toDegrees),
/* harmony export */   toRadians: () => (/* binding */ toRadians)
/* harmony export */ });
/* harmony import */ var _Random__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1394388__(/*! ./Random */ "./Math/Random.ts");

/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Returns the fractional part of a number
 * @param x
 */
function frac(x) {
    if (x >= 0) {
        return x - Math.floor(x);
    }
    else {
        return x - Math.ceil(x);
    }
}
/**
 * Returns the sign of a number, if 0 returns 0
 */
function sign(val) {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
}
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Approximately equals
 */
function approximatelyEqual(val1, val2, tolerance) {
    // https://dev.to/alldanielscott/how-to-compare-numbers-correctly-in-javascript-1l4i
    return Math.abs(val1 - val2) < tolerance;
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI)
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle >= TwoPI) {
        while (tmpAngle >= TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new _Random__WEBPACK_IMPORTED_MODULE_0__.Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new _Random__WEBPACK_IMPORTED_MODULE_0__.Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}


/***/ }),

/***/ "./Math/vector-view.ts":
/*!*****************************!*\
  !*** ./Math/vector-view.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1397649__) => {

__nested_webpack_require_1397649__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1397649__.d(__nested_webpack_exports__, {
/* harmony export */   VectorView: () => (/* binding */ VectorView)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1397649__(/*! ./vector */ "./Math/vector.ts");

class VectorView extends _vector__WEBPACK_IMPORTED_MODULE_0__.Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}


/***/ }),

/***/ "./Math/vector.ts":
/*!************************!*\
  !*** ./Math/vector.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1398714__) => {

__nested_webpack_require_1398714__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1398714__.d(__nested_webpack_exports__, {
/* harmony export */   Vector: () => (/* binding */ Vector),
/* harmony export */   vec: () => (/* binding */ vec)
/* harmony export */ });
/* harmony import */ var _rotation_type__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1398714__(/*! ./rotation-type */ "./Math/rotation-type.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1398714__(/*! ./util */ "./Math/util.ts");


/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    static min(vec1, vec2) {
        return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));
    }
    static max(vec1, vec2) {
        return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));
    }
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = Vector.EQUALS_EPSILON) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the {@apilink magnitude}.
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return deltaX * deltaX + deltaY * deltaY;
    }
    /**
     * Clamps the current vector's magnitude mutating it
     * @param magnitude
     */
    clampMagnitude(magnitude) {
        const size = this.magnitude;
        const newSize = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(size, 0, magnitude);
        this.magnitude = newSize;
        return this;
    }
    /**
     * The size (magnitude) of the Vector
     * @deprecated Will be removed in v1, use Vector.magnitude
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     * @deprecated Will be removed in v1, use Vector.magnitude
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * The magnitude (length) of the Vector
     */
    get magnitude() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set magnitude(newMagnitude) {
        this.normalize().scale(newMagnitude, this);
    }
    /**
     * Normalizes a non-zero vector to have a magnitude of 1. Zero vectors return a new zero vector.
     */
    normalize() {
        const distance = this.distance();
        if (distance === 0) {
            return Vector.Zero;
        }
        return new Vector(this.x / distance, this.y / distance);
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale, dest) {
        const result = dest || new Vector(0, 0);
        if (sizeOrScale instanceof Vector) {
            result.x = this.x * sizeOrScale.x;
            result.y = this.y * sizeOrScale.y;
        }
        else {
            result.x = this.x * sizeOrScale;
            result.y = this.y * sizeOrScale;
        }
        return result;
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     * @param dest Optionally copy the result into a provided vector
     */
    add(v, dest) {
        if (dest) {
            dest.x = this.x + v.x;
            dest.y = this.y + v.y;
            return dest;
        }
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v, dest) {
        const result = dest || new Vector(0, 0);
        const x = this.x - v.x;
        const y = this.y - v.y;
        result.x = x;
        result.y = y;
        return result;
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector, in range [0, 2*PI)
     */
    toAngle() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_0__.canonicalizeAngle)(Math.atan2(this.y, this.x));
    }
    /**
     * Returns the difference in radians between the angle of this vector and given angle,
     * using the given rotation type.
     * @param angle in radians to which the vector has to be rotated, using {@apilink rotate}
     * @param rotationType what {@apilink RotationType} to use for the rotation
     * @returns the angle by which the vector needs to be rotated to match the given angle
     */
    angleBetween(angle, rotationType) {
        const startAngleRadians = this.toAngle();
        const endAngleRadians = (0,_util__WEBPACK_IMPORTED_MODULE_0__.canonicalizeAngle)(angle);
        let rotationClockwise = 0;
        let rotationAntiClockwise = 0;
        if (endAngleRadians > startAngleRadians) {
            rotationClockwise = endAngleRadians - startAngleRadians;
        }
        else {
            rotationClockwise = (_util__WEBPACK_IMPORTED_MODULE_0__.TwoPI - startAngleRadians + endAngleRadians) % _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI;
        }
        rotationAntiClockwise = (rotationClockwise - _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI) % _util__WEBPACK_IMPORTED_MODULE_0__.TwoPI;
        switch (rotationType) {
            case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.ShortestPath:
                if (Math.abs(rotationClockwise) < Math.abs(rotationAntiClockwise)) {
                    return rotationClockwise;
                }
                else {
                    return rotationAntiClockwise;
                }
            case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.LongestPath:
                if (Math.abs(rotationClockwise) > Math.abs(rotationAntiClockwise)) {
                    return rotationClockwise;
                }
                else {
                    return rotationAntiClockwise;
                }
            case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.Clockwise:
                return rotationClockwise;
            case _rotation_type__WEBPACK_IMPORTED_MODULE_1__.RotationType.CounterClockwise:
                return rotationAntiClockwise;
        }
    }
    /**
     * Rotates the current vector around a point by a certain angle in radians.
     * Positive angle means rotation clockwise.
     */
    rotate(angle, anchor, dest) {
        const result = dest || new Vector(0, 0);
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        result.x = x;
        result.y = y;
        return result;
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone(dest) {
        const v = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);
        v.x = this.x;
        v.y = this.y;
        return v;
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
/**
 * Get or set the vector equals epsilon, by default 0.001 meaning vectors within that tolerance on x or y will be considered equal.
 */
Vector.EQUALS_EPSILON = 0.001;
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}


/***/ }),

/***/ "./Math/watch-vector.ts":
/*!******************************!*\
  !*** ./Math/watch-vector.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1412310__) => {

__nested_webpack_require_1412310__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1412310__.d(__nested_webpack_exports__, {
/* harmony export */   WatchVector: () => (/* binding */ WatchVector)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1412310__(/*! ./vector */ "./Math/vector.ts");

/**
 * Wraps a vector and watches for changes in the x/y, modifies the original vector.
 */
class WatchVector extends _vector__WEBPACK_IMPORTED_MODULE_0__.Vector {
    constructor(original, change) {
        super(original.x, original.y);
        this.original = original;
        this.change = change;
    }
    get x() {
        return (this._x = this.original.x);
    }
    set x(newX) {
        if (newX !== this._x) {
            this.change(newX, this._y);
            this._x = this.original.x = newX;
        }
    }
    get y() {
        return (this._y = this.original.y);
    }
    set y(newY) {
        if (newY !== this._y) {
            this.change(this._x, newY);
            this._y = this.original.y = newY;
        }
    }
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
}


/***/ }),

/***/ "./Particles/EmitterType.ts":
/*!**********************************!*\
  !*** ./Particles/EmitterType.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1413693__) => {

__nested_webpack_require_1413693__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1413693__.d(__nested_webpack_exports__, {
/* harmony export */   EmitterType: () => (/* binding */ EmitterType)
/* harmony export */ });
/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType["Circle"] = "circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType["Rectangle"] = "rectangle";
})(EmitterType || (EmitterType = {}));


/***/ }),

/***/ "./Particles/GpuParticleEmitter.ts":
/*!*****************************************!*\
  !*** ./Particles/GpuParticleEmitter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1414530__) => {

__nested_webpack_require_1414530__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1414530__.d(__nested_webpack_exports__, {
/* harmony export */   GpuParticleEmitter: () => (/* binding */ GpuParticleEmitter)
/* harmony export */ });
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1414530__(/*! ../Actor */ "./Actor.ts");
/* harmony import */ var _EmitterType__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1414530__(/*! ./EmitterType */ "./Particles/EmitterType.ts");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1414530__(/*! ./Particles */ "./Particles/Particles.ts");
/* harmony import */ var _GpuParticleRenderer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1414530__(/*! ./GpuParticleRenderer */ "./Particles/GpuParticleRenderer.ts");
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1414530__(/*! ../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Math_Random__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1414530__(/*! ../Math/Random */ "./Math/Random.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1414530__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1414530__(/*! ../Math */ "./Math/util.ts");








class GpuParticleEmitter extends _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor {
    get pos() {
        return this.transform.pos;
    }
    set pos(pos) {
        this.transform.pos = pos;
    }
    get z() {
        return this.transform.z;
    }
    set z(z) {
        this.transform.z = z;
    }
    constructor(config) {
        super({ name: `GpuParticleEmitter`, width: config.width, height: config.height }); // somewhat goofy way of doing width/height
        this.particle = {
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            life: 2000,
            transform: _Particles__WEBPACK_IMPORTED_MODULE_1__.ParticleTransform.Global,
            graphic: undefined,
            opacity: 1,
            angularVelocity: 0,
            focus: undefined,
            focusAccel: undefined,
            randomRotation: false
        };
        this.graphics = new _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_2__.GraphicsComponent();
        this.isEmitting = false;
        this.emitRate = 1;
        this.emitterType = _EmitterType__WEBPACK_IMPORTED_MODULE_3__.EmitterType.Rectangle;
        this.radius = 0;
        this.maxParticles = 2000;
        this._particlesToEmit = 0;
        this.addComponent(this.graphics, true);
        this.graphics.onPostDraw = this.draw.bind(this);
        const { particle, maxParticles, x, y, z, pos, isEmitting, emitRate, emitterType, radius, random } = { ...config };
        this.maxParticles = (0,_Math__WEBPACK_IMPORTED_MODULE_4__.clamp)(maxParticles !== null && maxParticles !== void 0 ? maxParticles : this.maxParticles, 0, _GpuParticleRenderer__WEBPACK_IMPORTED_MODULE_5__.GpuParticleRenderer.GPU_MAX_PARTICLES);
        this.pos = pos !== null && pos !== void 0 ? pos : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_6__.vec)(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particle = { ...this.particle, ...particle };
        this.random = random !== null && random !== void 0 ? random : new _Math_Random__WEBPACK_IMPORTED_MODULE_7__.Random();
        this.renderer = new _GpuParticleRenderer__WEBPACK_IMPORTED_MODULE_5__.GpuParticleRenderer(this, this.random, this.particle);
    }
    _initialize(engine) {
        super._initialize(engine);
        const context = engine.graphicsContext;
        this.renderer.initialize(context.__gl, context);
    }
    update(engine, elapsed) {
        super.update(engine, elapsed);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (elapsed / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        this.renderer.update(elapsed);
    }
    emitParticles(particleCount) {
        if (particleCount <= 0) {
            return;
        }
        this.renderer.emitParticles(particleCount | 0); // coerce to integer
    }
    clearParticles() {
        this.renderer.clearParticles();
    }
    draw(ctx, elapsed) {
        ctx.draw('ex.particle', this.renderer, elapsed);
    }
}


/***/ }),

/***/ "./Particles/GpuParticleRenderer.ts":
/*!******************************************!*\
  !*** ./Particles/GpuParticleRenderer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1419793__) => {

__nested_webpack_require_1419793__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1419793__.d(__nested_webpack_exports__, {
/* harmony export */   GpuParticleRenderer: () => (/* binding */ GpuParticleRenderer)
/* harmony export */ });
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1419793__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1419793__(/*! ./Particles */ "./Particles/Particles.ts");
/* harmony import */ var _EmitterType__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1419793__(/*! ./EmitterType */ "./Particles/EmitterType.ts");
/* harmony import */ var _Util_Assert__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1419793__(/*! ../Util/Assert */ "./Util/Assert.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1419793__(/*! ../Math/vector */ "./Math/vector.ts");





/**
 * Container for the GPU Particle State contains the internal state needed for the GPU
 * to render particles and maintain state.
 */
class GpuParticleRenderer {
    constructor(emitter, random, options) {
        var _a;
        this.emitRate = 1;
        this._initialized = false;
        this._vaos = [];
        this._buffers = [];
        this._drawIndex = 0;
        this._numInputFloats = 2 + 2 + 1 + 1 + 1;
        this._particleIndex = 0;
        this._uploadIndex = 0;
        this._wrappedLife = 0;
        this._wrappedParticles = 0;
        this._particleLife = 0;
        this._clearRequested = false;
        this._emitted = [];
        this.emitter = emitter;
        this.particle = options;
        this._particleData = new Float32Array(this.emitter.maxParticles * this._numInputFloats);
        this._random = random;
        this._particleLife = (_a = this.particle.life) !== null && _a !== void 0 ? _a : 2000;
    }
    get isInitialized() {
        return this._initialized;
    }
    get maxParticles() {
        return this.emitter.maxParticles;
    }
    initialize(gl, context) {
        if (this._initialized) {
            return;
        }
        const numParticles = this.emitter.maxParticles;
        const numInputFloats = this._numInputFloats;
        const particleData = this._particleData;
        const bytesPerFloat = 4;
        const particleDataBuffer1 = gl.createBuffer();
        const vao1 = gl.createVertexArray();
        gl.bindVertexArray(vao1);
        gl.bindBuffer(gl.ARRAY_BUFFER, particleDataBuffer1);
        gl.bufferData(gl.ARRAY_BUFFER, numParticles * numInputFloats * bytesPerFloat, gl.DYNAMIC_DRAW);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, particleData);
        let offset = 0;
        // position
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, 0);
        offset += bytesPerFloat * 2;
        // velocity
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 2;
        // rotation
        gl.vertexAttribPointer(2, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // angularVelocity
        gl.vertexAttribPointer(3, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // life
        gl.vertexAttribPointer(4, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // enable attributes
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);
        gl.enableVertexAttribArray(3);
        gl.enableVertexAttribArray(4);
        this._vaos.push(vao1);
        this._buffers.push(particleDataBuffer1);
        // Clean up
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        const particleDataBuffer2 = gl.createBuffer();
        const vao2 = gl.createVertexArray();
        gl.bindVertexArray(vao2);
        gl.bindBuffer(gl.ARRAY_BUFFER, particleDataBuffer2);
        gl.bufferData(gl.ARRAY_BUFFER, numParticles * numInputFloats * bytesPerFloat, gl.DYNAMIC_DRAW);
        offset = 0;
        // position
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, 0);
        offset += bytesPerFloat * 2;
        // velocity
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 2;
        // rotation
        gl.vertexAttribPointer(2, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // angularVelocity
        gl.vertexAttribPointer(3, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // life
        gl.vertexAttribPointer(4, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
        offset += bytesPerFloat * 1;
        // enable attributes
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);
        gl.enableVertexAttribArray(3);
        gl.enableVertexAttribArray(4);
        this._vaos.push(vao2);
        this._buffers.push(particleDataBuffer2);
        // Clean up
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._currentVao = this._vaos[this._drawIndex % 2];
        this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2];
        this._initialized = true;
    }
    clearParticles() {
        this._particleData.fill(0);
        this._clearRequested = true;
    }
    emitParticles(particleCount) {
        const startIndex = this._particleIndex;
        const maxSize = this.maxParticles * this._numInputFloats;
        const endIndex = particleCount * this._numInputFloats + startIndex;
        let countParticle = 0;
        for (let i = startIndex; i < endIndex; i += this._numInputFloats) {
            const angle = this._random.floating(this.particle.minAngle || 0, this.particle.maxAngle || _Math_util__WEBPACK_IMPORTED_MODULE_0__.TwoPI);
            const speedX = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0);
            const speedY = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0);
            const dx = speedX * Math.cos(angle);
            const dy = speedY * Math.sin(angle);
            let ranX = 0;
            let ranY = 0;
            if (this.emitter.emitterType === _EmitterType__WEBPACK_IMPORTED_MODULE_1__.EmitterType.Rectangle) {
                ranX = this._random.floating(-0.5, 0.5) * this.emitter.width;
                ranY = this._random.floating(-0.5, 0.5) * this.emitter.height;
            }
            else {
                const radius = this._random.floating(0, this.emitter.radius);
                ranX = radius * Math.cos(angle);
                ranY = radius * Math.sin(angle);
            }
            const tx = this.emitter.transform.apply((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(ranX, ranY));
            const data = [
                this.particle.transform === _Particles__WEBPACK_IMPORTED_MODULE_3__.ParticleTransform.Local ? ranX : tx.x,
                this.particle.transform === _Particles__WEBPACK_IMPORTED_MODULE_3__.ParticleTransform.Local ? ranY : tx.y, // pos in world space
                dx,
                dy, // velocity
                this.particle.randomRotation ? (0,_Math_util__WEBPACK_IMPORTED_MODULE_0__.randomInRange)(0, _Math_util__WEBPACK_IMPORTED_MODULE_0__.TwoPI, this._random) : this.particle.rotation || 0, // rotation
                this.particle.angularVelocity || 0, // angular velocity
                this._particleLife // life
            ];
            countParticle++;
            this._particleData.set(data, i % this._particleData.length);
        }
        if (endIndex >= maxSize) {
            this._wrappedParticles += (endIndex - maxSize) / this._numInputFloats;
            this._wrappedLife = this._particleLife;
        }
        else if (this._wrappedLife > 0) {
            this._wrappedParticles += particleCount;
        }
        this._particleIndex = endIndex % maxSize;
        this._emitted.push([this._particleLife, startIndex]);
    }
    _uploadEmitted(gl) {
        // upload index is the index of the previous upload
        // particle index is the current index of modification
        if (this._particleIndex !== this._uploadIndex) {
            // Bind one buffer to ARRAY_BUFFER and the other to TFB
            gl.bindBuffer(gl.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]);
            if (this._particleIndex >= this._uploadIndex) {
                gl.bufferSubData(gl.ARRAY_BUFFER, this._uploadIndex * 4, // dst byte offset 4 bytes per float
                this._particleData, this._uploadIndex, this._particleIndex - this._uploadIndex);
            }
            else {
                // upload before the wrap
                // prettier-ignore
                gl.bufferSubData(gl.ARRAY_BUFFER, this._uploadIndex * 4, this._particleData, this._uploadIndex, this._particleData.length - this._uploadIndex);
                // upload after the wrap if there are any
                if (this._wrappedParticles) {
                    // prettier-ignore
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._particleData, 0, this._wrappedParticles * this._numInputFloats);
                }
                this._wrappedLife = this._particleLife;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        this._uploadIndex = this._particleIndex % (this.maxParticles * this._numInputFloats);
    }
    update(elapsed) {
        var _a;
        this._particleLife = (_a = this.particle.life) !== null && _a !== void 0 ? _a : this._particleLife;
        if (this._wrappedLife > 0) {
            this._wrappedLife -= elapsed;
        }
        else {
            this._wrappedLife = 0;
            this._wrappedParticles = 0;
        }
        if (!this._emitted.length) {
            return;
        }
        for (let i = this._emitted.length - 1; i >= 0; i--) {
            const particle = this._emitted[i];
            particle[0] -= elapsed;
            const life = particle[0];
            if (life <= 0) {
                this._emitted.splice(i, 1);
            }
        }
        this._emitted.sort((a, b) => a[0] - b[0]);
    }
    draw(gl) {
        if (this._initialized) {
            // Emit
            if (this._clearRequested) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._particleData);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this._clearRequested = false;
            }
            else {
                this._uploadEmitted(gl);
            }
            // Bind one buffer to ARRAY_BUFFER and the other to transform feedback buffer
            gl.bindVertexArray(this._currentVao);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer);
            // Perform transform feedback (run the simulation) and the draw call all at once
            if (this._wrappedLife && this._emitted[0] && this._emitted[0][1] > 0) {
                const midpoint = this._emitted[0][1] / this._numInputFloats;
                // draw oldest first (maybe make configurable)
                (0,_Util_Assert__WEBPACK_IMPORTED_MODULE_4__.assert)(`midpoint greater than 0, actual: ${midpoint}`, () => midpoint > 0);
                (0,_Util_Assert__WEBPACK_IMPORTED_MODULE_4__.assert)(`midpoint is less than max, actual: ${midpoint}`, () => midpoint < this.maxParticles);
                gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, this._emitted[0][1] * 4, (this.maxParticles - midpoint) * this._numInputFloats * 4);
                gl.beginTransformFeedback(gl.POINTS);
                gl.drawArrays(gl.POINTS, midpoint, this.maxParticles - midpoint);
                gl.endTransformFeedback();
                // then draw newer particles
                gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._emitted[0][1] * 4);
                gl.beginTransformFeedback(gl.POINTS);
                gl.drawArrays(gl.POINTS, 0, midpoint);
                gl.endTransformFeedback();
            }
            else {
                gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._particleData.length * 4);
                gl.beginTransformFeedback(gl.POINTS);
                gl.drawArrays(gl.POINTS, 0, this.maxParticles);
                gl.endTransformFeedback();
            }
            // Clean up after ourselves to avoid errors.
            gl.bindVertexArray(null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            // flip flop buffers, one will be draw the other simulation
            this._currentVao = this._vaos[this._drawIndex % 2];
            this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2];
            this._drawIndex = (this._drawIndex + 1) % 2;
        }
    }
}
GpuParticleRenderer.GPU_MAX_PARTICLES = 100000;


/***/ }),

/***/ "./Particles/ParticleEmitter.ts":
/*!**************************************!*\
  !*** ./Particles/ParticleEmitter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1433226__) => {

__nested_webpack_require_1433226__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1433226__.d(__nested_webpack_exports__, {
/* harmony export */   ParticleEmitter: () => (/* binding */ ParticleEmitter)
/* harmony export */ });
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1433226__(/*! ../Actor */ "./Actor.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1433226__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Math_Random__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1433226__(/*! ../Math/Random */ "./Math/Random.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1433226__(/*! ../Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1433226__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _EmitterType__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1433226__(/*! ./EmitterType */ "./Particles/EmitterType.ts");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1433226__(/*! ./Particles */ "./Particles/Particles.ts");
/* harmony import */ var _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1433226__(/*! ../Util/RentalPool */ "./Util/RentalPool.ts");








/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend {@apilink Actor} allowing you to use all of the features that come with.
 *
 * These particles are simulated on the CPU in JavaScript
 */
class ParticleEmitter extends _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this._particlePool = new _Util_RentalPool__WEBPACK_IMPORTED_MODULE_1__.RentalPool(() => new _Particles__WEBPACK_IMPORTED_MODULE_2__.Particle({}), (p) => p, 500);
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = _EmitterType__WEBPACK_IMPORTED_MODULE_3__.EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the {@apilink emitterType} is {@apilink EmitterType.Circle}
         */
        this.radius = 0;
        this.particle = {
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            life: 2000,
            transform: _Particles__WEBPACK_IMPORTED_MODULE_2__.ParticleTransform.Global,
            graphic: undefined,
            opacity: 1,
            angularVelocity: 0,
            focus: undefined,
            focusAccel: undefined,
            randomRotation: false
        };
        this._activeParticles = [];
        const { particle, x, y, z, pos, isEmitting, emitRate, emitterType, radius, random } = { ...config };
        this.particle = { ...this.particle, ...particle };
        this.pos = pos !== null && pos !== void 0 ? pos : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.body.collisionType = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_5__.CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new _Math_Random__WEBPACK_IMPORTED_MODULE_6__.Random();
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        if (particleCount <= 0) {
            return;
        }
        particleCount = particleCount | 0; // coerce to int
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                if (this.particle.transform === _Particles__WEBPACK_IMPORTED_MODULE_2__.ParticleTransform.Global) {
                    this.scene.world.add(p);
                }
                else {
                    this.addChild(p);
                }
            }
            this._activeParticles.push(p);
        }
    }
    clearParticles() {
        for (let i = 0; i < this._activeParticles.length; i++) {
            this.removeParticle(this._activeParticles[i]);
        }
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        let ranX = 0;
        let ranY = 0;
        const angle = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(this.particle.minAngle || 0, this.particle.maxAngle || Math.PI * 2, this.random);
        const vel = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(this.particle.minSpeed || 0, this.particle.maxSpeed || 0, this.random);
        const size = this.particle.startSize || (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(this.particle.minSize || 5, this.particle.maxSize || 5, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === _EmitterType__WEBPACK_IMPORTED_MODULE_3__.EmitterType.Rectangle) {
            ranX = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(0, this.width, this.random);
            ranY = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(0, this.height, this.random);
        }
        else if (this.emitterType === _EmitterType__WEBPACK_IMPORTED_MODULE_3__.EmitterType.Circle) {
            const radius = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = this._particlePool.rent();
        p.configure({
            life: this.particle.life,
            opacity: this.particle.opacity,
            beginColor: this.particle.beginColor,
            endColor: this.particle.endColor,
            pos: (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(ranX, ranY),
            vel: (0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(dx, dy),
            acc: this.particle.acc,
            angularVelocity: this.particle.angularVelocity,
            startSize: this.particle.startSize,
            endSize: this.particle.endSize,
            size: size,
            graphic: this.particle.graphic,
            fade: this.particle.fade
        });
        p.registerEmitter(this);
        if (this.particle.randomRotation) {
            p.transform.rotation = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.randomInRange)(0, Math.PI * 2, this.random);
        }
        if (this.particle.focus) {
            p.focus = this.particle.focus.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_4__.vec)(this.pos.x, this.pos.y));
            p.focusAccel = this.particle.focusAccel;
        }
        return p;
    }
    update(engine, elapsed) {
        var _a;
        super.update(engine, elapsed);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (elapsed / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
                this._particlePool.return(this.deadParticles[i]);
            }
            const index = this._activeParticles.indexOf(this.deadParticles[i]);
            if (index > -1) {
                this._activeParticles.splice(index, 1);
            }
        }
        this.deadParticles.length = 0;
    }
}


/***/ }),

/***/ "./Particles/Particles.ts":
/*!********************************!*\
  !*** ./Particles/Particles.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1442520__) => {

__nested_webpack_require_1442520__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1442520__.d(__nested_webpack_exports__, {
/* harmony export */   Particle: () => (/* binding */ Particle),
/* harmony export */   ParticleTransform: () => (/* binding */ ParticleTransform)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1442520__(/*! ../Color */ "./Color.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1442520__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1442520__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1442520__(/*! ../Graphics/GraphicsComponent */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1442520__(/*! ../EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1442520__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1442520__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1442520__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Collision_Integrator__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1442520__(/*! ../Collision/Integrator */ "./Collision/Integrator.ts");









/**
/**
 * CPU Particle is used in a {@apilink ParticleEmitter}
 */
class Particle extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor(options) {
        super({ silenceWarnings: true });
        this.beginColor = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White;
        this.endColor = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fade = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White;
        this.size = 5;
        this.sizeRate = 0;
        this.visible = true;
        this.isOffscreen = false;
        this.particleTransform = ParticleTransform.Global;
        this.name = `Particle#${this.id}`;
        this.addComponent((this.transform = new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent()));
        this.addComponent((this.motion = new _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__.MotionComponent()));
        this.addComponent((this.graphics = new _Graphics_GraphicsComponent__WEBPACK_IMPORTED_MODULE_4__.GraphicsComponent()));
        this.configure(options);
    }
    registerEmitter(emitter) {
        this._emitter = emitter;
        if (this.particleTransform === ParticleTransform.Global) {
            const globalPos = this._emitter.transform.globalPos;
            this.transform.pos = this.transform.pos.add(globalPos);
            this.motion.vel = this.motion.vel.rotate(this._emitter.transform.globalRotation);
        }
    }
    configure(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        this.particleTransform = (_a = options.transform) !== null && _a !== void 0 ? _a : this.particleTransform;
        this.life = (_b = options.life) !== null && _b !== void 0 ? _b : this.life;
        this.fade = (_c = options.fade) !== null && _c !== void 0 ? _c : this.fade;
        this.size = (_d = options.size) !== null && _d !== void 0 ? _d : this.size;
        this.endColor = (_e = options.endColor) !== null && _e !== void 0 ? _e : this.endColor.clone();
        this.beginColor = (_f = options.beginColor) !== null && _f !== void 0 ? _f : this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.graphic = options.graphic;
        this.graphics.opacity = (_g = options.opacity) !== null && _g !== void 0 ? _g : this.graphics.opacity;
        this.transform.pos = (_h = options.pos) !== null && _h !== void 0 ? _h : this.transform.pos;
        this.transform.rotation = (_j = options.rotation) !== null && _j !== void 0 ? _j : 0;
        this.transform.scale = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_5__.vec)(1, 1);
        this.motion.vel = (_k = options.vel) !== null && _k !== void 0 ? _k : this.motion.vel;
        this.motion.angularVelocity = (_l = options.angularVelocity) !== null && _l !== void 0 ? _l : 0;
        this.motion.acc = (_m = options.acc) !== null && _m !== void 0 ? _m : this.motion.acc;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.graphics.opacity / this.life;
        this.startSize = (_o = options.startSize) !== null && _o !== void 0 ? _o : 0;
        this.endSize = (_p = options.endSize) !== null && _p !== void 0 ? _p : 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.size = this.startSize;
        }
        if (this.graphic) {
            this.graphics.use(this.graphic);
            this.graphics.onPostDraw = undefined;
        }
        else {
            this.graphics.localBounds = _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox.fromDimension(this.size, this.size, _Math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector.Half);
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                ctx.debug.drawPoint((0,_Math_vector__WEBPACK_IMPORTED_MODULE_5__.vec)(0, 0), { color: this._currentColor, size: this.size });
                ctx.restore();
            };
        }
    }
    kill() {
        var _a;
        if ((_a = this._emitter) === null || _a === void 0 ? void 0 : _a.isActive) {
            this._emitter.removeParticle(this);
        }
        else {
            super.kill();
        }
    }
    update(engine, elapsed) {
        this.life = this.life - elapsed;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fade) {
            this.graphics.opacity = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.clamp)(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize && this.endSize && this.startSize > 0 && this.endSize > 0) {
            this.size = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.clamp)(this.sizeRate * elapsed + this.size, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.clamp)(this._currentColor.r + this._rRate * elapsed, 0, 255);
        this._currentColor.g = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.clamp)(this._currentColor.g + this._gRate * elapsed, 0, 255);
        this._currentColor.b = (0,_Math_util__WEBPACK_IMPORTED_MODULE_7__.clamp)(this._currentColor.b + this._bRate * elapsed, 0, 255);
        this._currentColor.a = this.graphics.opacity;
        let accel = this.motion.acc;
        if (this.focus) {
            accel = this.focus
                .sub(this.transform.pos)
                .normalize()
                .scale(this.focusAccel || 0)
                .scale(elapsed / 1000);
        }
        // Update transform and motion based on Euler linear algebra
        _Collision_Integrator__WEBPACK_IMPORTED_MODULE_8__.EulerIntegrator.integrate(this.transform, this.motion, accel, elapsed);
    }
}
Particle.DefaultConfig = {
    beginColor: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White,
    endColor: _Color__WEBPACK_IMPORTED_MODULE_1__.Color.White,
    life: 300,
    fade: false,
    size: 5,
    graphic: undefined,
    startSize: undefined,
    endSize: undefined
};
var ParticleTransform;
(function (ParticleTransform) {
    /**
     * {@apilink ParticleTransform.Global} is the default and emits particles as if
     * they were world space objects, useful for most effects.
     */
    ParticleTransform["Global"] = "global";
    /**
     * {@apilink ParticleTransform.Local} particles are children of the emitter and move relative to the emitter
     * as they would in a parent/child actor relationship.
     */
    ParticleTransform["Local"] = "local";
})(ParticleTransform || (ParticleTransform = {}));


/***/ }),

/***/ "./Particles/index.ts":
/*!****************************!*\
  !*** ./Particles/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1451489__) => {

__nested_webpack_require_1451489__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1451489__.d(__nested_webpack_exports__, {
/* harmony export */   EmitterType: () => (/* reexport safe */ _EmitterType__WEBPACK_IMPORTED_MODULE_0__.EmitterType),
/* harmony export */   GpuParticleEmitter: () => (/* reexport safe */ _GpuParticleEmitter__WEBPACK_IMPORTED_MODULE_3__.GpuParticleEmitter),
/* harmony export */   GpuParticleRenderer: () => (/* reexport safe */ _GpuParticleRenderer__WEBPACK_IMPORTED_MODULE_4__.GpuParticleRenderer),
/* harmony export */   Particle: () => (/* reexport safe */ _Particles__WEBPACK_IMPORTED_MODULE_1__.Particle),
/* harmony export */   ParticleEmitter: () => (/* reexport safe */ _ParticleEmitter__WEBPACK_IMPORTED_MODULE_2__.ParticleEmitter),
/* harmony export */   ParticleTransform: () => (/* reexport safe */ _Particles__WEBPACK_IMPORTED_MODULE_1__.ParticleTransform)
/* harmony export */ });
/* harmony import */ var _EmitterType__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1451489__(/*! ./EmitterType */ "./Particles/EmitterType.ts");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1451489__(/*! ./Particles */ "./Particles/Particles.ts");
/* harmony import */ var _ParticleEmitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1451489__(/*! ./ParticleEmitter */ "./Particles/ParticleEmitter.ts");
/* harmony import */ var _GpuParticleEmitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1451489__(/*! ./GpuParticleEmitter */ "./Particles/GpuParticleEmitter.ts");
/* harmony import */ var _GpuParticleRenderer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1451489__(/*! ./GpuParticleRenderer */ "./Particles/GpuParticleRenderer.ts");







/***/ }),

/***/ "./Polyfill.ts":
/*!*********************!*\
  !*** ./Polyfill.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1453354__) => {

__nested_webpack_require_1453354__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1453354__.d(__nested_webpack_exports__, {
/* harmony export */   polyfill: () => (/* binding */ polyfill)
/* harmony export */ });
/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestIdleCallback) {
        // Adapted from https://developer.chrome.com/blog/using-requestidlecallback#checking_for_requestidlecallback
        window.requestIdleCallback =
            window.requestIdleCallback ||
                function (cb) {
                    const start = Date.now();
                    return setTimeout(function () {
                        cb({
                            didTimeout: false,
                            timeRemaining: function () {
                                return Math.max(0, 50 - (Date.now() - start));
                            }
                        });
                    }, 1);
                };
        window.cancelIdleCallback =
            window.cancelIdleCallback ||
                function (id) {
                    clearTimeout(id);
                };
    }
}


/***/ }),

/***/ "./Resources/Font.ts":
/*!***************************!*\
  !*** ./Resources/Font.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1456552__) => {

__nested_webpack_require_1456552__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1456552__.d(__nested_webpack_exports__, {
/* harmony export */   FontSource: () => (/* binding */ FontSource)
/* harmony export */ });
/* harmony import */ var _Graphics_Font__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1456552__(/*! ../Graphics/Font */ "./Graphics/Font.ts");
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1456552__(/*! ./Resource */ "./Resources/Resource.ts");


class FontSource {
    constructor(
    /**
     * Path to the font resource relative from the HTML document hosting the game, or absolute
     */
    path, 
    /**
     * The font family name
     */
    family, { bustCache, ...options } = {}) {
        this.path = path;
        this.family = family;
        this._isLoaded = false;
        this._resource = new _Resource__WEBPACK_IMPORTED_MODULE_0__.Resource(path, 'blob', bustCache);
        this._options = options;
    }
    async load() {
        if (this.isLoaded()) {
            return this.data;
        }
        try {
            const blob = await this._resource.load();
            const url = URL.createObjectURL(blob);
            if (!this.data) {
                this.data = new FontFace(this.family, `url(${url})`);
                document.fonts.add(this.data);
            }
            await this.data.load();
            this._isLoaded = true;
        }
        catch (error) {
            throw `Error loading FontSource from path '${this.path}' with error [${error.message}]`;
        }
        return this.data;
    }
    isLoaded() {
        return this._isLoaded;
    }
    /**
     * Build a font from this FontSource.
     * @param options {FontOptions} Override the font options
     */
    toFont(options) {
        return new _Graphics_Font__WEBPACK_IMPORTED_MODULE_1__.Font({ family: this.family, ...this._options, ...options });
    }
}


/***/ }),

/***/ "./Resources/Gif.ts":
/*!**************************!*\
  !*** ./Resources/Gif.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1458668__) => {

__nested_webpack_require_1458668__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1458668__.d(__nested_webpack_exports__, {
/* harmony export */   Gif: () => (/* binding */ Gif),
/* harmony export */   GifParser: () => (/* binding */ GifParser),
/* harmony export */   Stream: () => (/* binding */ Stream)
/* harmony export */ });
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1458668__(/*! ./Resource */ "./Resources/Resource.ts");
/* harmony import */ var _Graphics_SpriteSheet__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1458668__(/*! ../Graphics/SpriteSheet */ "./Graphics/SpriteSheet.ts");
/* harmony import */ var _Graphics_Animation__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1458668__(/*! ../Graphics/Animation */ "./Graphics/Animation.ts");
/* harmony import */ var _Graphics_ImageSource__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1458668__(/*! ../Graphics/ImageSource */ "./Graphics/ImageSource.ts");




/**
 * The {@apilink Texture} object allows games built in Excalibur to load image resources.
 * {@apilink Texture} is an {@apilink Loadable} which means it can be passed to a {@apilink Loader}
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, bustCache = false) {
        this.path = path;
        /**
         * The width of the texture in pixels
         */
        this.width = 0;
        /**
         * The height of the texture in pixels
         */
        this.height = 0;
        this._images = [];
        this.data = [];
        this._sprites = [];
        this._resource = new _Resource__WEBPACK_IMPORTED_MODULE_0__.Resource(path, 'arraybuffer', bustCache);
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
        return this._resource.bustCache;
    }
    set bustCache(val) {
        this._resource.bustCache = val;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    async load() {
        const arraybuffer = await this._resource.load();
        this._stream = new Stream(arraybuffer);
        this._gif = new GifParser(this._stream);
        const images = this._gif.images.map((i) => new _Graphics_ImageSource__WEBPACK_IMPORTED_MODULE_1__.ImageSource(i.src, false));
        // Load all textures
        await Promise.all(images.map((t) => t.load()));
        this.data = this._images = images;
        this._sprites = this._images.map((image) => {
            return image.toSprite();
        });
        return this.data;
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        var _a;
        return (_a = this._sprites[id]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._sprites;
        if (sprites.length) {
            return new _Graphics_SpriteSheet__WEBPACK_IMPORTED_MODULE_2__.SpriteSheet({ sprites });
        }
        return null;
    }
    /**
     * Transform the GIF into an animation with duration per frame
     * @param durationPerFrame Optionally override duration per frame
     */
    toAnimation(durationPerFrame) {
        var _a;
        const images = (_a = this._gif) === null || _a === void 0 ? void 0 : _a.images;
        if (images === null || images === void 0 ? void 0 : images.length) {
            const frames = images.map((image, index) => {
                var _a;
                return {
                    graphic: this._sprites[index],
                    duration: ((_a = this._gif) === null || _a === void 0 ? void 0 : _a.frames[index].delayMs) || undefined
                };
            });
            this._animation = new _Graphics_Animation__WEBPACK_IMPORTED_MODULE_3__.Animation({
                frames,
                frameDuration: durationPerFrame
            });
            return this._animation;
        }
        return null;
    }
    get readCheckBytes() {
        var _a, _b;
        return (_b = (_a = this._gif) === null || _a === void 0 ? void 0 : _a.checkBytes) !== null && _b !== void 0 ? _b : [];
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code = 0;
    let last = 0;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
/**
 * GifParser for binary format
 *
 * Roughly based on the documentation https://giflib.sourceforge.net/whatsinagif/index.html
 */
class GifParser {
    constructor(stream) {
        this._handler = {};
        this.frames = [];
        this.images = [];
        this.globalColorTableBytes = [];
        this.checkBytes = [];
        this.parseColorTableBytes = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const colorTable = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                colorTable.push(rgb);
            }
            return colorTable;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: '',
                ver: '',
                width: 0,
                height: 0,
                colorResolution: 0,
                globalColorTableSize: 0,
                gctFlag: false,
                sortedFlag: false,
                globalColorTable: [],
                backgroundColorIndex: 0,
                pixelAspectRatio: 0 // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            this._currentFrameCanvas.width = hdr.width;
            this._currentFrameCanvas.height = hdr.height;
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorResolution = bitsToNum(bits.splice(0, 3));
            hdr.sortedFlag = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.backgroundColorIndex = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                // hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTableBytes = this.parseColorTableBytes(1 << (hdr.globalColorTableSize + 1));
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInputFlag = bits.shift();
                block.transparentColorFlag = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparentColorIndex = this._st.readByte();
                block.terminator = this._st.readByte(); // always 0
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
                return block;
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    this._gce = parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            var _a;
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lctBytes = this.parseColorTableBytes(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            if ((_a = this._gce) === null || _a === void 0 ? void 0 : _a.delayTime) {
                img.delayMs = this._gce.delayTime * 10;
            }
            this.frames.push(img);
            this.arrayToImage(img, img.lctFlag ? img.lctBytes : this.globalColorTableBytes);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlocks = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlocks();
            }
        };
        this.arrayToImage = (frame, colorTable) => {
            var _a, _b, _c, _d;
            const canvas = document.createElement('canvas');
            canvas.width = frame.width;
            canvas.height = frame.height;
            const context = canvas.getContext('2d');
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            let transparentColorIndex = -1;
            if ((_a = this._gce) === null || _a === void 0 ? void 0 : _a.transparentColorFlag) {
                transparentColorIndex = this._gce.transparentColorIndex;
            }
            for (let pixel = 0; pixel < frame.pixels.length; pixel++) {
                const colorIndex = frame.pixels[pixel];
                const color = colorTable[colorIndex];
                if (colorIndex === transparentColorIndex) {
                    imageData.data.set([0, 0, 0, 0], pixel * 4);
                }
                else {
                    imageData.data.set([...color, 255], pixel * 4);
                }
            }
            context.putImageData(imageData, 0, 0);
            // A value of 1 which tells the decoder to leave the image in place and draw the next image on top of it.
            // A value of 2 would have meant that the canvas should be restored to the background color (as indicated by the logical screen descriptor).
            // A value of 3 is defined to mean that the decoder should restore the canvas to its previous state before the current image was drawn.
            // The behavior for values 4-7 are yet to be defined.
            if (((_b = this._gce) === null || _b === void 0 ? void 0 : _b.disposalMethod) === 1 && this.images.length) {
                this._currentFrameContext.drawImage(this.images[this.images.length - 1], 0, 0);
            }
            else if (((_c = this._gce) === null || _c === void 0 ? void 0 : _c.disposalMethod) === 2 && ((_d = this._hdr) === null || _d === void 0 ? void 0 : _d.gctFlag)) {
                const bg = colorTable[this._hdr.backgroundColorIndex];
                this._currentFrameContext.fillStyle = `rgb(${bg[0]}, ${bg[1]}, ${bg[2]})`;
                this._currentFrameContext.fillRect(0, 0, this._hdr.width, this._hdr.height);
            }
            else {
                this._currentFrameContext.clearRect(0, 0, this._currentFrameCanvas.width, this._currentFrameCanvas.height);
            }
            this._currentFrameContext.drawImage(canvas, frame.leftPos, frame.topPos, frame.width, frame.height);
            const img = new Image();
            img.src = this._currentFrameCanvas.toDataURL(); // default is png
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._currentFrameCanvas = document.createElement('canvas');
        this._currentFrameContext = this._currentFrameCanvas.getContext('2d');
        this.parseHeader();
        this.parseBlocks();
    }
}


/***/ }),

/***/ "./Resources/Index.ts":
/*!****************************!*\
  !*** ./Resources/Index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1479820__) => {

__nested_webpack_require_1479820__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1479820__.d(__nested_webpack_exports__, {
/* harmony export */   AudioContextFactory: () => (/* reexport safe */ _Sound_Index__WEBPACK_IMPORTED_MODULE_1__.AudioContextFactory),
/* harmony export */   FontSource: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_3__.FontSource),
/* harmony export */   Gif: () => (/* reexport safe */ _Gif__WEBPACK_IMPORTED_MODULE_2__.Gif),
/* harmony export */   GifParser: () => (/* reexport safe */ _Gif__WEBPACK_IMPORTED_MODULE_2__.GifParser),
/* harmony export */   Resource: () => (/* reexport safe */ _Resource__WEBPACK_IMPORTED_MODULE_0__.Resource),
/* harmony export */   ResourceEvents: () => (/* reexport safe */ _Resource__WEBPACK_IMPORTED_MODULE_0__.ResourceEvents),
/* harmony export */   Sound: () => (/* reexport safe */ _Sound_Index__WEBPACK_IMPORTED_MODULE_1__.Sound),
/* harmony export */   SoundEvents: () => (/* reexport safe */ _Sound_Index__WEBPACK_IMPORTED_MODULE_1__.SoundEvents),
/* harmony export */   Stream: () => (/* reexport safe */ _Gif__WEBPACK_IMPORTED_MODULE_2__.Stream),
/* harmony export */   WebAudioInstance: () => (/* reexport safe */ _Sound_Index__WEBPACK_IMPORTED_MODULE_1__.WebAudioInstance)
/* harmony export */ });
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1479820__(/*! ./Resource */ "./Resources/Resource.ts");
/* harmony import */ var _Sound_Index__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1479820__(/*! ./Sound/Index */ "./Resources/Sound/Index.ts");
/* harmony import */ var _Gif__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1479820__(/*! ./Gif */ "./Resources/Gif.ts");
/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1479820__(/*! ./Font */ "./Resources/Font.ts");






/***/ }),

/***/ "./Resources/Resource.ts":
/*!*******************************!*\
  !*** ./Resources/Resource.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1481840__) => {

__nested_webpack_require_1481840__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1481840__.d(__nested_webpack_exports__, {
/* harmony export */   Resource: () => (/* binding */ Resource),
/* harmony export */   ResourceEvents: () => (/* binding */ ResourceEvents)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1481840__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1481840__(/*! ../EventEmitter */ "./EventEmitter.ts");


const ResourceEvents = {
    Complete: 'complete',
    Load: 'load',
    LoadStart: 'loadstart',
    Progress: 'progress',
    Error: 'error'
};
/**
 * The {@apilink Resource} type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use {@apilink Resource} for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = false) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                if (request.response instanceof Blob && request.response.type === 'text/html') {
                    const errorText = `Expected blob (usually image) data from the server when loading ${this.path}, but got HTML content instead!

Check your server configuration, for example Vite serves static files from the /public folder`;
                    this.events.emit('error', request.response);
                    reject(new Error(errorText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}


/***/ }),

/***/ "./Resources/Sound/AudioContext.ts":
/*!*****************************************!*\
  !*** ./Resources/Sound/AudioContext.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1486320__) => {

__nested_webpack_require_1486320__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1486320__.d(__nested_webpack_exports__, {
/* harmony export */   AudioContextFactory: () => (/* binding */ AudioContextFactory)
/* harmony export */ });
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}


/***/ }),

/***/ "./Resources/Sound/Index.ts":
/*!**********************************!*\
  !*** ./Resources/Sound/Index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1487148__) => {

__nested_webpack_require_1487148__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1487148__.d(__nested_webpack_exports__, {
/* harmony export */   AudioContextFactory: () => (/* reexport safe */ _AudioContext__WEBPACK_IMPORTED_MODULE_1__.AudioContextFactory),
/* harmony export */   Sound: () => (/* reexport safe */ _Sound__WEBPACK_IMPORTED_MODULE_0__.Sound),
/* harmony export */   SoundEvents: () => (/* reexport safe */ _Sound__WEBPACK_IMPORTED_MODULE_0__.SoundEvents),
/* harmony export */   WebAudioInstance: () => (/* reexport safe */ _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__.WebAudioInstance)
/* harmony export */ });
/* harmony import */ var _Sound__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1487148__(/*! ./Sound */ "./Resources/Sound/Sound.ts");
/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1487148__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _WebAudioInstance__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1487148__(/*! ./WebAudioInstance */ "./Resources/Sound/WebAudioInstance.ts");





/***/ }),

/***/ "./Resources/Sound/Sound.ts":
/*!**********************************!*\
  !*** ./Resources/Sound/Sound.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1488459__) => {

__nested_webpack_require_1488459__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1488459__.d(__nested_webpack_exports__, {
/* harmony export */   Sound: () => (/* binding */ Sound),
/* harmony export */   SoundEvents: () => (/* binding */ SoundEvents)
/* harmony export */ });
/* harmony import */ var _Interfaces_AudioImplementation__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1488459__(/*! ../../Interfaces/AudioImplementation */ "./Interfaces/AudioImplementation.ts");
/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1488459__(/*! ../Resource */ "./Resources/Resource.ts");
/* harmony import */ var _WebAudioInstance__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1488459__(/*! ./WebAudioInstance */ "./Resources/Sound/WebAudioInstance.ts");
/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1488459__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1488459__(/*! ../../Events/MediaEvents */ "./Events/MediaEvents.ts");
/* harmony import */ var _Util_Sound__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1488459__(/*! ../../Util/Sound */ "./Util/Sound.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1488459__(/*! ../../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1488459__(/*! ../../EventEmitter */ "./EventEmitter.ts");








const SoundEvents = {
    VolumeChange: 'volumechange',
    Processed: 'processed',
    Pause: 'pause',
    Stop: 'stop',
    PlaybackEnd: 'playbackend',
    Resume: 'resume',
    PlaybackStart: 'playbackstart'
};
/**
 * The {@apilink Sound} object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. {@apilink Sound} is an {@apilink Loadable}
 * which means it can be passed to a {@apilink Loader} to pre-load before a game or level.
 */
class Sound {
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.events.emit('volumechange', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    /**
     * Get the duration that this audio should play. If unset the total natural playback duration will be used.
     */
    get duration() {
        return this._duration;
    }
    /**
     * Set the duration that this audio should play. If unset the total natural playback duration will be used.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
        return this._resource.bustCache;
    }
    set bustCache(val) {
        this._resource.bustCache = val;
    }
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_2__.Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._isStopped = false;
        // private _isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._playbackRate = 1.0;
        this._audioContext = _AudioContext__WEBPACK_IMPORTED_MODULE_3__.AudioContextFactory.create();
        this._resource = new _Resource__WEBPACK_IMPORTED_MODULE_4__.Resource('', _Interfaces_AudioImplementation__WEBPACK_IMPORTED_MODULE_5__.ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if ((0,_Util_Sound__WEBPACK_IMPORTED_MODULE_6__.canPlayFile)(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    isLoaded() {
        return !!this.data;
    }
    async load() {
        var _a, _b;
        if (this.data) {
            return this.data;
        }
        const arraybuffer = await this._resource.load();
        const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));
        this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : undefined;
        this.events.emit('processed', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundProcessedEvent(this, audiobuffer));
        return (this.data = audiobuffer);
    }
    async decodeAudio(data) {
        try {
            return await this._audioContext.decodeAudioData(data.slice(0));
        }
        catch (e) {
            this.logger.error('Unable to decode ' +
                ' this browser may not fully support this format, or the file may be corrupt, ' +
                'if this is an mp3 try removing id3 tags and album art from the file.');
            return await Promise.reject();
        }
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    isPaused() {
        return this._tracks.some((t) => t.isPaused());
    }
    isStopped() {
        return this._tracks.some((t) => t.isStopped());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this.isPaused()) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this.events.emit('pause', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.events.emit('stop', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this));
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    get playbackRate() {
        return this._playbackRate;
    }
    set playbackRate(playbackRate) {
        this._playbackRate = playbackRate;
        this._tracks.forEach((t) => {
            t.playbackRate = this._playbackRate;
        });
    }
    seek(position, trackId = 0) {
        if (this._tracks.length === 0) {
            this._getTrackInstance(this.data);
        }
        this._tracks[trackId].seek(position);
    }
    getTotalPlaybackDuration() {
        if (!this.isLoaded()) {
            this.logger.warnOnce(`Sound from ${this.path} is not loaded, cannot return total playback duration.` +
                `Did you forget to add Sound to a loader? https://excaliburjs.com/docs/loaders/`);
            return 0;
        }
        return this.data.duration;
    }
    /**
     * Return the current playback time of the playing track in seconds from the start.
     *
     * Optionally specify the track to query if multiple are playing at once.
     * @param trackId
     */
    getPlaybackPosition(trackId = 0) {
        if (this._tracks.length) {
            return this._tracks[trackId].getPlaybackPosition();
        }
        return 0;
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track {@apilink Audio} which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    async _resumePlayback() {
        if (this.isPaused()) {
            const resumed = [];
            // ensure we resume *current* tracks (if paused)
            for (const track of this._tracks) {
                resumed.push(track.play().then(() => {
                    this._tracks.splice(this.getTrackId(track), 1);
                    return true;
                }));
            }
            this.events.emit('resume', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this));
            this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
            // resolve when resumed tracks are done
            await Promise.all(resumed);
        }
        return true;
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    async _startPlayback() {
        const track = this._getTrackInstance(this.data);
        const complete = await track.play(() => {
            this.events.emit('playbackstart', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this, track));
            this.logger.debug('Playing new instance for sound', this.path);
        });
        this.events.emit('playbackend', new _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_0__.NativeSoundEvent(this, track));
        // cleanup any done tracks
        const trackId = this.getTrackId(track);
        if (trackId !== -1) {
            this._tracks.splice(trackId, 1);
        }
        return complete;
    }
    _getTrackInstance(data) {
        var _a;
        const newTrack = new _WebAudioInstance__WEBPACK_IMPORTED_MODULE_7__.WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = (_a = this.duration) !== null && _a !== void 0 ? _a : 0;
        newTrack.playbackRate = this._playbackRate;
        this._tracks.push(newTrack);
        return newTrack;
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
}


/***/ }),

/***/ "./Resources/Sound/WebAudioInstance.ts":
/*!*********************************************!*\
  !*** ./Resources/Sound/WebAudioInstance.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1501941__) => {

__nested_webpack_require_1501941__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1501941__.d(__nested_webpack_exports__, {
/* harmony export */   WebAudioInstance: () => (/* binding */ WebAudioInstance)
/* harmony export */ });
/* harmony import */ var _Util_StateMachine__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1501941__(/*! ../../Util/StateMachine */ "./Util/StateMachine.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1501941__(/*! ../../Math/util */ "./Math/util.ts");
/* harmony import */ var _AudioContext__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1501941__(/*! ./AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1501941__(/*! ../../Util/Future */ "./Util/Future.ts");




/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.value = this._playbackRate;
        this._instance.connect(this._volumeNode);
        this._volumeNode.connect(this._audioContext.destination);
    }
    _handleEnd() {
        if (!this.loop) {
            this._instance.onended = () => {
                this._playingFuture.resolve(true);
            };
        }
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            if (!this.loop) {
                this._instance.onended = () => {
                    this._playingFuture.resolve(true);
                };
            }
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = (0,_Math_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(value, 0, 1.0);
        this._volume = value;
        if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    /**
     * Returns the set duration to play, otherwise returns the total duration if unset
     */
    get duration() {
        var _a;
        return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();
    }
    /**
     * Set the duration that this audio should play.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    constructor(_src) {
        this._src = _src;
        this._audioContext = _AudioContext__WEBPACK_IMPORTED_MODULE_1__.AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        this._playingFuture = new _Util_Future__WEBPACK_IMPORTED_MODULE_2__.Future();
        this._stateMachine = _Util_StateMachine__WEBPACK_IMPORTED_MODULE_3__.StateMachine.create({
            start: 'STOPPED',
            states: {
                PLAYING: {
                    onEnter: ({ data }) => {
                        // Buffer nodes are single use
                        this._createNewBufferSource();
                        this._handleEnd();
                        if (this.loop) {
                            // when looping don't set a duration
                            this._instance.start(0, data.pausedAt * this._playbackRate);
                        }
                        else {
                            this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);
                        }
                        data.startedAt = this._audioContext.currentTime - data.pausedAt;
                        data.pausedAt = 0;
                    },
                    onState: () => this._playStarted(),
                    onExit: ({ to }) => {
                        // If you've exited early only resolve if explicitly STOPPED
                        if (to === 'STOPPED') {
                            this._playingFuture.resolve(true);
                        }
                        // Whenever you're not playing... you stop!
                        this._instance.onended = null; // disconnect the wired on-end handler
                        this._instance.disconnect();
                        this._instance.stop(0);
                        this._instance = null;
                    },
                    transitions: ['STOPPED', 'PAUSED', 'SEEK']
                },
                SEEK: {
                    onEnter: ({ eventData: position, data }) => {
                        data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;
                        data.startedAt = 0;
                    },
                    transitions: ['*']
                },
                STOPPED: {
                    onEnter: ({ data }) => {
                        data.pausedAt = 0;
                        data.startedAt = 0;
                        this._playingFuture.resolve(true);
                    },
                    transitions: ['PLAYING', 'PAUSED', 'SEEK']
                },
                PAUSED: {
                    onEnter: ({ data }) => {
                        // Playback rate will be a scale factor of how fast/slow the audio is being played
                        // default is 1.0
                        // we need to invert it to get the time scale
                        data.pausedAt = this._audioContext.currentTime - data.startedAt;
                    },
                    transitions: ['PLAYING', 'STOPPED', 'SEEK']
                }
            }
        }, {
            startedAt: 0,
            pausedAt: 0
        });
        this._volume = 1;
        this._loop = false;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._playStarted = () => { };
        this._playbackRate = 1.0;
        this._createNewBufferSource();
    }
    isPlaying() {
        return this._stateMachine.in('PLAYING');
    }
    isPaused() {
        return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');
    }
    isStopped() {
        return this._stateMachine.in('STOPPED');
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        this._playStarted = playStarted;
        this._stateMachine.go('PLAYING');
        return this._playingFuture.promise;
    }
    pause() {
        this._stateMachine.go('PAUSED');
    }
    stop() {
        this._stateMachine.go('STOPPED');
    }
    seek(position) {
        this._stateMachine.go('PAUSED');
        this._stateMachine.go('SEEK', position);
    }
    getTotalPlaybackDuration() {
        return this._src.duration;
    }
    getPlaybackPosition() {
        const { pausedAt, startedAt } = this._stateMachine.data;
        if (pausedAt) {
            return pausedAt * this._playbackRate;
        }
        if (startedAt) {
            return (this._audioContext.currentTime - startedAt) * this._playbackRate;
        }
        return 0;
    }
    set playbackRate(playbackRate) {
        this._instance.playbackRate.value = this._playbackRate = playbackRate;
    }
    get playbackRate() {
        return this._instance.playbackRate.value;
    }
}


/***/ }),

/***/ "./Scene.ts":
/*!******************!*\
  !*** ./Scene.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1510097__) => {

__nested_webpack_require_1510097__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1510097__.d(__nested_webpack_exports__, {
/* harmony export */   PreLoadEvent: () => (/* binding */ PreLoadEvent),
/* harmony export */   Scene: () => (/* binding */ Scene),
/* harmony export */   SceneEvents: () => (/* binding */ SceneEvents),
/* harmony export */   isSceneConstructor: () => (/* binding */ isSceneConstructor)
/* harmony export */ });
/* harmony import */ var _ScreenElement__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_1510097__(/*! ./ScreenElement */ "./ScreenElement.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_1510097__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1510097__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_1510097__(/*! ./Timer */ "./Timer.ts");
/* harmony import */ var _TileMap__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1510097__(/*! ./TileMap */ "./TileMap/TileMap.ts");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1510097__(/*! ./Camera */ "./Camera.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1510097__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_1510097__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Trigger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1510097__(/*! ./Trigger */ "./Trigger.ts");
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_1510097__(/*! ./EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _EntityComponentSystem_World__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1510097__(/*! ./EntityComponentSystem/World */ "./EntityComponentSystem/World.ts");
/* harmony import */ var _Collision_MotionSystem__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1510097__(/*! ./Collision/MotionSystem */ "./Collision/MotionSystem.ts");
/* harmony import */ var _Collision_CollisionSystem__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1510097__(/*! ./Collision/CollisionSystem */ "./Collision/CollisionSystem.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_1510097__(/*! ./EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Graphics_GraphicsSystem__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_1510097__(/*! ./Graphics/GraphicsSystem */ "./Graphics/GraphicsSystem.ts");
/* harmony import */ var _Debug_DebugSystem__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_1510097__(/*! ./Debug/DebugSystem */ "./Debug/DebugSystem.ts");
/* harmony import */ var _Input_PointerSystem__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1510097__(/*! ./Input/PointerSystem */ "./Input/PointerSystem.ts");
/* harmony import */ var _Actions_ActionsSystem__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1510097__(/*! ./Actions/ActionsSystem */ "./Actions/ActionsSystem.ts");
/* harmony import */ var _TileMap_IsometricEntitySystem__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1510097__(/*! ./TileMap/IsometricEntitySystem */ "./TileMap/IsometricEntitySystem.ts");
/* harmony import */ var _Graphics_OffscreenSystem__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_1510097__(/*! ./Graphics/OffscreenSystem */ "./Graphics/OffscreenSystem.ts");
/* harmony import */ var _Collision_PhysicsWorld__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1510097__(/*! ./Collision/PhysicsWorld */ "./Collision/PhysicsWorld.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1510097__(/*! ./EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Input_InputHost__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_1510097__(/*! ./Input/InputHost */ "./Input/InputHost.ts");
/* harmony import */ var _Input_PointerScope__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_1510097__(/*! ./Input/PointerScope */ "./Input/PointerScope.ts");
/* harmony import */ var _Collision_PhysicsConfig__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1510097__(/*! ./Collision/PhysicsConfig */ "./Collision/PhysicsConfig.ts");

























class PreLoadEvent {
}
const SceneEvents = {
    Initialize: 'initialize',
    Activate: 'activate',
    Deactivate: 'deactivate',
    PreUpdate: 'preupdate',
    PostUpdate: 'postupdate',
    PreDraw: 'predraw',
    PostDraw: 'postdraw',
    PreDebugDraw: 'predebugdraw',
    PostDebugDraw: 'postdebugdraw',
    PreLoad: 'preload'
};
/**
 *
 */
function isSceneConstructor(x) {
    var _a, _b;
    return !!(x === null || x === void 0 ? void 0 : x.prototype) && !!((_b = (_a = x === null || x === void 0 ? void 0 : x.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
}
/**
 * {@apilink Actor | `Actors`} are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene {
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof _Trigger__WEBPACK_IMPORTED_MODULE_1__.Trigger;
        });
    }
    /**
     * The {@apilink TileMap}s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof _TileMap__WEBPACK_IMPORTED_MODULE_2__.TileMap;
        });
    }
    get timers() {
        return this._timers;
    }
    constructor() {
        // Initialize systems
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_3__.Logger.getInstance();
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_4__.EventEmitter();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_5__.Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new _EntityComponentSystem_World__WEBPACK_IMPORTED_MODULE_6__.World(this);
        /**
         * The Excalibur physics world for the scene. Used to interact
         * with colliders included in the scene.
         *
         * Can be used to perform scene ray casts, track colliders, broadphase, and narrowphase.
         */
        this.physics = new _Collision_PhysicsWorld__WEBPACK_IMPORTED_MODULE_7__.PhysicsWorld((0,_Collision_PhysicsConfig__WEBPACK_IMPORTED_MODULE_8__.getDefaultPhysicsConfig)());
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // Update
        this.world.add(_Actions_ActionsSystem__WEBPACK_IMPORTED_MODULE_9__.ActionsSystem);
        this.world.add(new _Collision_MotionSystem__WEBPACK_IMPORTED_MODULE_10__.MotionSystem(this.world, this.physics));
        this.world.add(new _Collision_CollisionSystem__WEBPACK_IMPORTED_MODULE_11__.CollisionSystem(this.world, this.physics));
        this.world.add(_Input_PointerSystem__WEBPACK_IMPORTED_MODULE_12__.PointerSystem);
        this.world.add(_TileMap_IsometricEntitySystem__WEBPACK_IMPORTED_MODULE_13__.IsometricEntitySystem);
        // Draw
        this.world.add(_Graphics_OffscreenSystem__WEBPACK_IMPORTED_MODULE_14__.OffscreenSystem);
        this.world.add(_Graphics_GraphicsSystem__WEBPACK_IMPORTED_MODULE_15__.GraphicsSystem);
        this.world.add(_Debug_DebugSystem__WEBPACK_IMPORTED_MODULE_16__.DebugSystem);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * Event hook to provide Scenes a way of loading scene specific resources.
     *
     * This is called before the Scene.onInitialize during scene transition. It will only ever fire once for a scene.
     * @param loader
     */
    onPreLoad(loader) {
        // will be overridden
    }
    /**
     * Event hook fired directly before transition, either "in" or "out" of the scene
     *
     * This overrides the Engine scene definition. However transitions specified in goToScene take highest precedence
     *
     * ```typescript
     * // Overrides all
     * Engine.goToScene('scene', { destinationIn: ..., sourceOut: ... });
     * ```
     *
     * This can be used to configure custom transitions for a scene dynamically
     */
    onTransition(direction) {
        // will be overridden
        return undefined;
    }
    /**
     * This is called before the first update of the {@apilink Scene}. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(context) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(context) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     * @param engine reference to the engine
     * @param elapsed  Number of milliseconds elapsed since the last draw.
     */
    onPreUpdate(engine, elapsed) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     * @param engine reference to the engine
     * @param elapsed  Number of milliseconds elapsed since the last draw.
     */
    onPostUpdate(engine, elapsed) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     *
     */
    onPreDraw(ctx, elapsed) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     *
     */
    onPostDraw(ctx, elapsed) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the {@apilink Scene} has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    async _initialize(engine) {
        var _a;
        if (!this.isInitialized) {
            try {
                this.engine = engine;
                // PhysicsWorld config is watched so things will automagically update
                this.physics.config = this.engine.physics;
                this.input = new _Input_InputHost__WEBPACK_IMPORTED_MODULE_17__.InputHost({
                    pointerTarget: engine.pointerScope === _Input_PointerScope__WEBPACK_IMPORTED_MODULE_18__.PointerScope.Canvas ? engine.canvas : document,
                    grabWindowFocus: engine.grabWindowFocus,
                    engine
                });
                // Initialize camera first
                this.camera._initialize(engine);
                this.world.systemManager.initialize();
                // This order is important! we want to be sure any custom init that add actors
                // fire before the actor init
                await this.onInitialize(engine);
                this._initializeChildren();
                this._logger.debug('Scene.onInitialize', this, engine);
                this.events.emit('initialize', new _Events__WEBPACK_IMPORTED_MODULE_19__.InitializeEvent(engine, this));
            }
            catch (e) {
                this._logger.error(`Error during scene initialization for scene ${(_a = engine.director) === null || _a === void 0 ? void 0 : _a.getSceneName(this)}!`);
                throw e;
            }
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    async _activate(context) {
        var _a, _b;
        try {
            this._logger.debug('Scene.onActivate', this);
            this.input.toggleEnabled(true);
            await this.onActivate(context);
        }
        catch (e) {
            this._logger.error(`Error during scene activation for scene ${(_b = (_a = this.engine) === null || _a === void 0 ? void 0 : _a.director) === null || _b === void 0 ? void 0 : _b.getSceneName(this)}!`);
            throw e;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    async _deactivate(context) {
        this._logger.debug('Scene.onDeactivate', this);
        this.input.toggleEnabled(false);
        await this.onDeactivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
     * @internal
     */
    _preupdate(engine, elapsed) {
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_19__.PreUpdateEvent(engine, elapsed, this));
        this.onPreUpdate(engine, elapsed);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
     * @internal
     */
    _postupdate(engine, elapsed) {
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_19__.PostUpdateEvent(engine, elapsed, this));
        this.onPostUpdate(engine, elapsed);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for {@apilink onPreDraw} lifecycle event
     * @internal
     */
    _predraw(ctx, elapsed) {
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_19__.PreDrawEvent(ctx, elapsed, this));
        this.onPreDraw(ctx, elapsed);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for {@apilink onPostDraw} lifecycle event
     * @internal
     */
    _postdraw(ctx, elapsed) {
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_19__.PostDrawEvent(ctx, elapsed, this));
        this.onPostDraw(ctx, elapsed);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the {@apilink Engine}.
     * @param engine  Reference to the current Engine
     * @param elapsed   The number of milliseconds since the last update
     */
    update(engine, elapsed) {
        var _a;
        if (!this.isInitialized) {
            this._logger.warnOnce(`Scene update called before initialize for scene ${(_a = engine.director) === null || _a === void 0 ? void 0 : _a.getSceneName(this)}!`);
            return;
        }
        this._preupdate(engine, elapsed);
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(elapsed);
        }
        this.world.update(_EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_20__.SystemType.Update, elapsed);
        // Camera last keeps renders smooth that are based on entity/actor
        if (this.camera) {
            this.camera.update(engine, elapsed);
        }
        this._collectActorStats(engine);
        this._postupdate(engine, elapsed);
        this.input.update();
    }
    /**
     * Draws all the actors in the Scene. Called by the {@apilink Engine}.
     * @param ctx    The current rendering context
     * @param elapsed  The number of milliseconds since the last draw
     */
    draw(ctx, elapsed) {
        var _a;
        if (!this.isInitialized) {
            this._logger.warnOnce(`Scene draw called before initialize!`);
            return;
        }
        this._predraw(ctx, elapsed);
        this.world.update(_EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_20__.SystemType.Draw, elapsed);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, elapsed);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the {@apilink Engine}.
     * @param ctx  The current rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_19__.PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new _Events__WEBPACK_IMPORTED_MODULE_19__.PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof _Timer__WEBPACK_IMPORTED_MODULE_21__.Timer) {
            if (!_Util_Util__WEBPACK_IMPORTED_MODULE_22__.contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    /**
     * Removes an {@apilink Entity} (Actor, TileMap, Trigger, etc) or {@apilink Timer} from it's current scene
     * and adds it to this scene.
     *
     * Useful if you want to have an object be present in only 1 scene at a time.
     * @param entity
     */
    transfer(entity) {
        let scene;
        if (entity instanceof _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_23__.Entity && entity.scene && entity.scene !== this) {
            scene = entity.scene;
            entity.scene.world.remove(entity, false);
        }
        if (entity instanceof _Timer__WEBPACK_IMPORTED_MODULE_21__.Timer && entity.scene) {
            scene = entity.scene;
            entity.scene.removeTimer(entity);
        }
        scene === null || scene === void 0 ? void 0 : scene.emit('entityremoved', { target: entity });
        this.add(entity);
    }
    remove(entity) {
        if (entity instanceof _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_23__.Entity) {
            this.emit('entityremoved', { target: entity });
            if (entity.isActive) {
                entity.kill();
            }
            this.world.remove(entity);
        }
        if (entity instanceof _Timer__WEBPACK_IMPORTED_MODULE_21__.Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
     *
     * By default entities use deferred removal
     * @param deferred
     */
    clear(deferred = true) {
        for (let i = this.entities.length - 1; i >= 0; i--) {
            this.world.remove(this.entities[i], deferred);
        }
        for (let i = this.timers.length - 1; i >= 0; i--) {
            this.removeTimer(this.timers[i]);
        }
    }
    /**
     * Adds a {@apilink Timer} to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a {@apilink Timer} from the scene.
     * @warning Can be dangerous, use {@apilink cancelTimer} instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a {@apilink Timer}, removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a {@apilink Timer} is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const actors = this.actors;
        for (let i = 0; i < actors.length; i++) {
            const actor = actors[i];
            if (actor instanceof _ScreenElement__WEBPACK_IMPORTED_MODULE_24__.ScreenElement) {
                engine.stats.currFrame.actors.ui++;
            }
            engine.stats.currFrame.actors.alive++;
            for (let j = 0; j < actor.children.length; j++) {
                const child = actor.children[j];
                if ((0,_ScreenElement__WEBPACK_IMPORTED_MODULE_24__.isScreenElement)(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}


/***/ }),

/***/ "./Screen.ts":
/*!*******************!*\
  !*** ./Screen.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1533324__) => {

__nested_webpack_require_1533324__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1533324__.d(__nested_webpack_exports__, {
/* harmony export */   DisplayMode: () => (/* binding */ DisplayMode),
/* harmony export */   Resolution: () => (/* binding */ Resolution),
/* harmony export */   Screen: () => (/* binding */ Screen),
/* harmony export */   ScreenEvents: () => (/* binding */ ScreenEvents)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1533324__(/*! ./Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1533324__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1533324__(/*! ./Collision/Index */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1533324__(/*! ./Util/Util */ "./Util/Util.ts");
/* harmony import */ var _Graphics_Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1533324__(/*! ./Graphics/Context/ExcaliburGraphicsContextWebGL */ "./Graphics/Context/ExcaliburGraphicsContextWebGL.ts");
/* harmony import */ var _Graphics_Context_ExcaliburGraphicsContext2DCanvas__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1533324__(/*! ./Graphics/Context/ExcaliburGraphicsContext2DCanvas */ "./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1533324__(/*! ./EventEmitter */ "./EventEmitter.ts");







/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.
     * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the {@apilink Screen.contentArea}
     * is guaranteed to be on screen.
     */
    DisplayMode["FitContainerAndFill"] = "FitContainerAndFill";
    /**
     * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.
     * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the {@apilink Screen.contentArea}
     * is guaranteed to be on screen.
     */
    DisplayMode["FitScreenAndFill"] = "FitScreenAndFill";
    /**
     * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in {@apilink FitContainer}.
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use {@apilink Screen.contentArea} to know the safe to draw area.
     */
    DisplayMode["FitContainerAndZoom"] = "FitContainerAndZoom";
    /**
     * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in {@apilink FitScreen}.
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use {@apilink Screen.contentArea} to know the safe to draw area.
     */
    DisplayMode["FitScreenAndZoom"] = "FitScreenAndZoom";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as {@apilink Screen.goFullScreen} but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as {@apilink Screen.goFullScreen}
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
const ScreenEvents = {
    ScreenResize: 'resize',
    PixelRatioChange: 'pixelratio',
    FullScreenChange: 'fullscreen'
};
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c, _d;
        /**
         * Listen to screen events {@apilink ScreenEvents}
         */
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._antialiasing = true;
        this._canvasImageRendering = 'auto';
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullscreen = false;
        this._isDisposed = false;
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            if (this._isDisposed) {
                return;
            }
            this._isFullscreen = !this._isFullscreen;
            this._logger.debug('Fullscreen Change', this._isFullscreen);
            this.events.emit('fullscreen', {
                fullscreen: this.isFullScreen
            });
        };
        this._pixelRatioChangeHandler = () => {
            if (this._isDisposed) {
                return;
            }
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._listenForPixelRatio();
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
            this.events.emit('pixelratio', {
                pixelRatio: this.pixelRatio
            });
        };
        this._resizeHandler = () => {
            if (this._isDisposed) {
                return;
            }
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
            // Emit resize event
            this.events.emit('resize', {
                resolution: this.resolution,
                viewport: this.viewport
            });
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._contentArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();
        this._unsafeArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : { ...this.viewport };
        this._contentResolution = this.resolution;
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this.graphicsContext = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._canvasImageRendering = (_d = options.canvasImageRendering) !== null && _d !== void 0 ? _d : this._canvasImageRendering;
        this._browser = options.browser;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._listenForPixelRatio();
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    _listenForPixelRatio() {
        if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {
            // Safari <=13.1 workaround, remove any existing handlers
            this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
        }
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        // Safari <=13.1 workaround
        if (this._mediaQueryList.addEventListener) {
            this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });
        }
        else {
            this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
        }
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this.events.clear();
            this._browser.window.off('resize', this._resizeHandler);
            this._browser.window.clear();
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            // Safari <=13.1 workaround
            if (this._mediaQueryList.removeEventListener) {
                this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            }
            else {
                this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
            }
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
            this._canvas = null;
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    /**
     * Returns the computed pixel ratio, first using any override, then the device pixel ratio
     */
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    /**
     * This calculates the ratio between excalibur pixels and the HTML pixels.
     *
     * This is useful for scaling HTML UI so that it matches your game.
     */
    get worldToPagePixelRatio() {
        if (this._canvas) {
            const pageOrigin = this.worldToPageCoordinates(_Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
            const pageDistance = this.worldToPageCoordinates((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(1, 0)).sub(pageOrigin);
            const pixelConversion = pageDistance.x;
            return pixelConversion;
        }
        else {
            return 1;
        }
    }
    /**
     * Get or set the pixel ratio override
     *
     * You will need to call applyResolutionAndViewport() affect change on the screen
     */
    get pixelRatioOverride() {
        return this._pixelRatioOverride;
    }
    set pixelRatioOverride(value) {
        this._pixelRatioOverride = value;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        switch (this.displayMode) {
            case DisplayMode.FillContainer:
            case DisplayMode.FitContainer:
            case DisplayMode.FitContainerAndFill:
            case DisplayMode.FitContainerAndZoom:
                return this.canvas.parentElement || document.body;
            default:
                return window;
        }
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    /**
     * Returns screen dimensions in pixels or percentage
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = { ...this.resolution };
        this.viewport = { ...this.viewport };
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        if (this._resolutionStack.length && this._viewportStack.length) {
            this.resolution = this._resolutionStack.pop();
            this.viewport = this._viewportStack.pop();
        }
    }
    applyResolutionAndViewport() {
        if (this.graphicsContext instanceof _Graphics_Context_ExcaliburGraphicsContextWebGL__WEBPACK_IMPORTED_MODULE_4__.ExcaliburGraphicsContextWebGL) {
            const scaledResolutionSupported = this.graphicsContext.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!scaledResolutionSupported) {
                this._logger.warnOnce(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +
                    ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
                // Attempt to recover if the user hasn't configured a specific ratio for up scaling
                if (!this.pixelRatioOverride) {
                    let currentPixelRatio = Math.max(1, this.pixelRatio - 0.5);
                    let newResolutionSupported = false;
                    while (currentPixelRatio > 1 && !newResolutionSupported) {
                        currentPixelRatio = Math.max(1, currentPixelRatio - 0.5);
                        const width = this._resolution.width * currentPixelRatio;
                        const height = this._resolution.height * currentPixelRatio;
                        newResolutionSupported = this.graphicsContext.checkIfResolutionSupported({ width, height });
                    }
                    this.pixelRatioOverride = currentPixelRatio;
                    this._logger.warnOnce('Scaled resolution too big attempted recovery!' +
                        ` Pixel ratio was automatically reduced to (${this.pixelRatio}) to avoid 4k texture limit.` +
                        ' Setting `ex.Engine({pixelRatio: ...}) will override any automatic recalculation, do so at your own risk.` ' +
                        ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
                }
            }
        }
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this._canvasImageRendering === 'auto') {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        const widthUnit = this.viewport.widthUnit === 'percent' ? '%' : 'px';
        const heightUnit = this.viewport.heightUnit === 'percent' ? '%' : 'px';
        this._canvas.style.width = this.viewport.width + widthUnit;
        this._canvas.style.height = this.viewport.height + heightUnit;
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this.graphicsContext.updateViewport(this.resolution);
        this.graphicsContext.resetTransform();
        this.graphicsContext.smoothing = this._antialiasing;
        if (this.graphicsContext instanceof _Graphics_Context_ExcaliburGraphicsContext2DCanvas__WEBPACK_IMPORTED_MODULE_5__.ExcaliburGraphicsContext2DCanvas) {
            this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);
        }
        // Add the excalibur world pixel to page pixel
        document.documentElement.style.setProperty('--ex-pixel-ratio', this.worldToPagePixelRatio.toString());
    }
    /**
     * Get or set screen antialiasing,
     *
     * If true smoothing is applied
     */
    get antialiasing() {
        return this._antialiasing;
    }
    /**
     * Get or set screen antialiasing
     */
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this.graphicsContext.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreen using the browser fullscreen api
     * @deprecated use isFullscreen()
     */
    get isFullScreen() {
        return this._isFullscreen;
    }
    /**
     * Returns true if excalibur is fullscreen using the browser fullscreen api
     */
    get isFullscreen() {
        return this._isFullscreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     *
     * Optionally specify a target element id to go fullscreen, by default the game canvas is used
     * @param elementId
     * @deprecated use enterFullscreen(...)
     */
    goFullScreen(elementId) {
        return this.enterFullscreen(elementId);
    }
    /**
     * Requests to enter fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     *
     * Optionally specify a target element id to go fullscreen, by default the game canvas is used
     * @param elementId
     */
    enterFullscreen(elementId) {
        if (elementId) {
            const maybeElement = document.getElementById(elementId);
            if (maybeElement) {
                if (!maybeElement.getAttribute('ex-fullscreen-listener')) {
                    maybeElement.setAttribute('ex-fullscreen-listener', 'true');
                    maybeElement.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
                }
                const fullscreenPromise = maybeElement.requestFullscreen();
                return fullscreenPromise;
            }
        }
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     * @deprecated use exitFullscreen()
     */
    exitFullScreen() {
        return this.exitFullscreen();
    }
    exitFullscreen() {
        return document.exitFullscreen();
    }
    _viewportToPixels(viewport) {
        return {
            width: viewport.widthUnit === 'percent' ? this.canvas.offsetWidth : viewport.width,
            height: viewport.heightUnit === 'percent' ? this.canvas.offsetHeight : viewport.height
        };
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY). When using *AndFill suffixed display modes screen space
     * (0, 0) is the top left of the safe content area bounding box not the viewport.
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullscreen) {
            newX -= (0,_Util_Util__WEBPACK_IMPORTED_MODULE_6__.getPosition)(this._canvas).x;
            newY -= (0,_Util_Util__WEBPACK_IMPORTED_MODULE_6__.getPosition)(this._canvas).y;
        }
        const viewport = this._viewportToPixels(this.viewport);
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullscreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * viewport.height;
                newX = (newX / window.innerWidth) * viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * viewport.width;
                newY = (newY / window.innerHeight) * viewport.height;
            }
        }
        newX = (newX / viewport.width) * this.resolution.width;
        newY = (newY / viewport.height) * this.resolution.height;
        // offset by content area
        newX = newX - this.contentArea.left;
        newY = newY - this.contentArea.top;
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        // no need to offset by content area, drawing is already offset by this
        const viewport = this._viewportToPixels(this.viewport);
        newX = (newX / this.resolution.width) * viewport.width;
        newY = (newY / this.resolution.height) * viewport.height;
        if (this._isFullscreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / viewport.height) * screenHeight + screenMarginY;
                newX = (newX / viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / viewport.width) * screenWidth + screenMarginX;
                newY = (newY / viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullscreen) {
            newX += (0,_Util_Util__WEBPACK_IMPORTED_MODULE_6__.getPosition)(this._canvas).x;
            newY += (0,_Util_Util__WEBPACK_IMPORTED_MODULE_6__.getPosition)(this._canvas).y;
        }
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where {@apilink Entity | `entities`} in Excalibur live by default {@apilink CoordPlane.World}
     * and extends infinitely out relative from the {@apilink Camera}.
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        // offset by content area
        point = point.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this.contentArea.left, this.contentArea.top));
        // the only difference between screen & world is the camera transform
        if (this._camera) {
            return this._camera.inverse.multiply(point);
        }
        return point.sub((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this.resolution.width / 2, this.resolution.height / 2));
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where {@apilink ScreenElement | `screen elements`} and {@apilink Entity | `entities`} with {@apilink CoordPlane.Screen} live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        if (this._camera) {
            return this._camera.transform.multiply(point);
        }
        return point.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this.resolution.width / 2, this.resolution.height / 2));
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen that are in world space
     */
    getWorldBounds() {
        const bounds = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Half)
            .scale((0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(1 / this._camera.zoom, 1 / this._camera.zoom))
            .rotate(this._camera.rotation)
            .translate(this._camera.drawPos);
        return bounds;
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen and the bottom right corner of the screen.
     *
     * Screen bounds are in screen coordinates, useful for culling objects offscreen that are in screen space
     */
    getScreenBounds() {
        const bounds = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        return bounds;
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get width() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    get height() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(this.halfDrawWidth, this.halfDrawHeight);
    }
    /**
     * Returns the content area in screen space where it is safe to place content
     */
    get contentArea() {
        return this._contentArea;
    }
    /**
     * Returns the unsafe area in screen space, this is the full screen and some space may not be onscreen.
     */
    get unsafeArea() {
        return this._unsafeArea;
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
        this._contentArea = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        this._unsafeArea = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _computeFitScreenAndFill() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndFill(vw, vh);
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _computeFitContainerAndFill() {
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this._computeFitAndFill(this.canvas.offsetWidth, this.canvas.offsetHeight, {
            width: 100,
            widthUnit: 'percent',
            height: 100,
            heightUnit: 'percent'
        });
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _computeFitAndFill(vw, vh, viewport) {
        this.viewport = viewport !== null && viewport !== void 0 ? viewport : {
            width: vw,
            height: vh
        };
        // if the current screen aspectRatio is less than the original aspectRatio
        if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {
            // compute new resolution to match the original aspect ratio
            this.resolution = {
                width: (vw * this._contentResolution.width) / vw,
                height: (((vw * this._contentResolution.width) / vw) * vh) / vw
            };
            const clip = (this.resolution.height - this._contentResolution.height) / 2;
            this._contentArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox({
                top: clip,
                left: 0,
                right: this._contentResolution.width,
                bottom: this.resolution.height - clip
            });
            this._unsafeArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox({
                top: -clip,
                left: 0,
                right: this._contentResolution.width,
                bottom: this.resolution.height + clip
            });
        }
        else {
            this.resolution = {
                width: (((vh * this._contentResolution.height) / vh) * vw) / vh,
                height: (vh * this._contentResolution.height) / vh
            };
            const clip = (this.resolution.width - this._contentResolution.width) / 2;
            this._contentArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox({
                top: 0,
                left: clip,
                right: this.resolution.width - clip,
                bottom: this._contentResolution.height
            });
            this._unsafeArea = new _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox({
                top: 0,
                left: -clip,
                right: this.resolution.width + clip,
                bottom: this._contentResolution.height
            });
        }
    }
    _computeFitScreenAndZoom() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        this.canvas.style.position = 'absolute';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndZoom(vw, vh);
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _computeFitContainerAndZoom() {
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.position = 'relative';
        const parent = this.canvas.parentElement;
        parent.style.overflow = 'hidden';
        const { offsetWidth: vw, offsetHeight: vh } = this.canvas;
        this._computeFitAndZoom(vw, vh);
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _computeFitAndZoom(vw, vh) {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (vw / aspect < vh) {
            adjustedWidth = vw;
            adjustedHeight = vw / aspect;
        }
        else {
            adjustedWidth = vh * aspect;
            adjustedHeight = vh;
        }
        const scaleX = vw / adjustedWidth;
        const scaleY = vh / adjustedHeight;
        const maxScaleFactor = Math.max(scaleX, scaleY);
        const zoomedWidth = adjustedWidth * maxScaleFactor;
        const zoomedHeight = adjustedHeight * maxScaleFactor;
        // Center zoomed dimension if bigger than the screen
        if (zoomedWidth > vw) {
            this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';
        }
        else {
            this.canvas.style.left = '';
        }
        if (zoomedHeight > vh) {
            this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';
        }
        else {
            this.canvas.style.top = '';
        }
        this.viewport = {
            width: zoomedWidth,
            height: zoomedHeight
        };
        const bounds = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.viewport.width, this.viewport.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        // return safe area
        if (this.viewport.width > vw) {
            const clip = ((this.viewport.width - vw) / this.viewport.width) * this.resolution.width;
            bounds.top = 0;
            bounds.left = clip / 2;
            bounds.right = this.resolution.width - clip / 2;
            bounds.bottom = this.resolution.height;
        }
        if (this.viewport.height > vh) {
            const clip = ((this.viewport.height - vh) / this.viewport.height) * this.resolution.height;
            bounds.top = clip / 2;
            bounds.left = 0;
            bounds.bottom = this.resolution.height - clip / 2;
            bounds.right = this.resolution.width;
        }
        this._contentArea = bounds;
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        let widthUnit = 'pixel';
        let heightUnit = 'pixel';
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            this.canvas.style.width = '100%';
            adjustedWidth = 100;
            widthUnit = 'percent';
            adjustedHeight = this.canvas.offsetWidth / aspect;
        }
        else {
            this.canvas.style.height = '100%';
            adjustedHeight = 100;
            heightUnit = 'percent';
            adjustedWidth = this.canvas.offsetHeight * aspect;
        }
        this.viewport = {
            width: adjustedWidth,
            widthUnit,
            height: adjustedHeight,
            heightUnit
        };
        this._contentArea = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        this.events.emit('resize', {
            resolution: this.resolution,
            viewport: this.viewport
        });
    }
    _applyDisplayMode() {
        this._setResolutionAndViewportByDisplayMode(this.parent);
        // watch resizing
        if (this.parent instanceof Window) {
            this._browser.window.on('resize', this._resizeHandler);
        }
        else {
            this._resizeObserver = new ResizeObserver(() => {
                this._resizeHandler();
            });
            this._resizeObserver.observe(this.parent);
        }
        this.parent.addEventListener('resize', this._resizeHandler);
    }
    /**
     * Sets the resolution and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.viewport = {
                width: 100,
                widthUnit: 'percent',
                height: 100,
                heightUnit: 'percent'
            };
            this.resolution = {
                width: this.canvas.offsetWidth,
                height: this.canvas.offsetHeight
            };
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        this._contentArea = _Collision_Index__WEBPACK_IMPORTED_MODULE_2__.BoundingBox.fromDimension(this.resolution.width, this.resolution.height, _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector.Zero);
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
        if (this.displayMode === DisplayMode.FitScreenAndFill) {
            this._computeFitScreenAndFill();
        }
        if (this.displayMode === DisplayMode.FitContainerAndFill) {
            this._computeFitContainerAndFill();
        }
        if (this.displayMode === DisplayMode.FitScreenAndZoom) {
            this._computeFitScreenAndZoom();
        }
        if (this.displayMode === DisplayMode.FitContainerAndZoom) {
            this._computeFitContainerAndZoom();
        }
    }
}


/***/ }),

/***/ "./ScreenElement.ts":
/*!**************************!*\
  !*** ./ScreenElement.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1574892__) => {

__nested_webpack_require_1574892__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1574892__.d(__nested_webpack_exports__, {
/* harmony export */   ScreenElement: () => (/* binding */ ScreenElement),
/* harmony export */   isScreenElement: () => (/* binding */ isScreenElement)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1574892__(/*! ./Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1574892__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1574892__(/*! ./EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1574892__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1574892__(/*! ./Math/coord-plane */ "./Math/coord-plane.ts");





/**
 * Type guard to detect a screen element
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement;
}
/**
 * Helper {@apilink Actor} primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement extends _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor {
    constructor(config) {
        var _a, _b;
        super({ ...config });
        this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).coordPlane = _Math_coord_plane__WEBPACK_IMPORTED_MODULE_2__.CoordPlane.Screen;
        this.anchor = (_a = config === null || config === void 0 ? void 0 : config.anchor) !== null && _a !== void 0 ? _a : (0,_Math_vector__WEBPACK_IMPORTED_MODULE_3__.vec)(0, 0);
        this.body.collisionType = (_b = config === null || config === void 0 ? void 0 : config.collisionType) !== null && _b !== void 0 ? _b : _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_4__.CollisionType.PreventCollision;
        this.pointer.useGraphicsBounds = true;
        this.pointer.useColliderShape = false;
        if (!(config === null || config === void 0 ? void 0 : config.collider) && (config === null || config === void 0 ? void 0 : config.width) > 0 && (config === null || config === void 0 ? void 0 : config.height) > 0) {
            this.collider.useBoxCollider(this.width, this.height, this.anchor);
        }
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new _Math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}


/***/ }),

/***/ "./TileMap/IsometricEntityComponent.ts":
/*!*********************************************!*\
  !*** ./TileMap/IsometricEntityComponent.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1578137__) => {

__nested_webpack_require_1578137__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1578137__.d(__nested_webpack_exports__, {
/* harmony export */   IsometricEntityComponent: () => (/* binding */ IsometricEntityComponent)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1578137__(/*! ../EntityComponentSystem/Component */ "./EntityComponentSystem/Component.ts");

class IsometricEntityComponent extends _EntityComponentSystem_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    /**
     * Specify the isometric map to use to position this entity's z-index
     * @param mapOrOptions
     */
    constructor(mapOrOptions) {
        super();
        /**
         * Vertical "height" in the isometric world
         */
        this.elevation = 0;
        this.columns = mapOrOptions.columns;
        this.rows = mapOrOptions.rows;
        this.tileWidth = mapOrOptions.tileWidth;
        this.tileHeight = mapOrOptions.tileHeight;
    }
}


/***/ }),

/***/ "./TileMap/IsometricEntitySystem.ts":
/*!******************************************!*\
  !*** ./TileMap/IsometricEntitySystem.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1579417__) => {

__nested_webpack_require_1579417__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1579417__.d(__nested_webpack_exports__, {
/* harmony export */   IsometricEntitySystem: () => (/* binding */ IsometricEntitySystem)
/* harmony export */ });
/* harmony import */ var _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1579417__(/*! ../EntityComponentSystem/System */ "./EntityComponentSystem/System.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1579417__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1579417__(/*! ./IsometricEntityComponent */ "./TileMap/IsometricEntityComponent.ts");
/* harmony import */ var _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1579417__(/*! ../EntityComponentSystem */ "./EntityComponentSystem/Priority.ts");




class IsometricEntitySystem extends _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.System {
    constructor(world) {
        super();
        this.world = world;
        this.systemType = _EntityComponentSystem_System__WEBPACK_IMPORTED_MODULE_0__.SystemType.Update;
        this.query = this.world.query([_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent, _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_2__.IsometricEntityComponent]);
    }
    update() {
        let transform;
        let iso;
        for (let i = 0; i < this.query.entities.length; i++) {
            const entity = this.query.entities[i];
            transform = entity.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
            iso = entity.get(_IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_2__.IsometricEntityComponent);
            const maxZindexPerElevation = Math.max(iso.columns * iso.tileWidth, iso.rows * iso.tileHeight);
            const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;
            transform.z = newZ;
        }
    }
}
IsometricEntitySystem.priority = _EntityComponentSystem__WEBPACK_IMPORTED_MODULE_3__.SystemPriority.Lower;


/***/ }),

/***/ "./TileMap/IsometricMap.ts":
/*!*********************************!*\
  !*** ./TileMap/IsometricMap.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1581948__) => {

__nested_webpack_require_1581948__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1581948__.d(__nested_webpack_exports__, {
/* harmony export */   IsometricMap: () => (/* binding */ IsometricMap),
/* harmony export */   IsometricTile: () => (/* binding */ IsometricTile)
/* harmony export */ });
/* harmony import */ var _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1581948__(/*! ../Collision/BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1581948__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1581948__(/*! ../Collision/ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1581948__(/*! ../Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Collision_Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1581948__(/*! ../Collision/Colliders/CompositeCollider */ "./Collision/Colliders/CompositeCollider.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1581948__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1581948__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1581948__(/*! ../EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1581948__(/*! ../Graphics */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1581948__(/*! ../Graphics */ "./Graphics/DebugGraphicsComponent.ts");
/* harmony import */ var _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1581948__(/*! ./IsometricEntityComponent */ "./TileMap/IsometricEntityComponent.ts");
/* harmony import */ var _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1581948__(/*! ../Input/PointerComponent */ "./Input/PointerComponent.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1581948__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Input_PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1581948__(/*! ../Input/PointerEventsToObjectDispatcher */ "./Input/PointerEventsToObjectDispatcher.ts");













class IsometricTile extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    getGraphics() {
        return this._graphics;
    }
    /**
     * Tile graphics
     */
    addGraphic(graphic, options) {
        this._graphics.push(graphic);
        this._gfx.isVisible = this.map.isVisible;
        this._gfx.opacity = this.map.opacity;
        if (options === null || options === void 0 ? void 0 : options.offset) {
            this._gfx.offset = options.offset;
        }
        // TODO detect when this changes on the map and apply to all tiles
        this._gfx.localBounds = this._recalculateBounds();
    }
    _recalculateBounds() {
        let bounds = this._tileBounds.clone();
        for (const graphic of this._graphics) {
            const offset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));
            bounds = bounds.combine(graphic.localBounds.translate(offset));
        }
        return bounds;
    }
    removeGraphic(graphic) {
        const index = this._graphics.indexOf(graphic);
        if (index > -1) {
            this._graphics.splice(index, 1);
        }
        this._gfx.localBounds = this._recalculateBounds();
    }
    clearGraphics() {
        this._graphics.length = 0;
        this._gfx.isVisible = false;
        this._gfx.localBounds = this._recalculateBounds();
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a collider to the IsometricTile
     *
     * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the IsometricTile
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the IsometricTile
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    /**
     * Returns the top left corner of the {@apilink IsometricTile} in world space
     */
    get pos() {
        return this.map.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this.x, this.y));
    }
    /**
     * Returns the center of the {@apilink IsometricTile}
     */
    get center() {
        return this.pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, this.map.tileHeight / 2));
    }
    /**
     * Construct a new IsometricTile
     * @param x tile coordinate in x (not world position)
     * @param y tile coordinate in y (not world position)
     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
     * @param map reference to owning IsometricMap
     */
    constructor(x, y, graphicsOffset, map) {
        super([
            new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent(),
            new _Graphics__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent({
                offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero,
                onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)
            }),
            new _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_4__.IsometricEntityComponent(map)
        ]);
        /**
         * Indicates whether this tile is solid
         */
        this.solid = false;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
        this._tileBounds = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox();
        this._graphics = [];
        /**
         * Tile colliders
         */
        this._colliders = [];
        /**
         * Arbitrary data storage per tile, useful for any game specific data
         */
        this.data = new Map();
        this.x = x;
        this.y = y;
        this.map = map;
        this._transform = this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        this._isometricEntityComponent = this.get(_IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_4__.IsometricEntityComponent);
        const halfTileWidth = this.map.tileWidth / 2;
        const halfTileHeight = this.map.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        // The x position shifts left with every y step
        const xPos = (this.x - this.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (this.x + this.y) * halfTileHeight;
        this._transform.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(xPos, yPos);
        this._isometricEntityComponent.elevation = map.elevation;
        this._gfx = this.get(_Graphics__WEBPACK_IMPORTED_MODULE_3__.GraphicsComponent);
        this._gfx.isVisible = false; // start not visible
        const totalWidth = this.map.tileWidth;
        const totalHeight = this.map.tileHeight;
        // initial guess at gfx bounds based on the tile
        const offset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, this.map.renderFromTopOfGraphic ? totalHeight : 0);
        this._gfx.localBounds = this._tileBounds = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox({
            left: -totalWidth / 2,
            top: -totalHeight,
            right: totalWidth / 2,
            bottom: totalHeight
        }).translate(offset);
    }
    draw(gfx, _elapsed) {
        const halfTileWidth = this.map.tileWidth / 2;
        gfx.save();
        // shift left origin to corner of map, not the left corner of the first sprite
        gfx.translate(-halfTileWidth, 0);
        for (const graphic of this._graphics) {
            graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));
        }
        gfx.restore();
    }
}
/**
 * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur
 *
 * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.
 * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.
 *
 * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given
 * your art assets.
 */
class IsometricMap extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    /**
     * Whether tiles should be visible
     * @deprecated use isVisible
     */
    get visible() {
        return this.isVisible;
    }
    /**
     * Whether tiles should be visible
     * @deprecated use isVisible
     */
    set visible(val) {
        this.isVisible = val;
    }
    constructor(options) {
        super([
            new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent(),
            new _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_7__.BodyComponent({
                type: _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_8__.CollisionType.Fixed
            }),
            new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_9__.ColliderComponent(),
            new _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_10__.PointerComponent(),
            new _Graphics__WEBPACK_IMPORTED_MODULE_11__.DebugGraphicsComponent((ctx, debugFlags) => this.debug(ctx, debugFlags), false)
        ], options.name);
        this.elevation = 0;
        /**
         * Whether tiles should be visible
         */
        this.isVisible = true;
        /**
         * Opacity of tiles
         */
        this.opacity = 1.0;
        /**
         * Render the tile graphic from the top instead of the bottom
         *
         * default is `false` meaning rendering from the bottom
         */
        this.renderFromTopOfGraphic = false;
        this.graphicsOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0);
        this._collidersDirty = false;
        this._originalOffsets = new WeakMap();
        const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset, elevation } = options;
        this.transform = this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent);
        if (pos) {
            this.transform.pos = pos;
        }
        this.collider = this.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_9__.ColliderComponent);
        if (this.collider) {
            this.collider.set((this._composite = new _Collision_Colliders_CompositeCollider__WEBPACK_IMPORTED_MODULE_12__.CompositeCollider([])));
        }
        this.pointer = this.get(_Input_PointerComponent__WEBPACK_IMPORTED_MODULE_10__.PointerComponent);
        this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;
        this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;
        this.elevation = elevation !== null && elevation !== void 0 ? elevation : this.elevation;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.columns = width;
        this.rows = height;
        this._pointerEventDispatcher = new _Input_PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_13__.PointerEventsToObjectDispatcher();
        this.tiles = new Array(width * height);
        // build up tile representation
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const tile = new IsometricTile(x, y, this.graphicsOffset, this);
                this.tiles[x + y * width] = tile;
                this.addChild(tile);
                this._pointerEventDispatcher.addObject(tile, (p) => this.getTileByPoint(p.worldPos) === tile, () => true);
            }
        }
        this.pointer.localBounds = _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox.fromDimension(tileWidth * width * this.transform.scale.x, tileHeight * height * this.transform.scale.y, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0.5, 0));
    }
    /**
     * @internal
     */
    _processPointerToObject(receiver) {
        this._pointerEventDispatcher.processPointerToObject(receiver, this.tiles);
    }
    /**
     * @internal
     */
    _dispatchPointerEvents(receiver) {
        this._pointerEventDispatcher.dispatchEvents(receiver, this.tiles);
    }
    update() {
        if (this._collidersDirty) {
            this.updateColliders();
            this._collidersDirty = false;
        }
        this._pointerEventDispatcher.clear();
    }
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    _getOrSetColliderOriginalOffset(collider) {
        var _a;
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return (_a = this._originalOffsets.get(collider)) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector.Zero;
        }
    }
    updateColliders() {
        this._composite.clearColliders();
        const pos = this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent).pos;
        for (const tile of this.tiles) {
            if (tile.solid) {
                for (const collider of tile.getColliders()) {
                    const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                    collider.offset = this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(tile.x, tile.y))
                        .sub(pos)
                        .add(originalOffset)
                        .sub((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing
                    collider.owner = this;
                    this._composite.addCollider(collider);
                }
            }
        }
        this.collider.update();
    }
    /**
     * Convert world space coordinates to the tile x, y coordinate
     * @param worldCoordinate
     */
    worldToTile(worldCoordinate) {
        // TODO I don't think this handles parent transform see TileMap
        worldCoordinate = worldCoordinate.sub(this.transform.globalPos);
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(~~((worldCoordinate.x / halfTileWidth + worldCoordinate.y / halfTileHeight) / 2), ~~((worldCoordinate.y / halfTileHeight - worldCoordinate.x / halfTileWidth) / 2));
    }
    /**
     * Given a tile coordinate, return the top left corner in world space
     * @param tileCoordinate
     */
    tileToWorld(tileCoordinate) {
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // The x position shifts left with every y step
        const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;
        return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(xPos, yPos).add(this.transform.pos);
    }
    /**
     * Returns the {@apilink IsometricTile} by its x and y coordinates
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the {@apilink IsometricTile} by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const tileCoord = this.worldToTile(point);
        const tile = this.getTile(tileCoord.x, tileCoord.y);
        return tile;
    }
    _getMaxZIndex() {
        let maxZ = Number.NEGATIVE_INFINITY;
        for (const tile of this.tiles) {
            const currentZ = tile.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__.TransformComponent).z;
            if (currentZ > maxZ) {
                maxZ = currentZ;
            }
        }
        return maxZ;
    }
    /**
     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
     * @param gfx
     */
    debug(gfx, debugFlags) {
        const { showAll, showPosition, positionColor, positionSize, showGrid, gridColor, gridWidth, showColliderGeometry } = debugFlags.isometric;
        const { geometryColor, geometryLineWidth, geometryPointSize } = debugFlags.collider;
        gfx.save();
        gfx.z = this._getMaxZIndex() + 0.5;
        if (showAll || showGrid) {
            for (let y = 0; y < this.rows + 1; y++) {
                const left = this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, y));
                const right = this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(this.columns, y));
                gfx.drawLine(left, right, gridColor, gridWidth);
            }
            for (let x = 0; x < this.columns + 1; x++) {
                const top = this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(x, 0));
                const bottom = this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(x, this.rows));
                gfx.drawLine(top, bottom, gridColor, gridWidth);
            }
        }
        if (showAll || showPosition) {
            for (const tile of this.tiles) {
                gfx.drawCircle(this.tileToWorld((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(tile.x, tile.y)), positionSize, positionColor);
            }
        }
        if (showAll || showColliderGeometry) {
            for (const tile of this.tiles) {
                if (tile.solid) {
                    // only draw solid tiles
                    for (const collider of tile.getColliders()) {
                        collider.debug(gfx, geometryColor, { lineWidth: geometryLineWidth, pointSize: geometryPointSize });
                    }
                }
            }
        }
        gfx.restore();
    }
}


/***/ }),

/***/ "./TileMap/TileMap.ts":
/*!****************************!*\
  !*** ./TileMap/TileMap.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1601779__) => {

__nested_webpack_require_1601779__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1601779__.d(__nested_webpack_exports__, {
/* harmony export */   Tile: () => (/* binding */ Tile),
/* harmony export */   TileMap: () => (/* binding */ TileMap),
/* harmony export */   TileMapEvents: () => (/* binding */ TileMapEvents)
/* harmony export */ });
/* harmony import */ var _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1601779__(/*! ../Collision/BoundingBox */ "./Collision/BoundingBox.ts");
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1601779__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1601779__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1601779__(/*! ../EntityComponentSystem/Entity */ "./EntityComponentSystem/Entity.ts");
/* harmony import */ var _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1601779__(/*! ../EntityComponentSystem/Components/TransformComponent */ "./EntityComponentSystem/Components/TransformComponent.ts");
/* harmony import */ var _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1601779__(/*! ../Collision/BodyComponent */ "./Collision/BodyComponent.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1601779__(/*! ../Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Collision_Colliders_Shape__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_1601779__(/*! ../Collision/Colliders/Shape */ "./Collision/Colliders/Shape.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1601779__(/*! ../Graphics */ "./Graphics/GraphicsComponent.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_1601779__(/*! ../Graphics */ "./Graphics/ParallaxComponent.ts");
/* harmony import */ var _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1601779__(/*! ../EntityComponentSystem/Components/MotionComponent */ "./EntityComponentSystem/Components/MotionComponent.ts");
/* harmony import */ var _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1601779__(/*! ../Collision/ColliderComponent */ "./Collision/ColliderComponent.ts");
/* harmony import */ var _Graphics_DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1601779__(/*! ../Graphics/DebugGraphicsComponent */ "./Graphics/DebugGraphicsComponent.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_1601779__(/*! ../Events */ "./Events.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1601779__(/*! ../EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Math_coord_plane__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_1601779__(/*! ../Math/coord-plane */ "./Math/coord-plane.ts");
/* harmony import */ var _Math_util__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_1601779__(/*! ../Math/util */ "./Math/util.ts");
/* harmony import */ var _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1601779__(/*! ../Input/PointerComponent */ "./Input/PointerComponent.ts");
/* harmony import */ var _Input_PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1601779__(/*! ../Input/PointerEventsToObjectDispatcher */ "./Input/PointerEventsToObjectDispatcher.ts");


















const TileMapEvents = {
    PreUpdate: 'preupdate',
    PostUpdate: 'postupdate',
    PreDraw: 'predraw',
    PostDraw: 'postdraw',
    PointerUp: 'pointerup',
    PointerDown: 'pointerdown',
    PointerMove: 'pointermove',
    PointerCancel: 'pointercancel'
};
/**
 * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.
 *
 * TileMaps are useful for top down or side scrolling grid oriented games.
 */
class TileMap extends _EntityComponentSystem_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    flagTilesDirty() {
        for (let i = 0; i < this.tiles.length; i++) {
            if (this.tiles[i]) {
                this.tiles[i].flagDirty();
            }
        }
    }
    get x() {
        var _a;
        return (_a = this.transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this.transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent).pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this.transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.transform.pos = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this.transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this.transform) {
            this.transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        if (this.transform) {
            this.transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this.transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this.transform.scale = val;
        }
    }
    get pos() {
        return this.transform.pos;
    }
    set pos(val) {
        this.transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    /**
     * Width of the whole tile map in pixels
     */
    get width() {
        return this.tileWidth * this.columns * this.scale.x;
    }
    /**
     * Height of the whole tilemap in pixels
     */
    get height() {
        return this.tileHeight * this.rows * this.scale.y;
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        this.events.off(eventName, handler);
    }
    /**
     * @param options
     */
    constructor(options) {
        var _a, _b, _c;
        super([], options.name);
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
        this._token = 0;
        this.logger = _Util_Log__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance();
        this.tiles = [];
        this._rows = [];
        this._cols = [];
        this.renderFromTopOfGraphic = false;
        this.meshingLookBehind = 10;
        this._collidersDirty = true;
        this._oldRotation = 0;
        this._originalOffsets = new WeakMap();
        this.meshingLookBehind = (_a = options.meshingLookBehind) !== null && _a !== void 0 ? _a : this.meshingLookBehind;
        this.addComponent(new _EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent());
        this.addComponent(new _EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_5__.MotionComponent());
        this.addComponent(new _Collision_BodyComponent__WEBPACK_IMPORTED_MODULE_6__.BodyComponent({
            type: _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_7__.CollisionType.Fixed
        }));
        this.addComponent(new _Graphics__WEBPACK_IMPORTED_MODULE_8__.GraphicsComponent({
            onPostDraw: (ctx, elapsed) => this.draw(ctx, elapsed)
        }));
        this.addComponent(new _Graphics_DebugGraphicsComponent__WEBPACK_IMPORTED_MODULE_9__.DebugGraphicsComponent((ctx, debugFlags) => this.debug(ctx, debugFlags), false));
        this.addComponent(new _Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_10__.ColliderComponent());
        this.addComponent(new _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_11__.PointerComponent());
        this.pointer = this.get(_Input_PointerComponent__WEBPACK_IMPORTED_MODULE_11__.PointerComponent);
        this._graphics = this.get(_Graphics__WEBPACK_IMPORTED_MODULE_8__.GraphicsComponent);
        this.transform = this.get(_EntityComponentSystem_Components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__.TransformComponent);
        this._motion = this.get(_EntityComponentSystem_Components_MotionComponent__WEBPACK_IMPORTED_MODULE_5__.MotionComponent);
        this.collider = this.get(_Collision_ColliderComponent__WEBPACK_IMPORTED_MODULE_10__.ColliderComponent);
        this._composite = this.collider.useCompositeCollider([]);
        this.transform.pos = (_b = options.pos) !== null && _b !== void 0 ? _b : _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
        this._oldPos = this.transform.pos.clone();
        this._oldScale = this.transform.scale.clone();
        this.renderFromTopOfGraphic = (_c = options.renderFromTopOfGraphic) !== null && _c !== void 0 ? _c : this.renderFromTopOfGraphic;
        this.tileWidth = options.tileWidth;
        this.tileHeight = options.tileHeight;
        this.rows = options.rows;
        this.columns = options.columns;
        this._pointerEventDispatcher = new _Input_PointerEventsToObjectDispatcher__WEBPACK_IMPORTED_MODULE_12__.PointerEventsToObjectDispatcher();
        this.tiles = new Array(this.rows * this.columns);
        this._rows = new Array(this.rows);
        this._cols = new Array(this.columns);
        let currentCol = [];
        for (let i = 0; i < this.columns; i++) {
            for (let j = 0; j < this.rows; j++) {
                const tile = new Tile({
                    x: i,
                    y: j,
                    map: this
                });
                tile.map = this;
                this.tiles[i + j * this.columns] = tile;
                this._pointerEventDispatcher.addObject(tile, (vec) => {
                    // TODO handle geometry/graphics
                    return tile.bounds.contains(vec.worldPos);
                }, () => true);
                currentCol.push(tile);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(tile);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this._graphics.localBounds = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_13__.BoundingBox({
            left: 0,
            top: 0,
            right: this.columns * this.tileWidth * this.scale.x,
            bottom: this.rows * this.tileHeight * this.scale.y
        });
    }
    _initialize(engine) {
        super._initialize(engine);
        this._engine = engine;
    }
    _getOrSetColliderOriginalOffset(collider) {
        var _a;
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return (_a = this._originalOffsets.get(collider)) !== null && _a !== void 0 ? _a : _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this.collider.$colliderRemoved.notifyAll(this._composite);
        this._composite.clearColliders();
        const colliders = [];
        this._composite = this.collider.useCompositeCollider([]);
        let current = null;
        /**
         * Returns wether or not the 2 boxes share an edge and are the same height
         * @param prev
         * @param next
         * @returns true if they share and edge, false if not
         */
        const shareEdges = (prev, next) => {
            if (prev && next) {
                // same top/bottom
                return (prev.top === next.top &&
                    prev.bottom === next.bottom &&
                    // Shared right/left edge
                    prev.right === next.left);
            }
            return false;
        };
        /**
         * Potentially merges the current collider into a list of previous ones, mutating the list
         * If checkAndCombine returns true, the collider was successfully merged and should be thrown away
         * @param current current collider to test
         * @param colliders List of colliders to consider merging with
         * @param maxLookBack The amount of colliders to look back for combination
         * @returns false when no combination found, true when successfully combined
         */
        const checkAndCombine = (current, colliders, maxLookBack = this.meshingLookBehind) => {
            if (!current) {
                return false;
            }
            // walk backwards through the list of colliders and combine with the first that shares an edge
            for (let i = colliders.length - 1; i >= 0; i--) {
                if (maxLookBack-- < 0) {
                    // blunt the O(n^2) algorithm a bit
                    return false;
                }
                const prev = colliders[i];
                if (shareEdges(prev, current)) {
                    colliders[i] = prev.combine(current);
                    return true;
                }
            }
            return false;
        };
        // ? configurable bias perhaps, horizontal strips vs. vertical ones
        // Bad tile collider packing algorithm
        for (let i = 0; i < this.columns; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                const tile = this.tiles[i + j * this.columns];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    // Use custom collider otherwise bounding box
                    if (tile.getColliders().length > 0) {
                        // tile with custom collider interrupting the current run
                        for (const collider of tile.getColliders()) {
                            const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                            collider.offset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(tile.x * this.tileWidth * this.scale.x, tile.y * this.tileHeight * this.scale.y).add(originalOffset);
                            collider.owner = this;
                            this._composite.addCollider(collider);
                        }
                        //we push any current collider before nulling the current run
                        if (current && !checkAndCombine(current, colliders)) {
                            colliders.push(current);
                        }
                        current = null;
                        // Use the bounding box
                    }
                    else {
                        if (!current) {
                            // no current run, start one
                            current = tile.defaultGeometry;
                        }
                        else {
                            // combine with current run
                            current = current.combine(tile.defaultGeometry);
                        }
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    // End of run check and combine
                    if (current && !checkAndCombine(current, colliders)) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            // Eno of run check and combine
            if (current && !checkAndCombine(current, colliders)) {
                // else new collider if no combination
                colliders.push(current);
            }
            current = null;
        }
        for (const c of colliders) {
            const collider = _Collision_Colliders_Shape__WEBPACK_IMPORTED_MODULE_14__.Shape.Box(c.width, c.height, _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero, (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this.collider.update();
        // Notify that colliders have been updated
        this.collider.$colliderAdded.notifyAll(this._composite);
    }
    /**
     * Returns the {@apilink Tile} by index (row major order)
     *
     * Returns null if out of bounds
     */
    getTileByIndex(index) {
        var _a;
        return (_a = this.tiles[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Returns the {@apilink Tile} by its x and y integer coordinates
     *
     * Returns null if out of bounds
     *
     * For example, if I want the tile in fifth column (x), and second row (y):
     * `getTile(4, 1)` 0 based, so 0 is the first in row/column
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the {@apilink Tile} by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const { x, y } = this._getTileCoordinates(point);
        const tile = this.getTile(x, y);
        if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {
            return tile;
        }
        return null;
    }
    _getTileCoordinates(point) {
        // Convert to Tile Space point
        point = this.transform.applyInverse(point);
        const x = Math.floor(point.x / this.tileWidth);
        const y = Math.floor(point.y / this.tileHeight);
        return { x, y };
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    /**
     * Returns the on screen tiles for a tilemap, this will overshoot by a small amount because of the internal quad tree data structure.
     *
     * Useful if you need to perform specific logic on onscreen tiles
     */
    getOnScreenTiles() {
        let worldBounds = this._engine.screen.getWorldBounds();
        const maybeParallax = this.get(_Graphics__WEBPACK_IMPORTED_MODULE_15__.ParallaxComponent);
        if (maybeParallax && this.isInitialized) {
            let pos = this.pos;
            const oneMinusFactor = _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.One.sub(maybeParallax.parallaxFactor);
            const parallaxOffset = this._engine.currentScene.camera.pos.scale(oneMinusFactor);
            pos = pos.sub(parallaxOffset);
            // adjust world bounds by parallax factor
            worldBounds = worldBounds.translate(pos);
        }
        const bounds = this.transform.coordPlane === _Math_coord_plane__WEBPACK_IMPORTED_MODULE_16__.CoordPlane.Screen ? this._engine.screen.getScreenBounds() : worldBounds;
        const topLeft = this._getTileCoordinates(bounds.topLeft);
        const topRight = this._getTileCoordinates(bounds.topRight);
        const bottomRight = this._getTileCoordinates(bounds.bottomRight);
        const bottomLeft = this._getTileCoordinates(bounds.bottomLeft);
        const tileStartX = Math.min((0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(topLeft.x, 0, this.columns - 1), (0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(topRight.x, 0, this.columns - 1));
        const tileStartY = Math.min((0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(topLeft.y, 0, this.rows - 1), (0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(topRight.y, 0, this.rows - 1));
        const tileEndX = Math.max((0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(bottomRight.x, 0, this.columns - 1), (0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(bottomLeft.x, 0, this.columns - 1));
        const tileEndY = Math.max((0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(bottomRight.y, 0, this.rows - 1), (0,_Math_util__WEBPACK_IMPORTED_MODULE_17__.clamp)(bottomLeft.y, 0, this.rows - 1));
        const tiles = [];
        for (let x = tileStartX; x <= tileEndX; x++) {
            for (let y = tileStartY; y <= tileEndY; y++) {
                tiles.push(this.getTile(x, y));
            }
        }
        return tiles;
    }
    /**
     * @internal
     */
    _processPointerToObject(receiver) {
        this._pointerEventDispatcher.processPointerToObject(receiver, this.tiles);
    }
    /**
     * @internal
     */
    _dispatchPointerEvents(receiver) {
        this._pointerEventDispatcher.dispatchEvents(receiver, this.tiles);
    }
    update(engine, elapsed) {
        this._initialize(engine);
        this.onPreUpdate(engine, elapsed);
        this.emit('preupdate', new _Events__WEBPACK_IMPORTED_MODULE_18__.PreUpdateEvent(engine, elapsed, this));
        // Update colliders
        if (!this._oldPos.equals(this.pos) || this._oldRotation !== this.rotation || !this._oldScale.equals(this.scale)) {
            this.flagCollidersDirty();
            this.flagTilesDirty();
        }
        if (this._collidersDirty) {
            this._collidersDirty = false;
            this._updateColliders();
        }
        // Clear last frame's events
        this._pointerEventDispatcher.clear();
        this._token++;
        this.pos.clone(this._oldPos);
        this._oldRotation = this.rotation;
        this.scale.clone(this._oldScale);
        this.transform.pos = this.pos;
        this.onPostUpdate(engine, elapsed);
        this.emit('postupdate', new _Events__WEBPACK_IMPORTED_MODULE_18__.PostUpdateEvent(engine, elapsed, this));
    }
    /**
     * Draws the tile map to the screen. Called by the {@apilink Scene}.
     * @param ctx ExcaliburGraphicsContext
     * @param elapsed  The number of milliseconds since the last draw
     */
    draw(ctx, elapsed) {
        if (!this.isInitialized) {
            return;
        }
        this.emit('predraw', new _Events__WEBPACK_IMPORTED_MODULE_18__.PreDrawEvent(ctx, elapsed, this)); // TODO fix event
        let graphics, graphicsIndex, graphicsLen;
        const tiles = this.getOnScreenTiles();
        for (let i = 0; i < tiles.length; i++) {
            const tile = tiles[i];
            // get non-negative tile sprites
            const offsets = tile.getGraphicsOffsets();
            graphics = tile.getGraphics();
            for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                // draw sprite, warning if sprite doesn't exist
                const graphic = graphics[graphicsIndex];
                const offset = offsets[graphicsIndex];
                if (graphic) {
                    if ((0,_Graphics__WEBPACK_IMPORTED_MODULE_8__.hasGraphicsTick)(graphic)) {
                        graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, this._token);
                    }
                    const offsetY = this.renderFromTopOfGraphic ? 0 : graphic.height - this.tileHeight;
                    graphic.draw(ctx, tile.x * this.tileWidth + offset.x, tile.y * this.tileHeight - offsetY + offset.y);
                }
            }
        }
        this.emit('postdraw', new _Events__WEBPACK_IMPORTED_MODULE_18__.PostDrawEvent(ctx, elapsed, this));
    }
    debug(gfx, debugFlags) {
        const { showAll, showGrid, gridColor, gridWidth, showSolidBounds: showColliderBounds, solidBoundsColor: colliderBoundsColor, showColliderGeometry } = debugFlags.tilemap;
        const { geometryColor, geometryLineWidth, geometryPointSize } = debugFlags.collider;
        const width = this.tileWidth * this.columns * this.scale.x;
        const height = this.tileHeight * this.rows * this.scale.y;
        const pos = this.pos;
        if (showGrid || showAll) {
            for (let r = 0; r < this.rows + 1; r++) {
                const yOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(0, r * this.tileHeight * this.scale.y);
                gfx.drawLine(pos.add(yOffset), pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(width, yOffset.y)), gridColor, gridWidth);
            }
            for (let c = 0; c < this.columns + 1; c++) {
                const xOffset = (0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(c * this.tileWidth * this.scale.x, 0);
                gfx.drawLine(pos.add(xOffset), pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(xOffset.x, height)), gridColor, gridWidth);
            }
        }
        if (showAll || showColliderBounds || showColliderGeometry) {
            const colliders = this._composite.getColliders();
            gfx.save();
            gfx.translate(this.pos.x, this.pos.y);
            gfx.scale(this.scale.x, this.scale.y);
            for (const collider of colliders) {
                const bounds = collider.localBounds;
                const pos = collider.worldPos.sub(this.pos);
                if (showColliderBounds) {
                    gfx.drawRectangle(pos, bounds.width, bounds.height, colliderBoundsColor);
                }
            }
            gfx.restore();
            if (showColliderGeometry) {
                for (const collider of colliders) {
                    collider.debug(gfx, geometryColor, { lineWidth: geometryLineWidth, pointSize: geometryPointSize });
                }
            }
        }
        if (showAll || showColliderBounds) {
            gfx.save();
            gfx.z = 999;
            if (showColliderBounds) {
                for (let i = 0; i < this.tiles.length; i++) {
                    this.tiles[i].bounds.draw(gfx);
                }
            }
            gfx.restore();
        }
    }
}
/**
 * TileMap Tile
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a {@apilink TileMap}.
 *
 * Tiles can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Tile {
    /**
     * Return the world position of the top left corner of the tile
     */
    get pos() {
        if (this._posDirty) {
            this._recalculate();
            this._posDirty = false;
        }
        return this._pos;
    }
    /**
     * Width of the tile in pixels
     */
    get width() {
        return this._width;
    }
    /**
     * Height of the tile in pixels
     */
    get height() {
        return this._height;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagCollidersDirty();
        this._solid = val;
    }
    /**
     * Current list of graphics for this tile
     */
    getGraphics() {
        return this._graphics;
    }
    /**
     * Current list of offsets for this tile's graphics
     */
    getGraphicsOffsets() {
        return this._offsets;
    }
    /**
     * Add another {@apilink Graphic} to this TileMap tile
     * @param graphic
     */
    addGraphic(graphic, options) {
        this._graphics.push(graphic);
        if (options === null || options === void 0 ? void 0 : options.offset) {
            this._offsets.push(options.offset);
        }
        else {
            this._offsets.push(_Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero);
        }
    }
    /**
     * Remove an instance of a {@apilink Graphic} from this tile
     */
    removeGraphic(graphic) {
        const index = this._graphics.indexOf(graphic);
        if (index > -1) {
            this._graphics.splice(index, 1);
            this._offsets.splice(index, 1);
        }
    }
    /**
     * Clear all graphics from this tile
     */
    clearGraphics() {
        this._graphics.length = 0;
        this._offsets.length = 0;
    }
    /**
     * Returns the list of colliders
     */
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a custom collider to the {@apilink Tile} to use instead of it's bounds
     *
     * If no collider is set but {@apilink Tile.solid} is set, the tile bounds are used as a collider.
     *
     * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the {@apilink Tile}
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the {@apilink Tile}
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    constructor(options) {
        var _a, _b;
        this._posDirty = false;
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
        this._solid = false;
        this._graphics = [];
        this._offsets = [];
        /**
         * Current list of colliders for this tile
         */
        this._colliders = [];
        /**
         * Arbitrary data storage per tile, useful for any game specific data
         */
        this.data = new Map();
        this.x = options.x;
        this.y = options.y;
        this.map = options.map;
        this._width = options.map.tileWidth * this.map.scale.x;
        this._height = options.map.tileHeight * this.map.scale.y;
        this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;
        this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];
        this._recalculate();
    }
    flagDirty() {
        return (this._posDirty = true);
    }
    _recalculate() {
        const geometryPos = this.map.pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(this.x * this.map.tileWidth, this.y * this.map.tileHeight));
        this._geometry = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_13__.BoundingBox(geometryPos.x, geometryPos.y, geometryPos.x + this.map.tileWidth, geometryPos.y + this.map.tileHeight);
        this._width = this.map.tileWidth * this.map.scale.x;
        this._height = this.map.tileHeight * this.map.scale.y;
        this._pos = this.map.pos.add((0,_Math_vector__WEBPACK_IMPORTED_MODULE_2__.vec)(this.x * this._width, this.y * this._height));
        this._bounds = new _Collision_BoundingBox__WEBPACK_IMPORTED_MODULE_13__.BoundingBox(this._pos.x, this._pos.y, this._pos.x + this._width, this._pos.y + this._height);
        if (this.map.rotation) {
            this._bounds = this._bounds.rotate(this.map.rotation, this.map.pos);
        }
        this._posDirty = false;
    }
    /**
     * Tile bounds in world space
     */
    get bounds() {
        if (this._posDirty) {
            this._recalculate();
        }
        return this._bounds;
    }
    get defaultGeometry() {
        return this._geometry;
    }
    /**
     * Tile position in world space
     */
    get center() {
        if (this._posDirty) {
            this._recalculate();
        }
        return new _Math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector(this._pos.x + this._width / 2, this._pos.y + this._height / 2);
    }
    emit(eventName, event) {
        this.events.emit(eventName, event);
    }
    on(eventName, handler) {
        return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
        return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
        if (handler) {
            this.events.off(eventName, handler);
        }
        else {
            this.events.off(eventName);
        }
    }
}


/***/ }),

/***/ "./TileMap/index.ts":
/*!**************************!*\
  !*** ./TileMap/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1634680__) => {

__nested_webpack_require_1634680__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1634680__.d(__nested_webpack_exports__, {
/* harmony export */   IsometricEntityComponent: () => (/* reexport safe */ _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_2__.IsometricEntityComponent),
/* harmony export */   IsometricEntitySystem: () => (/* reexport safe */ _IsometricEntitySystem__WEBPACK_IMPORTED_MODULE_3__.IsometricEntitySystem),
/* harmony export */   IsometricMap: () => (/* reexport safe */ _IsometricMap__WEBPACK_IMPORTED_MODULE_1__.IsometricMap),
/* harmony export */   IsometricTile: () => (/* reexport safe */ _IsometricMap__WEBPACK_IMPORTED_MODULE_1__.IsometricTile),
/* harmony export */   Tile: () => (/* reexport safe */ _TileMap__WEBPACK_IMPORTED_MODULE_0__.Tile),
/* harmony export */   TileMap: () => (/* reexport safe */ _TileMap__WEBPACK_IMPORTED_MODULE_0__.TileMap),
/* harmony export */   TileMapEvents: () => (/* reexport safe */ _TileMap__WEBPACK_IMPORTED_MODULE_0__.TileMapEvents)
/* harmony export */ });
/* harmony import */ var _TileMap__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1634680__(/*! ./TileMap */ "./TileMap/TileMap.ts");
/* harmony import */ var _IsometricMap__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1634680__(/*! ./IsometricMap */ "./TileMap/IsometricMap.ts");
/* harmony import */ var _IsometricEntityComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1634680__(/*! ./IsometricEntityComponent */ "./TileMap/IsometricEntityComponent.ts");
/* harmony import */ var _IsometricEntitySystem__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1634680__(/*! ./IsometricEntitySystem */ "./TileMap/IsometricEntitySystem.ts");






/***/ }),

/***/ "./Timer.ts":
/*!******************!*\
  !*** ./Timer.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1636499__) => {

__nested_webpack_require_1636499__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1636499__.d(__nested_webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1636499__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Math_Random__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1636499__(/*! ./Math/Random */ "./Math/Random.ts");


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    get complete() {
        return this._complete;
    }
    constructor(options) {
        var _a;
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this.randomRange = [0, 0];
        this._baseInterval = 10;
        this._generateRandomInterval = () => {
            return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);
        };
        this._complete = false;
        this.scene = null;
        const fcn = (_a = options.action) !== null && _a !== void 0 ? _a : options.fcn;
        const interval = options.interval;
        const repeats = options.repeats;
        const numberOfRepeats = options.numberOfRepeats;
        const randomRange = options.randomRange;
        const random = options.random;
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this._callbacks = [];
        this._baseInterval = this.interval = interval;
        if (!!randomRange) {
            if (randomRange[0] > randomRange[1]) {
                throw new Error('min value must be lower than max value for range');
            }
            //We use the instance of ex.Random to generate the range
            this.random = random !== null && random !== void 0 ? random : new _Math_Random__WEBPACK_IMPORTED_MODULE_1__.Random();
            this.randomRange = randomRange;
            this.interval = this._generateRandomInterval();
            this.on(() => {
                this.interval = this._generateRandomInterval();
            });
        }
        this.repeats = repeats || this.repeats;
        if (fcn) {
            this.on(fcn);
        }
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param action The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(action) {
        this._callbacks.push(action);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param action The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(action) {
        const index = this._callbacks.indexOf(action);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param elapsed  Number of elapsed milliseconds since the last update.
     */
    update(elapsed) {
        if (this._running) {
            this._totalTimeAlive += elapsed;
            this._elapsedTime += elapsed;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this._baseInterval = this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;


/***/ }),

/***/ "./Trigger.ts":
/*!********************!*\
  !*** ./Trigger.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1643965__) => {

__nested_webpack_require_1643965__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1643965__.d(__nested_webpack_exports__, {
/* harmony export */   Trigger: () => (/* binding */ Trigger),
/* harmony export */   TriggerEvents: () => (/* binding */ TriggerEvents)
/* harmony export */ });
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1643965__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1643965__(/*! ./Collision/CollisionType */ "./Collision/CollisionType.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1643965__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1643965__(/*! ./EventEmitter */ "./EventEmitter.ts");




const TriggerEvents = {
    ExitTrigger: 'exit',
    EnterTrigger: 'enter'
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when {@apilink Trigger.visible} is set to `true`.
 */
class Trigger extends _Actor__WEBPACK_IMPORTED_MODULE_0__.Actor {
    /**
     * @param options Trigger options
     */
    constructor(options) {
        var _a, _b, _c, _d;
        super({ ...options });
        this.events = new _EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.filter = (_a = options.filter) !== null && _a !== void 0 ? _a : (() => true);
        this.repeat = (_b = options.repeat) !== null && _b !== void 0 ? _b : -1;
        this.action = (_c = options.action) !== null && _c !== void 0 ? _c : (() => undefined);
        this.target = options.target;
        this.graphics.isVisible = (_d = options.visible) !== null && _d !== void 0 ? _d : false;
        this.body.collisionType = _Collision_CollisionType__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Passive;
        this.events.on('collisionstart', ({ other: collider }) => {
            if (!this._matchesTarget(collider.owner)) {
                return;
            }
            this.events.emit('enter', new _Events__WEBPACK_IMPORTED_MODULE_3__.EnterTriggerEvent(this, collider.owner));
            this._dispatchAction(collider.owner);
            // remove trigger if its done, -1 repeat forever
            if (this.repeat === 0) {
                this.kill();
            }
        });
        this.events.on('collisionend', ({ other: collider }) => {
            if (this._matchesTarget(collider.owner)) {
                this.events.emit('exit', new _Events__WEBPACK_IMPORTED_MODULE_3__.ExitTriggerEvent(this, collider.owner));
            }
        });
    }
    _matchesTarget(entity) {
        return this.filter(entity) && (this.target === undefined || this.target === entity);
    }
    _dispatchAction(target) {
        if (this.repeat !== 0) {
            this.action.call(this, target);
            this.repeat--;
        }
    }
}


/***/ }),

/***/ "./Util/Assert.ts":
/*!************************!*\
  !*** ./Util/Assert.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1647165__) => {

__nested_webpack_require_1647165__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1647165__.d(__nested_webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
/**
 * Asserts will throw in `process.env.NODE_ENV === 'development'` builds if the expression evaluates false
 */
function assert(message, expression) {
    if (true) {
        if (!expression()) {
            throw new Error(message);
        }
    }
}


/***/ }),

/***/ "./Util/Browser.ts":
/*!*************************!*\
  !*** ./Util/Browser.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1647828__) => {

__nested_webpack_require_1647828__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1647828__.d(__nested_webpack_exports__, {
/* harmony export */   BrowserComponent: () => (/* binding */ BrowserComponent),
/* harmony export */   BrowserEvents: () => (/* binding */ BrowserEvents)
/* harmony export */ });
class BrowserComponent {
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}


/***/ }),

/***/ "./Util/Clock.ts":
/*!***********************!*\
  !*** ./Util/Clock.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1650116__) => {

__nested_webpack_require_1650116__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1650116__.d(__nested_webpack_exports__, {
/* harmony export */   Clock: () => (/* binding */ Clock),
/* harmony export */   StandardClock: () => (/* binding */ StandardClock),
/* harmony export */   TestClock: () => (/* binding */ TestClock)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1650116__(/*! ../Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Fps__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1650116__(/*! ./Fps */ "./Util/Fps.ts");


/**
 * Abstract Clock is the base type of all Clocks
 *
 * It has a few opinions
 * 1. It manages the calculation of what "elapsed" time means and thus maximum fps
 * 2. The default timing api is implemented in now()
 *
 * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever
 * method is unique to your clock implementation.
 */
class Clock {
    constructor(options) {
        var _a, _b, _c;
        this._onFatalException = () => {
            /* default nothing */
        };
        this._maxFps = Infinity;
        this._lastTime = 0;
        this._elapsed = 1;
        this._scheduledCbs = [];
        this._totalElapsed = 0;
        this._options = options;
        this.tick = options.tick;
        this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;
        this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;
        this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;
        this.fpsSampler = new _Fps__WEBPACK_IMPORTED_MODULE_0__.FpsSampler({
            initialFps: 60,
            nowFn: () => this.now()
        });
    }
    /**
     * Get the elapsed time for the last completed frame
     */
    elapsed() {
        return this._elapsed;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        return performance.now();
    }
    toTestClock() {
        const testClock = new TestClock({
            ...this._options,
            defaultUpdateMs: 16.6
        });
        return testClock;
    }
    toStandardClock() {
        const clock = new StandardClock({
            ...this._options
        });
        return clock;
    }
    setFatalExceptionHandler(handler) {
        this._onFatalException = handler;
    }
    /**
     * Schedule a callback to fire given a timeout in milliseconds using the excalibur {@apilink Clock}
     *
     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
     * stopped or paused.
     * @param cb callback to fire
     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
     * @param timing Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
     */
    schedule(cb, timeoutMs = 0, timing = 'preframe') {
        // Scheduled based on internal elapsed time
        const scheduledTime = this._totalElapsed + timeoutMs;
        this._scheduledCbs.push([cb, scheduledTime, timing]);
    }
    /**
     * Called internally to trigger scheduled callbacks in the clock
     * @param timing
     * @internal
     */
    __runScheduledCbs(timing = 'preframe') {
        // walk backwards to delete items as we loop
        for (let i = this._scheduledCbs.length - 1; i > -1; i--) {
            if (timing === this._scheduledCbs[i][2] && this._scheduledCbs[i][1] <= this._totalElapsed) {
                this._scheduledCbs[i][0](this._elapsed);
                this._scheduledCbs.splice(i, 1);
            }
        }
    }
    update(overrideUpdateMs) {
        try {
            this.fpsSampler.start();
            // Get the time to calculate time-elapsed
            const now = this.now();
            let elapsed = now - this._lastTime || 1; // first frame
            // Constrain fps
            const fpsInterval = 1000 / this._maxFps;
            // only run frame if enough time has elapsed
            if (elapsed >= fpsInterval) {
                let leftover = 0;
                if (fpsInterval !== 0) {
                    leftover = elapsed % fpsInterval;
                    elapsed = elapsed - leftover; // shift elapsed to be "in phase" with the current loop fps
                }
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                // tick the mainloop and run scheduled callbacks
                this._elapsed = overrideUpdateMs || elapsed;
                this._totalElapsed += this._elapsed;
                this.__runScheduledCbs('preframe');
                this.tick(overrideUpdateMs || elapsed);
                this.__runScheduledCbs('postframe');
                if (fpsInterval !== 0) {
                    this._lastTime = now - leftover;
                }
                else {
                    this._lastTime = now;
                }
                this.fpsSampler.end();
            }
        }
        catch (e) {
            this._onFatalException(e);
            this.stop();
        }
    }
}
/**
 * The {@apilink StandardClock} implements the requestAnimationFrame browser api to run the tick()
 */
class StandardClock extends Clock {
    constructor(options) {
        super(options);
        this._running = false;
    }
    isRunning() {
        return this._running;
    }
    start() {
        if (this._running) {
            return;
        }
        this._running = true;
        const mainloop = () => {
            // stop the loop
            if (!this._running) {
                return;
            }
            try {
                // request next loop
                this._requestId = window.requestAnimationFrame(mainloop);
                this.update();
            }
            catch (e) {
                window.cancelAnimationFrame(this._requestId);
                throw e;
            }
        };
        // begin the first frame
        mainloop();
    }
    stop() {
        window.cancelAnimationFrame(this._requestId);
        this._running = false;
    }
}
/**
 * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test
 */
class TestClock extends Clock {
    constructor(options) {
        super({
            ...options
        });
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
        this._running = false;
        this._currentTime = 0;
        this._updateMs = options.defaultUpdateMs;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        var _a;
        return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    isRunning() {
        return this._running;
    }
    start() {
        this._running = true;
    }
    stop() {
        this._running = false;
    }
    /**
     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
     * @param overrideUpdateMs
     */
    step(overrideUpdateMs) {
        const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;
        if (this._running) {
            // to be comparable to RAF this needs to be a full blown Task
            // For example, images cannot decode synchronously in a single step
            this.update(time);
            this._currentTime += time;
        }
        else {
            this._logger.warn('The clock is not running, no step will be performed');
        }
    }
    /**
     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
     * @param numberOfSteps
     * @param overrideUpdateMs
     */
    run(numberOfSteps, overrideUpdateMs) {
        for (let i = 0; i < numberOfSteps; i++) {
            this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);
        }
    }
}


/***/ }),

/***/ "./Util/Coroutine.ts":
/*!***************************!*\
  !*** ./Util/Coroutine.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1658778__) => {

__nested_webpack_require_1658778__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1658778__.d(__nested_webpack_exports__, {
/* harmony export */   coroutine: () => (/* binding */ coroutine)
/* harmony export */ });
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1658778__(/*! ../Context */ "./Context.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1658778__(/*! ../Engine */ "./Engine.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1658778__(/*! ./Log */ "./Util/Log.ts");



const InsideCoroutineContext = (0,_Context__WEBPACK_IMPORTED_MODULE_0__.createContext)();
const generatorFunctionDeclaration = /^\s*(?:function)?\*/;
/**
 *
 */
function isCoroutineGenerator(x) {
    if (typeof x !== 'function') {
        return false;
    }
    if (generatorFunctionDeclaration.test(Function.prototype.toString.call(x))) {
        return true;
    }
    if (!Object.getPrototypeOf) {
        return false;
    }
    return Object.getPrototypeOf(x) === Object.getPrototypeOf(new Function('return function * () {}')());
}
/**
 *
 */
function coroutine(...args) {
    var _a;
    const logger = _Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance();
    let coroutineGenerator;
    let thisArg;
    let options;
    let passedEngine;
    // coroutine(coroutineGenerator: CoroutineGenerator, options?: CoroutineOptions): CoroutineInstance;
    if (isCoroutineGenerator(args[0])) {
        thisArg = globalThis;
        coroutineGenerator = args[0];
        options = args[1];
    }
    // coroutine(thisArg: any, coroutineGenerator: CoroutineGenerator, options?: CoroutineOptions): CoroutineInstance;
    if (isCoroutineGenerator(args[1])) {
        thisArg = args[0];
        coroutineGenerator = args[1];
        options = args[2];
    }
    // coroutine(thisArg: any, engine: Engine, coroutineGenerator: CoroutineGenerator, options?: CoroutineOptions): CoroutineInstance;
    if (args[1] instanceof _Engine__WEBPACK_IMPORTED_MODULE_2__.Engine) {
        thisArg = args[0];
        passedEngine = args[1];
        coroutineGenerator = args[2];
        options = args[3];
    }
    // coroutine(engine: Engine, coroutineGenerator: CoroutineGenerator, options?: CoroutineOptions): CoroutineInstance;
    if (args[0] instanceof _Engine__WEBPACK_IMPORTED_MODULE_2__.Engine) {
        thisArg = globalThis;
        passedEngine = args[0];
        coroutineGenerator = args[1];
        options = args[2];
    }
    const inside = (0,_Context__WEBPACK_IMPORTED_MODULE_0__.useContext)(InsideCoroutineContext);
    const schedule = options === null || options === void 0 ? void 0 : options.timing;
    const autostart = inside ? false : (_a = options === null || options === void 0 ? void 0 : options.autostart) !== null && _a !== void 0 ? _a : true;
    let engine;
    try {
        engine = passedEngine !== null && passedEngine !== void 0 ? passedEngine : _Engine__WEBPACK_IMPORTED_MODULE_2__.Engine.useEngine();
    }
    catch (_) {
        throw Error('Cannot run coroutine without engine parameter outside of an excalibur lifecycle method.\n' +
            'Pass an engine parameter to ex.coroutine(engine, function * {...})');
    }
    let started = false;
    let completed = false;
    let cancelled = false;
    const generatorFcn = coroutineGenerator.bind(thisArg);
    const generator = generatorFcn();
    let loop;
    const complete = new Promise((resolve, reject) => {
        loop = (elapsed) => {
            try {
                if (cancelled) {
                    completed = true;
                    resolve();
                    return;
                }
                const { done, value } = InsideCoroutineContext.scope(true, () => generator.next(elapsed));
                if (done || cancelled) {
                    completed = true;
                    resolve();
                    return;
                }
                if (value instanceof Promise) {
                    value.then(() => {
                        // schedule next loop
                        engine.clock.schedule(loop, 0, schedule);
                    });
                }
                else if (value === undefined || value === void 0) {
                    // schedule next frame
                    engine.clock.schedule(loop, 0, schedule);
                }
                else {
                    // schedule value milliseconds from now
                    engine.clock.schedule(loop, value || 0, schedule);
                }
            }
            catch (e) {
                reject(e);
                return;
            }
        };
        if (autostart) {
            started = true;
            loop(engine.clock.elapsed()); // run first frame immediately
        }
    });
    const co = {
        isRunning: () => {
            return started && !cancelled && !completed;
        },
        isComplete: () => {
            return completed;
        },
        cancel: () => {
            cancelled = true;
        },
        start: () => {
            if (!started) {
                started = true;
                loop(engine.clock.elapsed());
            }
            else {
                logger.warn('.start() was called on a coroutine that was already started, this is probably a bug:\n', Function.prototype.toString.call(generatorFcn));
            }
            return co;
        },
        generator,
        done: complete,
        then: complete.then.bind(complete),
        [Symbol.iterator]: () => {
            // TODO warn if a coroutine is already running
            // TODO warn if a coroutine is cancelled
            return generator;
        }
    };
    return co;
}


/***/ }),

/***/ "./Util/Decorators.ts":
/*!****************************!*\
  !*** ./Util/Decorators.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1664693__) => {

__nested_webpack_require_1664693__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1664693__.d(__nested_webpack_exports__, {
/* harmony export */   maxMessages: () => (/* binding */ maxMessages),
/* harmony export */   obsolete: () => (/* binding */ obsolete),
/* harmony export */   resetObsoleteCounter: () => (/* binding */ resetObsoleteCounter)
/* harmony export */ });
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1664693__(/*! ../Flags */ "./Flags.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1664693__(/*! ./Log */ "./Util/Log.ts");


const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = _Flags__WEBPACK_IMPORTED_MODULE_0__.Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        _Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrace: false,
        ...options
    };
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? { ...descriptor } : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}


/***/ }),

/***/ "./Util/Detector.ts":
/*!**************************!*\
  !*** ./Util/Detector.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1668576__) => {

__nested_webpack_require_1668576__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1668576__.d(__nested_webpack_exports__, {
/* harmony export */   Detector: () => (/* binding */ Detector)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1668576__(/*! ./Log */ "./Util/Log.ts");

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // (✓)
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // (✗)
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                _Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                _Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}


/***/ }),

/***/ "./Util/DrawUtil.ts":
/*!**************************!*\
  !*** ./Util/DrawUtil.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1675536__) => {

__nested_webpack_require_1675536__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1675536__.d(__nested_webpack_exports__, {
/* harmony export */   circle: () => (/* binding */ circle),
/* harmony export */   line: () => (/* binding */ line),
/* harmony export */   point: () => (/* binding */ point),
/* harmony export */   roundRect: () => (/* binding */ roundRect),
/* harmony export */   vector: () => (/* binding */ vector)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1675536__(/*! ../Color */ "./Color.ts");

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The {@apilink LineCapStyle} (butt, round, or square)
 */
function line(ctx, color = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The {@apilink Color} to stroke rectangle with
 * @param fill The {@apilink Color} to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}


/***/ }),

/***/ "./Util/EasingFunctions.ts":
/*!*********************************!*\
  !*** ./Util/EasingFunctions.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1679844__) => {

__nested_webpack_require_1679844__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1679844__.d(__nested_webpack_exports__, {
/* harmony export */   EasingFunctions: () => (/* binding */ EasingFunctions)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1679844__(/*! ../Math/vector */ "./Math/vector.ts");

/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});


/***/ }),

/***/ "./Util/Fps.ts":
/*!*********************!*\
  !*** ./Util/Fps.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1684213__) => {

__nested_webpack_require_1684213__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1684213__.d(__nested_webpack_exports__, {
/* harmony export */   FpsSampler: () => (/* binding */ FpsSampler)
/* harmony export */ });
class FpsSampler {
    constructor(options) {
        var _a;
        this._samplePeriod = 100;
        this._currentFrameTime = 0;
        this._frames = 0;
        this._previousSampleTime = 0;
        this._beginFrameTime = 0;
        this._fps = options.initialFps;
        this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;
        this._currentFrameTime = 1000 / options.initialFps;
        this._nowFn = options.nowFn;
        this._previousSampleTime = this._nowFn();
    }
    /**
     * Start of code block to sample FPS for
     */
    start() {
        this._beginFrameTime = this._nowFn();
    }
    /**
     * End of code block to sample FPS for
     */
    end() {
        this._frames++;
        const time = this._nowFn();
        this._currentFrameTime = time - this._beginFrameTime;
        if (time >= this._previousSampleTime + this._samplePeriod) {
            this._fps = (this._frames * 1000) / (time - this._previousSampleTime);
            this._previousSampleTime = time;
            this._frames = 0;
        }
    }
    /**
     * Return the currently sampled fps over the last sample period, by default every 100ms
     */
    get fps() {
        return this._fps;
    }
    /**
     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
     */
    get instant() {
        return 1000 / this._currentFrameTime;
    }
}


/***/ }),

/***/ "./Util/Future.ts":
/*!************************!*\
  !*** ./Util/Future.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1686084__) => {

__nested_webpack_require_1686084__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1686084__.d(__nested_webpack_exports__, {
/* harmony export */   Future: () => (/* binding */ Future)
/* harmony export */ });
/**
 * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time
 */
class Future {
    constructor() {
        this._isCompleted = false;
        this.promise = new Promise((resolve, reject) => {
            this._resolver = resolve;
            this._rejecter = reject;
        });
    }
    get isCompleted() {
        return this._isCompleted;
    }
    resolve(value) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._resolver(value);
    }
    reject(error) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._rejecter(error);
    }
}


/***/ }),

/***/ "./Util/IFrame.ts":
/*!************************!*\
  !*** ./Util/IFrame.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1687188__) => {

__nested_webpack_require_1687188__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1687188__.d(__nested_webpack_exports__, {
/* harmony export */   isCrossOriginIframe: () => (/* binding */ isCrossOriginIframe)
/* harmony export */ });
/**
 * Checks if excalibur is in a x-origin iframe
 */
function isCrossOriginIframe() {
    try {
        // Try and listen to events on top window frame if within an iframe.
        //
        // See https://github.com/excaliburjs/Excalibur/issues/1294
        //
        // Attempt to add an event listener, which triggers a DOMException on
        // cross-origin iframes
        const noop = () => {
            return;
        };
        window.top.addEventListener('blur', noop);
        window.top.removeEventListener('blur', noop);
    }
    catch (_a) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./Util/Index.ts":
/*!***********************!*\
  !*** ./Util/Index.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1688224__) => {

__nested_webpack_require_1688224__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1688224__.d(__nested_webpack_exports__, {
/* harmony export */   ConsoleAppender: () => (/* reexport safe */ _Log__WEBPACK_IMPORTED_MODULE_1__.ConsoleAppender),
/* harmony export */   DrawUtil: () => (/* reexport module object */ _DrawUtil__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   EasingFunctions: () => (/* reexport safe */ _EasingFunctions__WEBPACK_IMPORTED_MODULE_3__.EasingFunctions),
/* harmony export */   LogLevel: () => (/* reexport safe */ _Log__WEBPACK_IMPORTED_MODULE_1__.LogLevel),
/* harmony export */   Logger: () => (/* reexport safe */ _Log__WEBPACK_IMPORTED_MODULE_1__.Logger),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable),
/* harmony export */   ScreenAppender: () => (/* reexport safe */ _Log__WEBPACK_IMPORTED_MODULE_1__.ScreenAppender),
/* harmony export */   addItemToArray: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.addItemToArray),
/* harmony export */   contains: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.contains),
/* harmony export */   delay: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.delay),
/* harmony export */   fail: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.fail),
/* harmony export */   getPosition: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.getPosition),
/* harmony export */   isObject: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.isObject),
/* harmony export */   mergeDeep: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.mergeDeep),
/* harmony export */   omit: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.omit),
/* harmony export */   removeItemFromArray: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.removeItemFromArray)
/* harmony export */ });
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1688224__(/*! ./Util */ "./Util/Util.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1688224__(/*! ./Log */ "./Util/Log.ts");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1688224__(/*! ./Observable */ "./Util/Observable.ts");
/* harmony import */ var _EasingFunctions__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1688224__(/*! ./EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _DrawUtil__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1688224__(/*! ./DrawUtil */ "./Util/DrawUtil.ts");








/***/ }),

/***/ "./Util/Log.ts":
/*!*********************!*\
  !*** ./Util/Log.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1690969__) => {

__nested_webpack_require_1690969__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1690969__.d(__nested_webpack_exports__, {
/* harmony export */   ConsoleAppender: () => (/* binding */ ConsoleAppender),
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   ScreenAppender: () => (/* binding */ ScreenAppender)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1690969__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1690969__(/*! ../Color */ "./Color.ts");
/* eslint-disable no-console */


/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a {@apilink ConsoleAppender} and {@apilink ScreenAppender}.
 * Derive from {@apilink Appender} to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: {@apilink LogLevel.Info}
         */
        this.defaultLevel = LogLevel.Info;
        this._logOnceSet = new Set();
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new {@apilink Appender} to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    _logOnce(level, args) {
        const serialized = level + args.join('+');
        if (this._logOnceSet.has(serialized)) {
            return;
        }
        else {
            this._logOnceSet.add(serialized);
            this._log(level, args);
        }
    }
    /**
     * Writes a log message at the {@apilink LogLevel.Debug} level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it wont log
     * @param args  Accepts any number of arguments
     */
    debugOnce(...args) {
        this._logOnce(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the {@apilink LogLevel.Info} level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message once at the {@apilink LogLevel.Info} level, if it sees the same args again it wont log
     * @param args  Accepts any number of arguments
     */
    infoOnce(...args) {
        this._logOnce(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the {@apilink LogLevel.Warn} level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message once at the {@apilink LogLevel.Warn} level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    warnOnce(...args) {
        this._logOnce(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the {@apilink LogLevel.Error} level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message once at the {@apilink LogLevel.Error} level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    errorOnce(...args) {
        this._logOnce(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the {@apilink LogLevel.Fatal} level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
    /**
     * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it won't log
     * @param args  Accepts any number of arguments
     */
    fatalOnce(...args) {
        this._logOnce(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given {@apilink LogLevel}
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    constructor(options) {
        var _a, _b;
        this._messages = [];
        this._pos = 10;
        this._color = _Color__WEBPACK_IMPORTED_MODULE_0__.Color.Black;
        this._options = options;
        this.canvas = document.createElement('canvas');
        this._ctx = this.canvas.getContext('2d');
        this.canvas.style.position = 'absolute';
        this.canvas.style.zIndex = (_b = (_a = options.zIndex) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '99';
        document.body.appendChild(this.canvas);
        this._positionScreenAppenderCanvas();
        options.engine.screen.events.on('resize', () => {
            this._positionScreenAppenderCanvas();
        });
    }
    _positionScreenAppenderCanvas() {
        var _a, _b, _c, _d;
        const options = this._options;
        this.canvas.width = (_a = options.width) !== null && _a !== void 0 ? _a : options.engine.screen.resolution.width;
        this.canvas.height = (_b = options.height) !== null && _b !== void 0 ? _b : options.engine.screen.resolution.height;
        this.canvas.style.position = 'absolute';
        const pagePos = options.engine.screen.screenToPageCoordinates((0,_Math_vector__WEBPACK_IMPORTED_MODULE_1__.vec)(0, 0));
        this.canvas.style.left = pagePos.x + 'px';
        this.canvas.style.top = pagePos.y + 'px';
        this._pos = (_c = options.xPos) !== null && _c !== void 0 ? _c : this._pos;
        this._color = (_d = options.color) !== null && _d !== void 0 ? _d : this._color;
    }
    /**
     * Logs a message at the given {@apilink LogLevel}
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        this._messages = this._messages.slice(0, 1000);
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = this._color.toRGBA();
            this._ctx.fillText(this._messages[i], this._pos, pos);
            pos += 10;
        }
    }
}


/***/ }),

/***/ "./Util/Observable.ts":
/*!****************************!*\
  !*** ./Util/Observable.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1700545__) => {

__nested_webpack_require_1700545__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1700545__.d(__nested_webpack_exports__, {
/* harmony export */   Observable: () => (/* binding */ Observable)
/* harmony export */ });
/**
 * Simple Observable implementation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        const observersLength = this.observers.length;
        for (let i = 0; i < observersLength; i++) {
            this.observers[i].notify(message);
        }
        const subscriptionsLength = this.subscriptions.length;
        for (let i = 0; i < subscriptionsLength; i++) {
            this.subscriptions[i](message);
        }
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}


/***/ }),

/***/ "./Util/Pool.ts":
/*!**********************!*\
  !*** ./Util/Pool.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1702622__) => {

__nested_webpack_require_1702622__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1702622__.d(__nested_webpack_exports__, {
/* harmony export */   Pool: () => (/* binding */ Pool)
/* harmony export */ });
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1702622__(/*! ../Util/Log */ "./Util/Log.ts");

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this.disableWarnings = false;
        this._logger = _Util_Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance();
    }
    dispose() {
        this.objects.length = 0;
    }
    preallocate() {
        for (let i = 0; i < this.maxObjects; i++) {
            this.objects[i] = this.builder();
        }
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     */
    get() {
        if (this.index === this.maxObjects) {
            if (!this.disableWarnings) {
                this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            }
            this.maxObjects = this.maxObjects * 2;
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            if (this.recycler) {
                return this.recycler(this.objects[this.index++]);
            }
            return this.objects[this.index++];
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder());
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder();
            this.totalAllocations++;
        }
        return objects;
    }
}


/***/ }),

/***/ "./Util/RentalPool.ts":
/*!****************************!*\
  !*** ./Util/RentalPool.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1705636__) => {

__nested_webpack_require_1705636__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1705636__.d(__nested_webpack_exports__, {
/* harmony export */   RentalPool: () => (/* binding */ RentalPool)
/* harmony export */ });
class RentalPool {
    constructor(builder, cleaner, preAllocate = 1) {
        this.builder = builder;
        this.cleaner = cleaner;
        this._pool = [];
        this._size = 0;
        this.grow(preAllocate);
    }
    /**
     * Grow the pool size by an amount
     * @param amount
     */
    grow(amount) {
        if (amount > 0) {
            this._size += amount;
            for (let i = 0; i < amount; i++) {
                this._pool.push(this.builder());
            }
        }
    }
    /**
     * Rent an object from the pool, optionally clean it. If not cleaned previous state may be set.
     *
     * The pool will automatically double if depleted
     * @param clean
     */
    rent(clean = false) {
        if (this._pool.length === 0) {
            this.grow(this._size);
        }
        return clean ? this.cleaner(this._pool.pop()) : this._pool.pop();
    }
    /**
     * Return an object to the pool
     * @param object
     */
    return(object) {
        this._pool.push(object);
    }
}


/***/ }),

/***/ "./Util/Semaphore.ts":
/*!***************************!*\
  !*** ./Util/Semaphore.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1707086__) => {

__nested_webpack_require_1707086__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1707086__.d(__nested_webpack_exports__, {
/* harmony export */   Semaphore: () => (/* binding */ Semaphore)
/* harmony export */ });
/* harmony import */ var _Future__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1707086__(/*! ./Future */ "./Util/Future.ts");

class AsyncWaitQueue {
    constructor() {
        // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e
        this._queue = [];
    }
    get length() {
        return this._queue.length;
    }
    enqueue() {
        const future = new _Future__WEBPACK_IMPORTED_MODULE_0__.Future();
        this._queue.push(future);
        return future.promise;
    }
    dequeue(value) {
        const future = this._queue.shift();
        future.resolve(value);
    }
}
/**
 * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`
 *
 * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work
 * around browser limitations like max Image.decode() calls in chromium being 256.
 */
class Semaphore {
    constructor(_count) {
        this._count = _count;
        this._waitQueue = new AsyncWaitQueue();
    }
    get count() {
        return this._count;
    }
    get waiting() {
        return this._waitQueue.length;
    }
    // eslint-disable-next-line require-await
    async enter() {
        if (this._count !== 0) {
            this._count--;
            return Promise.resolve();
        }
        return this._waitQueue.enqueue();
    }
    exit(count = 1) {
        if (count === 0) {
            return;
        }
        while (count !== 0 && this._waitQueue.length !== 0) {
            this._waitQueue.dequeue(null);
            count--;
        }
        this._count += count;
    }
}


/***/ }),

/***/ "./Util/Sound.ts":
/*!***********************!*\
  !*** ./Util/Sound.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1709153__) => {

__nested_webpack_require_1709153__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1709153__.d(__nested_webpack_exports__, {
/* harmony export */   canPlayFile: () => (/* binding */ canPlayFile)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1709153__(/*! ./Log */ "./Util/Log.ts");

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)(?:(?:\?|\#).*)*$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        _Log__WEBPACK_IMPORTED_MODULE_0__.Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}


/***/ }),

/***/ "./Util/StateMachine.ts":
/*!******************************!*\
  !*** ./Util/StateMachine.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1710285__) => {

__nested_webpack_require_1710285__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1710285__.d(__nested_webpack_exports__, {
/* harmony export */   StateMachine: () => (/* binding */ StateMachine)
/* harmony export */ });
class StateMachine {
    constructor() {
        this.states = new Map();
    }
    get currentState() {
        return this._currentState;
    }
    set currentState(state) {
        this._currentState = state;
    }
    static create(machineDescription, data) {
        const machine = new StateMachine();
        machine.data = data;
        for (const stateName in machineDescription.states) {
            machine.states.set(stateName, {
                name: stateName,
                ...machineDescription.states[stateName]
            });
        }
        // validate transitions are states
        for (const state of machine.states.values()) {
            for (const transitionState of state.transitions) {
                if (transitionState === '*') {
                    continue;
                }
                if (!machine.states.has(transitionState)) {
                    throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);
                }
            }
        }
        machine.currentState = machine.startState = machine.states.get(machineDescription.start);
        return machine;
    }
    in(state) {
        return this.currentState.name === state;
    }
    go(stateName, eventData) {
        var _a, _b;
        if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {
            const potentialNewState = this.states.get(stateName);
            if (this.currentState.onExit) {
                const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });
                if (canExit === false) {
                    return false;
                }
            }
            if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {
                const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });
                if (canEnter === false) {
                    return false;
                }
            }
            this.currentState = potentialNewState;
            if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) {
                this.currentState.onState();
            }
            return true;
        }
        return false;
    }
    update(elapsed) {
        if (this.currentState.onUpdate) {
            this.currentState.onUpdate(this.data, elapsed);
        }
    }
    save(saveKey) {
        localStorage.setItem(saveKey, JSON.stringify({
            currentState: this.currentState.name,
            data: this.data
        }));
    }
    restore(saveKey) {
        const state = JSON.parse(localStorage.getItem(saveKey));
        this.currentState = this.states.get(state.currentState);
        this.data = state.data;
    }
}


/***/ }),

/***/ "./Util/Toaster.ts":
/*!*************************!*\
  !*** ./Util/Toaster.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1713693__) => {

__nested_webpack_require_1713693__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1713693__.d(__nested_webpack_exports__, {
/* harmony export */   Toaster: () => (/* binding */ Toaster)
/* harmony export */ });
/* harmony import */ var _Toaster_css__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1713693__(/*! ./Toaster.css */ "./Util/Toaster.css");

/**
 * The Toaster is only meant to be called from inside Excalibur to display messages to players
 */
class Toaster {
    constructor() {
        this._toasterCss = _Toaster_css__WEBPACK_IMPORTED_MODULE_0__["default"].toString();
        this._isInitialized = false;
    }
    _initialize() {
        if (!this._isInitialized) {
            this._container = document.createElement('div');
            this._container.id = 'ex-toast-container';
            document.body.appendChild(this._container);
            this._isInitialized = true;
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._toasterCss;
            document.head.appendChild(this._styleBlock);
        }
    }
    dispose() {
        this._container.parentElement.removeChild(this._container);
        this._styleBlock.parentElement.removeChild(this._styleBlock);
        this._isInitialized = false;
    }
    _createFragment(message) {
        const toastMessage = document.createElement('span');
        toastMessage.innerText = message;
        return toastMessage;
    }
    /**
     * Display a toast message to a player
     * @param message Text of the message, messages may have a single "[LINK]" to influence placement
     * @param linkTarget Optionally specify a link location
     * @param linkName Optionally specify a name for that link location
     */
    toast(message, linkTarget, linkName) {
        this._initialize();
        const toast = document.createElement('div');
        toast.className = 'ex-toast-message';
        const messageFragments = message.split('[LINK]').map((message) => this._createFragment(message));
        if (linkTarget) {
            const link = document.createElement('a');
            link.href = linkTarget;
            if (linkName) {
                link.innerText = linkName;
            }
            else {
                link.innerText = linkTarget;
            }
            messageFragments.splice(1, 0, link);
        }
        // Assembly message
        const finalMessage = document.createElement('div');
        messageFragments.forEach((message) => {
            finalMessage.appendChild(message);
        });
        toast.appendChild(finalMessage);
        // Dismiss button
        const dismissBtn = document.createElement('button');
        dismissBtn.innerText = 'x';
        dismissBtn.addEventListener('click', () => {
            this._container.removeChild(toast);
        });
        toast.appendChild(dismissBtn);
        // Escape to dismiss
        const keydownHandler = (evt) => {
            if (evt.key === 'Escape') {
                try {
                    this._container.removeChild(toast);
                }
                catch (_a) {
                    // pass
                }
            }
            document.removeEventListener('keydown', keydownHandler);
        };
        document.addEventListener('keydown', keydownHandler);
        // Insert into container
        const first = this._container.firstChild;
        this._container.insertBefore(toast, first);
    }
}


/***/ }),

/***/ "./Util/Util.ts":
/*!**********************!*\
  !*** ./Util/Util.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1717330__) => {

__nested_webpack_require_1717330__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1717330__.d(__nested_webpack_exports__, {
/* harmony export */   addItemToArray: () => (/* binding */ addItemToArray),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   delay: () => (/* binding */ delay),
/* harmony export */   fail: () => (/* binding */ fail),
/* harmony export */   getPosition: () => (/* binding */ getPosition),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),
/* harmony export */   omit: () => (/* binding */ omit),
/* harmony export */   removeItemFromArray: () => (/* binding */ removeItemFromArray)
/* harmony export */ });
/* harmony import */ var _Math_vector__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1717330__(/*! ../Math/vector */ "./Math/vector.ts");
/* harmony import */ var _Future__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1717330__(/*! ./Future */ "./Util/Future.ts");


/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    // do we need the scroll too? technically the offset method before did that
    if (el && el.getBoundingClientRect) {
        const rect = el.getBoundingClientRect();
        return (0,_Math_vector__WEBPACK_IMPORTED_MODULE_0__.vec)(rect.x + window.scrollX, rect.y + window.scrollY);
    }
    return _Math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector.Zero;
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Create a promise that resolves after a certain number of milliseconds
 *
 * It is strongly recommended you pass the excalibur clock so delays are bound to the
 * excalibur clock which would be unaffected by stop/pause.
 * @param milliseconds
 * @param clock
 */
function delay(milliseconds, clock) {
    var _a;
    const future = new _Future__WEBPACK_IMPORTED_MODULE_1__.Future();
    const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;
    schedule(() => {
        future.resolve();
    }, milliseconds);
    return future.promise;
}
/**
 * Remove keys from object literals
 * @param object
 * @param keys
 */
function omit(object, keys) {
    const newObj = {};
    for (const key in object) {
        if (!keys.includes(key)) {
            newObj[key] = object[key];
        }
    }
    return newObj;
}
/**
 * Simple object check.
 * @param item
 */
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
/**
 * Deep merge two objects.
 * @param target
 * @param sources
 */
function mergeDeep(target, ...sources) {
    if (!sources.length) {
        return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key]) {
                    Object.assign(target, { [key]: {} });
                }
                mergeDeep(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(target, ...sources);
}


/***/ }),

/***/ "./Util/Watch.ts":
/*!***********************!*\
  !*** ./Util/Watch.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1721611__) => {

__nested_webpack_require_1721611__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1721611__.d(__nested_webpack_exports__, {
/* harmony export */   watch: () => (/* binding */ watch),
/* harmony export */   watchAny: () => (/* binding */ watchAny),
/* harmony export */   watchDeep: () => (/* binding */ watchDeep)
/* harmony export */ });
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
const createHandler = (path = [], change, typeType) => ({
    get: (target, key) => {
        if (key === '__isProxy') {
            return true;
        }
        if (typeof target[key] === 'object' && target[key] != null) {
            return new Proxy(target[key], createHandler([...path, key], change, typeType));
        }
        return target[key];
    },
    set: (target, key, value) => {
        if (typeof key === 'string') {
            if (key[0] !== '_') {
                change(typeType);
            }
        }
        target[key] = value;
        return true;
    }
});
/**
 *
 */
function watchDeep(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, createHandler([], change, type));
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}


/***/ }),

/***/ "./Util/WebAudio.ts":
/*!**************************!*\
  !*** ./Util/WebAudio.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1724924__) => {

__nested_webpack_require_1724924__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1724924__.d(__nested_webpack_exports__, {
/* harmony export */   WebAudio: () => (/* binding */ WebAudio)
/* harmony export */ });
/* harmony import */ var _Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1724924__(/*! ../Resources/Sound/AudioContext */ "./Resources/Sound/AudioContext.ts");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1724924__(/*! ./Log */ "./Util/Log.ts");


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !_Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__.AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                _Log__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = _Resources_Sound_AudioContext__WEBPACK_IMPORTED_MODULE_0__.AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;


/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1728055__) => {

__nested_webpack_require_1728055__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1728055__.d(__nested_webpack_exports__, {
/* harmony export */   ActionCompleteEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ActionCompleteEvent),
/* harmony export */   ActionContext: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ActionContext),
/* harmony export */   ActionQueue: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ActionQueue),
/* harmony export */   ActionSequence: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ActionSequence),
/* harmony export */   ActionStartEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ActionStartEvent),
/* harmony export */   ActionsComponent: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ActionsComponent),
/* harmony export */   ActionsSystem: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ActionsSystem),
/* harmony export */   ActivateEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ActivateEvent),
/* harmony export */   Actor: () => (/* reexport safe */ _Actor__WEBPACK_IMPORTED_MODULE_6__.Actor),
/* harmony export */   ActorEvents: () => (/* reexport safe */ _Actor__WEBPACK_IMPORTED_MODULE_6__.ActorEvents),
/* harmony export */   AddEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.AddEvent),
/* harmony export */   AddedComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.AddedComponent),
/* harmony export */   AffineMatrix: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.AffineMatrix),
/* harmony export */   Animation: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Animation),
/* harmony export */   AnimationDirection: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.AnimationDirection),
/* harmony export */   AnimationEvents: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.AnimationEvents),
/* harmony export */   AnimationStrategy: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.AnimationStrategy),
/* harmony export */   ArcadeSolver: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.ArcadeSolver),
/* harmony export */   AudioContextFactory: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.AudioContextFactory),
/* harmony export */   Axes: () => (/* reexport safe */ _Input_Gamepad__WEBPACK_IMPORTED_MODULE_40__.Axes),
/* harmony export */   Axis: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.Axis),
/* harmony export */   BaseAlign: () => (/* reexport safe */ _Graphics_FontCommon__WEBPACK_IMPORTED_MODULE_14__.BaseAlign),
/* harmony export */   BezierCurve: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.BezierCurve),
/* harmony export */   Blink: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Blink),
/* harmony export */   BodyComponent: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.BodyComponent),
/* harmony export */   BoundingBox: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.BoundingBox),
/* harmony export */   BrowserComponent: () => (/* reexport safe */ _Util_Browser__WEBPACK_IMPORTED_MODULE_45__.BrowserComponent),
/* harmony export */   BrowserEvents: () => (/* reexport safe */ _Util_Browser__WEBPACK_IMPORTED_MODULE_45__.BrowserEvents),
/* harmony export */   Buttons: () => (/* reexport safe */ _Input_Gamepad__WEBPACK_IMPORTED_MODULE_40__.Buttons),
/* harmony export */   Camera: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.Camera),
/* harmony export */   CameraEvents: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.CameraEvents),
/* harmony export */   Canvas: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Canvas),
/* harmony export */   Circle: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Circle),
/* harmony export */   CircleCollider: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CircleCollider),
/* harmony export */   Clock: () => (/* reexport safe */ _Util_Clock__WEBPACK_IMPORTED_MODULE_53__.Clock),
/* harmony export */   ClosestLineJumpTable: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.ClosestLineJumpTable),
/* harmony export */   Collider: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.Collider),
/* harmony export */   ColliderComponent: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.ColliderComponent),
/* harmony export */   CollisionContact: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionContact),
/* harmony export */   CollisionEndEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionEndEvent),
/* harmony export */   CollisionGroup: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionGroup),
/* harmony export */   CollisionGroupManager: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionGroupManager),
/* harmony export */   CollisionJumpTable: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionJumpTable),
/* harmony export */   CollisionPostSolveEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionPostSolveEvent),
/* harmony export */   CollisionPreSolveEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionPreSolveEvent),
/* harmony export */   CollisionStartEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.CollisionStartEvent),
/* harmony export */   CollisionSystem: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionSystem),
/* harmony export */   CollisionType: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CollisionType),
/* harmony export */   Color: () => (/* reexport safe */ _Color__WEBPACK_IMPORTED_MODULE_27__.Color),
/* harmony export */   ColorBlindFlags: () => (/* reexport safe */ _Debug_index__WEBPACK_IMPORTED_MODULE_9__.ColorBlindFlags),
/* harmony export */   ColorBlindnessMode: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ColorBlindnessMode),
/* harmony export */   ColorBlindnessPostProcessor: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ColorBlindnessPostProcessor),
/* harmony export */   Component: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.Component),
/* harmony export */   CompositeCollider: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.CompositeCollider),
/* harmony export */   ConsoleAppender: () => (/* reexport safe */ _Util_Log__WEBPACK_IMPORTED_MODULE_50__.ConsoleAppender),
/* harmony export */   ContactConstraintPoint: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.ContactConstraintPoint),
/* harmony export */   ContactEndEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ContactEndEvent),
/* harmony export */   ContactSolveBias: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.ContactSolveBias),
/* harmony export */   ContactStartEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ContactStartEvent),
/* harmony export */   CoordPlane: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.CoordPlane),
/* harmony export */   CrossFade: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.CrossFade),
/* harmony export */   CurveBy: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.CurveBy),
/* harmony export */   CurveTo: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.CurveTo),
/* harmony export */   DeactivateEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.DeactivateEvent),
/* harmony export */   Debug: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Debug),
/* harmony export */   DebugConfig: () => (/* reexport safe */ _Debug_index__WEBPACK_IMPORTED_MODULE_9__.DebugConfig),
/* harmony export */   DebugGraphicsComponent: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.DebugGraphicsComponent),
/* harmony export */   DebugSystem: () => (/* reexport safe */ _Debug_index__WEBPACK_IMPORTED_MODULE_9__.DebugSystem),
/* harmony export */   DebugText: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.DebugText),
/* harmony export */   DefaultAntialiasOptions: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.DefaultAntialiasOptions),
/* harmony export */   DefaultGarbageCollectionOptions: () => (/* reexport safe */ _GarbageCollector__WEBPACK_IMPORTED_MODULE_4__.DefaultGarbageCollectionOptions),
/* harmony export */   DefaultLoader: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.DefaultLoader),
/* harmony export */   DefaultPixelArtOptions: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.DefaultPixelArtOptions),
/* harmony export */   DegreeOfFreedom: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.DegreeOfFreedom),
/* harmony export */   Delay: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Delay),
/* harmony export */   Detector: () => (/* reexport safe */ _Util_Detector__WEBPACK_IMPORTED_MODULE_47__.Detector),
/* harmony export */   Die: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Die),
/* harmony export */   Direction: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Direction),
/* harmony export */   Director: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.Director),
/* harmony export */   DirectorEvents: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.DirectorEvents),
/* harmony export */   DisplayMode: () => (/* reexport safe */ _Screen__WEBPACK_IMPORTED_MODULE_5__.DisplayMode),
/* harmony export */   DynamicTree: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.DynamicTree),
/* harmony export */   DynamicTreeCollisionProcessor: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.DynamicTreeCollisionProcessor),
/* harmony export */   EX_VERSION: () => (/* binding */ EX_VERSION),
/* harmony export */   EaseBy: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.EaseBy),
/* harmony export */   EaseTo: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.EaseTo),
/* harmony export */   EasingFunctions: () => (/* reexport safe */ _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_48__.EasingFunctions),
/* harmony export */   EdgeCollider: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.EdgeCollider),
/* harmony export */   ElasticToActorStrategy: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.ElasticToActorStrategy),
/* harmony export */   EmitterType: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.EmitterType),
/* harmony export */   Engine: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_3__.Engine),
/* harmony export */   EngineEvents: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_3__.EngineEvents),
/* harmony export */   EnterTriggerEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.EnterTriggerEvent),
/* harmony export */   EnterViewPortEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.EnterViewPortEvent),
/* harmony export */   Entity: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.Entity),
/* harmony export */   EntityEvents: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.EntityEvents),
/* harmony export */   EntityManager: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.EntityManager),
/* harmony export */   EventEmitter: () => (/* reexport safe */ _EventEmitter__WEBPACK_IMPORTED_MODULE_10__.EventEmitter),
/* harmony export */   EventTypes: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.EventTypes),
/* harmony export */   Events: () => (/* reexport module object */ _Events__WEBPACK_IMPORTED_MODULE_12__),
/* harmony export */   ExResponse: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.ExResponse),
/* harmony export */   ExcaliburGraphicsContext2DCanvas: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ExcaliburGraphicsContext2DCanvas),
/* harmony export */   ExcaliburGraphicsContextWebGL: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ExcaliburGraphicsContextWebGL),
/* harmony export */   ExitTriggerEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ExitTriggerEvent),
/* harmony export */   ExitViewPortEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.ExitViewPortEvent),
/* harmony export */   Fade: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Fade),
/* harmony export */   FadeInOut: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.FadeInOut),
/* harmony export */   Flags: () => (/* reexport safe */ _Flags__WEBPACK_IMPORTED_MODULE_1__.Flags),
/* harmony export */   Flash: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Flash),
/* harmony export */   Follow: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Follow),
/* harmony export */   Font: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Font),
/* harmony export */   FontCache: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.FontCache),
/* harmony export */   FontSource: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.FontSource),
/* harmony export */   FontStyle: () => (/* reexport safe */ _Graphics_FontCommon__WEBPACK_IMPORTED_MODULE_14__.FontStyle),
/* harmony export */   FontUnit: () => (/* reexport safe */ _Graphics_FontCommon__WEBPACK_IMPORTED_MODULE_14__.FontUnit),
/* harmony export */   FpsSampler: () => (/* reexport safe */ _Util_Fps__WEBPACK_IMPORTED_MODULE_52__.FpsSampler),
/* harmony export */   FrameStats: () => (/* reexport safe */ _Debug_index__WEBPACK_IMPORTED_MODULE_9__.FrameStats),
/* harmony export */   Future: () => (/* reexport safe */ _Util_Future__WEBPACK_IMPORTED_MODULE_57__.Future),
/* harmony export */   GameEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GameEvent),
/* harmony export */   GameStartEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GameStartEvent),
/* harmony export */   GameStopEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GameStopEvent),
/* harmony export */   Gamepad: () => (/* reexport safe */ _Input_Gamepad__WEBPACK_IMPORTED_MODULE_40__.Gamepad),
/* harmony export */   GamepadAxisEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GamepadAxisEvent),
/* harmony export */   GamepadButtonEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GamepadButtonEvent),
/* harmony export */   GamepadConnectEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GamepadConnectEvent),
/* harmony export */   GamepadDisconnectEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.GamepadDisconnectEvent),
/* harmony export */   Gamepads: () => (/* reexport safe */ _Input_Gamepad__WEBPACK_IMPORTED_MODULE_40__.Gamepads),
/* harmony export */   GarbageCollector: () => (/* reexport safe */ _GarbageCollector__WEBPACK_IMPORTED_MODULE_4__.GarbageCollector),
/* harmony export */   Gif: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.Gif),
/* harmony export */   GifParser: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.GifParser),
/* harmony export */   GlobalCoordinates: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.GlobalCoordinates),
/* harmony export */   GpuParticleEmitter: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.GpuParticleEmitter),
/* harmony export */   GpuParticleRenderer: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.GpuParticleRenderer),
/* harmony export */   Graphic: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Graphic),
/* harmony export */   GraphicsComponent: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.GraphicsComponent),
/* harmony export */   GraphicsGroup: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.GraphicsGroup),
/* harmony export */   GraphicsSystem: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.GraphicsSystem),
/* harmony export */   HashColliderProxy: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.HashColliderProxy),
/* harmony export */   HashGridCell: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.HashGridCell),
/* harmony export */   HashGridProxy: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.HashGridProxy),
/* harmony export */   HiddenEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.HiddenEvent),
/* harmony export */   HorizontalFirst: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.HorizontalFirst),
/* harmony export */   ImageFiltering: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ImageFiltering),
/* harmony export */   ImageSource: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ImageSource),
/* harmony export */   ImageSourceAttributeConstants: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ImageSourceAttributeConstants),
/* harmony export */   ImageWrapping: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ImageWrapping),
/* harmony export */   InitializeEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.InitializeEvent),
/* harmony export */   InputHost: () => (/* reexport safe */ _Input_InputHost__WEBPACK_IMPORTED_MODULE_42__.InputHost),
/* harmony export */   InputMapper: () => (/* reexport safe */ _Input_InputMapper__WEBPACK_IMPORTED_MODULE_43__.InputMapper),
/* harmony export */   IsometricEntityComponent: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.IsometricEntityComponent),
/* harmony export */   IsometricEntitySystem: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.IsometricEntitySystem),
/* harmony export */   IsometricMap: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.IsometricMap),
/* harmony export */   IsometricTile: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.IsometricTile),
/* harmony export */   KeyEvent: () => (/* reexport safe */ _Input_Keyboard__WEBPACK_IMPORTED_MODULE_41__.KeyEvent),
/* harmony export */   Keyboard: () => (/* reexport safe */ _Input_Keyboard__WEBPACK_IMPORTED_MODULE_41__.Keyboard),
/* harmony export */   Keys: () => (/* reexport safe */ _Input_Keyboard__WEBPACK_IMPORTED_MODULE_41__.Keys),
/* harmony export */   KillEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.KillEvent),
/* harmony export */   Label: () => (/* reexport safe */ _Label__WEBPACK_IMPORTED_MODULE_13__.Label),
/* harmony export */   LimitCameraBoundsStrategy: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.LimitCameraBoundsStrategy),
/* harmony export */   Line: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Line),
/* harmony export */   LineSegment: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.LineSegment),
/* harmony export */   Loader: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.Loader),
/* harmony export */   LoaderEvents: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.LoaderEvents),
/* harmony export */   LockCameraToActorAxisStrategy: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.LockCameraToActorAxisStrategy),
/* harmony export */   LockCameraToActorStrategy: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.LockCameraToActorStrategy),
/* harmony export */   LogLevel: () => (/* reexport safe */ _Util_Log__WEBPACK_IMPORTED_MODULE_50__.LogLevel),
/* harmony export */   Logger: () => (/* reexport safe */ _Util_Log__WEBPACK_IMPORTED_MODULE_50__.Logger),
/* harmony export */   Material: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Material),
/* harmony export */   Matrix: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Matrix),
/* harmony export */   MatrixLocations: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.MatrixLocations),
/* harmony export */   MediaEvent: () => (/* reexport safe */ _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_11__.MediaEvent),
/* harmony export */   Meet: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Meet),
/* harmony export */   MotionComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.MotionComponent),
/* harmony export */   MotionSystem: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.MotionSystem),
/* harmony export */   MoveBy: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.MoveBy),
/* harmony export */   MoveByWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.MoveByWithOptions),
/* harmony export */   MoveTo: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.MoveTo),
/* harmony export */   MoveToWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.MoveToWithOptions),
/* harmony export */   NativePointerButton: () => (/* reexport safe */ _Input_NativePointerButton__WEBPACK_IMPORTED_MODULE_33__.NativePointerButton),
/* harmony export */   NativeSoundEvent: () => (/* reexport safe */ _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_11__.NativeSoundEvent),
/* harmony export */   NativeSoundProcessedEvent: () => (/* reexport safe */ _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_11__.NativeSoundProcessedEvent),
/* harmony export */   NineSlice: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.NineSlice),
/* harmony export */   NineSliceStretch: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.NineSliceStretch),
/* harmony export */   None: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.None),
/* harmony export */   Observable: () => (/* reexport safe */ _Util_Observable__WEBPACK_IMPORTED_MODULE_49__.Observable),
/* harmony export */   OffscreenSystem: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.OffscreenSystem),
/* harmony export */   Pair: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.Pair),
/* harmony export */   ParallaxComponent: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ParallaxComponent),
/* harmony export */   ParallelActions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ParallelActions),
/* harmony export */   Particle: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.Particle),
/* harmony export */   ParticleEmitter: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.ParticleEmitter),
/* harmony export */   ParticleRenderer: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ParticleRenderer),
/* harmony export */   ParticleTransform: () => (/* reexport safe */ _Particles_index__WEBPACK_IMPORTED_MODULE_15__.ParticleTransform),
/* harmony export */   PhysicsStats: () => (/* reexport safe */ _Debug_index__WEBPACK_IMPORTED_MODULE_9__.PhysicsStats),
/* harmony export */   PhysicsWorld: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.PhysicsWorld),
/* harmony export */   PointerAbstraction: () => (/* reexport safe */ _Input_PointerAbstraction__WEBPACK_IMPORTED_MODULE_35__.PointerAbstraction),
/* harmony export */   PointerButton: () => (/* reexport safe */ _Input_PointerButton__WEBPACK_IMPORTED_MODULE_32__.PointerButton),
/* harmony export */   PointerComponent: () => (/* reexport safe */ _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_36__.PointerComponent),
/* harmony export */   PointerEvent: () => (/* reexport safe */ _Input_PointerEvent__WEBPACK_IMPORTED_MODULE_30__.PointerEvent),
/* harmony export */   PointerEventReceiver: () => (/* reexport safe */ _Input_PointerEventReceiver__WEBPACK_IMPORTED_MODULE_34__.PointerEventReceiver),
/* harmony export */   PointerScope: () => (/* reexport safe */ _Input_PointerScope__WEBPACK_IMPORTED_MODULE_39__.PointerScope),
/* harmony export */   PointerSystem: () => (/* reexport safe */ _Input_PointerSystem__WEBPACK_IMPORTED_MODULE_37__.PointerSystem),
/* harmony export */   PointerType: () => (/* reexport safe */ _Input_PointerType__WEBPACK_IMPORTED_MODULE_38__.PointerType),
/* harmony export */   Polygon: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Polygon),
/* harmony export */   PolygonCollider: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.PolygonCollider),
/* harmony export */   Pool: () => (/* reexport safe */ _Util_Pool__WEBPACK_IMPORTED_MODULE_51__.Pool),
/* harmony export */   PostCollisionEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostCollisionEvent),
/* harmony export */   PostDebugDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostDebugDrawEvent),
/* harmony export */   PostDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostDrawEvent),
/* harmony export */   PostFrameEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostFrameEvent),
/* harmony export */   PostKillEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostKillEvent),
/* harmony export */   PostTransformDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostTransformDrawEvent),
/* harmony export */   PostUpdateEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PostUpdateEvent),
/* harmony export */   PreCollisionEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreCollisionEvent),
/* harmony export */   PreDebugDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreDebugDrawEvent),
/* harmony export */   PreDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreDrawEvent),
/* harmony export */   PreFrameEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreFrameEvent),
/* harmony export */   PreKillEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreKillEvent),
/* harmony export */   PreLoadEvent: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_16__.PreLoadEvent),
/* harmony export */   PreTransformDrawEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreTransformDrawEvent),
/* harmony export */   PreUpdateEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.PreUpdateEvent),
/* harmony export */   Projection: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Projection),
/* harmony export */   QuadIndexBuffer: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.QuadIndexBuffer),
/* harmony export */   QuadTree: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.QuadTree),
/* harmony export */   Query: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.Query),
/* harmony export */   QueryManager: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.QueryManager),
/* harmony export */   RadiusAroundActorStrategy: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.RadiusAroundActorStrategy),
/* harmony export */   Random: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Random),
/* harmony export */   Raster: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Raster),
/* harmony export */   Ray: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Ray),
/* harmony export */   RealisticSolver: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.RealisticSolver),
/* harmony export */   Rectangle: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Rectangle),
/* harmony export */   RemoveEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.RemoveEvent),
/* harmony export */   RemovedComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.RemovedComponent),
/* harmony export */   Repeat: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.Repeat),
/* harmony export */   RepeatForever: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.RepeatForever),
/* harmony export */   Resolution: () => (/* reexport safe */ _Screen__WEBPACK_IMPORTED_MODULE_5__.Resolution),
/* harmony export */   Resource: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.Resource),
/* harmony export */   ResourceEvents: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.ResourceEvents),
/* harmony export */   RotateBy: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.RotateBy),
/* harmony export */   RotateByWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.RotateByWithOptions),
/* harmony export */   RotateTo: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.RotateTo),
/* harmony export */   RotateToWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.RotateToWithOptions),
/* harmony export */   RotationType: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.RotationType),
/* harmony export */   ScaleBy: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ScaleBy),
/* harmony export */   ScaleByWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ScaleByWithOptions),
/* harmony export */   ScaleTo: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ScaleTo),
/* harmony export */   ScaleToWithOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.ScaleToWithOptions),
/* harmony export */   Scene: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_16__.Scene),
/* harmony export */   SceneEvents: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_16__.SceneEvents),
/* harmony export */   Screen: () => (/* reexport safe */ _Screen__WEBPACK_IMPORTED_MODULE_5__.Screen),
/* harmony export */   ScreenAppender: () => (/* reexport safe */ _Util_Log__WEBPACK_IMPORTED_MODULE_50__.ScreenAppender),
/* harmony export */   ScreenElement: () => (/* reexport safe */ _ScreenElement__WEBPACK_IMPORTED_MODULE_20__.ScreenElement),
/* harmony export */   ScreenEvents: () => (/* reexport safe */ _Screen__WEBPACK_IMPORTED_MODULE_5__.ScreenEvents),
/* harmony export */   ScreenShader: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.ScreenShader),
/* harmony export */   ScrollPreventionMode: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_3__.ScrollPreventionMode),
/* harmony export */   Semaphore: () => (/* reexport safe */ _Util_Semaphore__WEBPACK_IMPORTED_MODULE_58__.Semaphore),
/* harmony export */   SeparatingAxis: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SeparatingAxis),
/* harmony export */   SeparationInfo: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SeparationInfo),
/* harmony export */   Shader: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Shader),
/* harmony export */   Shape: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.Shape),
/* harmony export */   Side: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.Side),
/* harmony export */   Slide: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.Slide),
/* harmony export */   SolverStrategy: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SolverStrategy),
/* harmony export */   Sound: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.Sound),
/* harmony export */   SoundEvents: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.SoundEvents),
/* harmony export */   SparseHashGrid: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SparseHashGrid),
/* harmony export */   SparseHashGridCollisionProcessor: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SparseHashGridCollisionProcessor),
/* harmony export */   SpatialPartitionStrategy: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.SpatialPartitionStrategy),
/* harmony export */   Sprite: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Sprite),
/* harmony export */   SpriteFont: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.SpriteFont),
/* harmony export */   SpriteSheet: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.SpriteSheet),
/* harmony export */   StandardClock: () => (/* reexport safe */ _Util_Clock__WEBPACK_IMPORTED_MODULE_53__.StandardClock),
/* harmony export */   StateMachine: () => (/* reexport safe */ _Util_StateMachine__WEBPACK_IMPORTED_MODULE_56__.StateMachine),
/* harmony export */   StrategyContainer: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_8__.StrategyContainer),
/* harmony export */   Stream: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.Stream),
/* harmony export */   System: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.System),
/* harmony export */   SystemManager: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.SystemManager),
/* harmony export */   SystemPriority: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.SystemPriority),
/* harmony export */   SystemType: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.SystemType),
/* harmony export */   TagQuery: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.TagQuery),
/* harmony export */   TestClock: () => (/* reexport safe */ _Util_Clock__WEBPACK_IMPORTED_MODULE_53__.TestClock),
/* harmony export */   Text: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.Text),
/* harmony export */   TextAlign: () => (/* reexport safe */ _Graphics_FontCommon__WEBPACK_IMPORTED_MODULE_14__.TextAlign),
/* harmony export */   TextureLoader: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.TextureLoader),
/* harmony export */   Tile: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.Tile),
/* harmony export */   TileMap: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.TileMap),
/* harmony export */   TileMapEvents: () => (/* reexport safe */ _TileMap_index__WEBPACK_IMPORTED_MODULE_17__.TileMapEvents),
/* harmony export */   TiledAnimation: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.TiledAnimation),
/* harmony export */   TiledSprite: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.TiledSprite),
/* harmony export */   Timer: () => (/* reexport safe */ _Timer__WEBPACK_IMPORTED_MODULE_18__.Timer),
/* harmony export */   Toaster: () => (/* reexport safe */ _Util_Toaster__WEBPACK_IMPORTED_MODULE_55__.Toaster),
/* harmony export */   Transform: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Transform),
/* harmony export */   TransformComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.TransformComponent),
/* harmony export */   Transition: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.Transition),
/* harmony export */   TreeNode: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.TreeNode),
/* harmony export */   Trigger: () => (/* reexport safe */ _Trigger__WEBPACK_IMPORTED_MODULE_19__.Trigger),
/* harmony export */   TriggerEvents: () => (/* reexport safe */ _Trigger__WEBPACK_IMPORTED_MODULE_19__.TriggerEvents),
/* harmony export */   TwoPI: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.TwoPI),
/* harmony export */   Util: () => (/* reexport module object */ _Util_Index__WEBPACK_IMPORTED_MODULE_44__),
/* harmony export */   Vector: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.Vector),
/* harmony export */   VectorView: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.VectorView),
/* harmony export */   VertexBuffer: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.VertexBuffer),
/* harmony export */   VertexLayout: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.VertexLayout),
/* harmony export */   VerticalFirst: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.VerticalFirst),
/* harmony export */   VisibleEvent: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_12__.VisibleEvent),
/* harmony export */   WebAudio: () => (/* reexport safe */ _Util_WebAudio__WEBPACK_IMPORTED_MODULE_54__.WebAudio),
/* harmony export */   WebAudioInstance: () => (/* reexport safe */ _Resources_Index__WEBPACK_IMPORTED_MODULE_24__.WebAudioInstance),
/* harmony export */   WheelDeltaMode: () => (/* reexport safe */ _Input_WheelDeltaMode__WEBPACK_IMPORTED_MODULE_31__.WheelDeltaMode),
/* harmony export */   WheelEvent: () => (/* reexport safe */ _Input_WheelEvent__WEBPACK_IMPORTED_MODULE_29__.WheelEvent),
/* harmony export */   World: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.World),
/* harmony export */   approximatelyEqual: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.approximatelyEqual),
/* harmony export */   assert: () => (/* reexport safe */ _Util_Assert__WEBPACK_IMPORTED_MODULE_60__.assert),
/* harmony export */   canonicalizeAngle: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.canonicalizeAngle),
/* harmony export */   clamp: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.clamp),
/* harmony export */   coroutine: () => (/* reexport safe */ _Util_Coroutine__WEBPACK_IMPORTED_MODULE_59__.coroutine),
/* harmony export */   createId: () => (/* reexport safe */ _Id__WEBPACK_IMPORTED_MODULE_2__.createId),
/* harmony export */   frac: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.frac),
/* harmony export */   getDefaultPhysicsConfig: () => (/* reexport safe */ _Collision_Index__WEBPACK_IMPORTED_MODULE_22__.getDefaultPhysicsConfig),
/* harmony export */   hasGraphicsTick: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.hasGraphicsTick),
/* harmony export */   hasOnAdd: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasOnAdd),
/* harmony export */   hasOnInitialize: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasOnInitialize),
/* harmony export */   hasOnPostUpdate: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasOnPostUpdate),
/* harmony export */   hasOnPreUpdate: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasOnPreUpdate),
/* harmony export */   hasOnRemove: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasOnRemove),
/* harmony export */   hasPostDraw: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasPostDraw),
/* harmony export */   hasPreDraw: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.hasPreDraw),
/* harmony export */   has_add: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.has_add),
/* harmony export */   has_initialize: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.has_initialize),
/* harmony export */   has_postupdate: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.has_postupdate),
/* harmony export */   has_preupdate: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.has_preupdate),
/* harmony export */   has_remove: () => (/* reexport safe */ _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__.has_remove),
/* harmony export */   inverseLerp: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.inverseLerp),
/* harmony export */   inverseLerpVector: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.inverseLerpVector),
/* harmony export */   isActor: () => (/* reexport safe */ _Actor__WEBPACK_IMPORTED_MODULE_6__.isActor),
/* harmony export */   isAddedComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.isAddedComponent),
/* harmony export */   isComponentCtor: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.isComponentCtor),
/* harmony export */   isLoaderConstructor: () => (/* reexport safe */ _Director_index__WEBPACK_IMPORTED_MODULE_26__.isLoaderConstructor),
/* harmony export */   isMoveByOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isMoveByOptions),
/* harmony export */   isMoveToOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isMoveToOptions),
/* harmony export */   isRemovedComponent: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.isRemovedComponent),
/* harmony export */   isRotateByOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isRotateByOptions),
/* harmony export */   isRotateToOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isRotateToOptions),
/* harmony export */   isScaleByOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isScaleByOptions),
/* harmony export */   isScaleToOptions: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.isScaleToOptions),
/* harmony export */   isSceneConstructor: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_16__.isSceneConstructor),
/* harmony export */   isScreenElement: () => (/* reexport safe */ _ScreenElement__WEBPACK_IMPORTED_MODULE_20__.isScreenElement),
/* harmony export */   isSystemConstructor: () => (/* reexport safe */ _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__.isSystemConstructor),
/* harmony export */   lerp: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.lerp),
/* harmony export */   lerpAngle: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.lerpAngle),
/* harmony export */   lerpVector: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.lerpVector),
/* harmony export */   maxMessages: () => (/* reexport safe */ _Util_Decorators__WEBPACK_IMPORTED_MODULE_46__.maxMessages),
/* harmony export */   nextActionId: () => (/* reexport safe */ _Actions_index__WEBPACK_IMPORTED_MODULE_21__.nextActionId),
/* harmony export */   obsolete: () => (/* reexport safe */ _Util_Decorators__WEBPACK_IMPORTED_MODULE_46__.obsolete),
/* harmony export */   parseImageFiltering: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.parseImageFiltering),
/* harmony export */   parseImageWrapping: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.parseImageWrapping),
/* harmony export */   pixelSnapEpsilon: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.pixelSnapEpsilon),
/* harmony export */   randomInRange: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.randomInRange),
/* harmony export */   randomIntInRange: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.randomIntInRange),
/* harmony export */   range: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.range),
/* harmony export */   remap: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.remap),
/* harmony export */   remapVector: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.remapVector),
/* harmony export */   resetObsoleteCounter: () => (/* reexport safe */ _Util_Decorators__WEBPACK_IMPORTED_MODULE_46__.resetObsoleteCounter),
/* harmony export */   sign: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.sign),
/* harmony export */   toDegrees: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.toDegrees),
/* harmony export */   toRadians: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.toRadians),
/* harmony export */   vec: () => (/* reexport safe */ _Math_index__WEBPACK_IMPORTED_MODULE_7__.vec),
/* harmony export */   webgl: () => (/* reexport safe */ _Graphics_index__WEBPACK_IMPORTED_MODULE_28__.webgl)
/* harmony export */ });
/* harmony import */ var _Polyfill__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1728055__(/*! ./Polyfill */ "./Polyfill.ts");
/* harmony import */ var _Flags__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1728055__(/*! ./Flags */ "./Flags.ts");
/* harmony import */ var _Id__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1728055__(/*! ./Id */ "./Id.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1728055__(/*! ./Engine */ "./Engine.ts");
/* harmony import */ var _GarbageCollector__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1728055__(/*! ./GarbageCollector */ "./GarbageCollector.ts");
/* harmony import */ var _Screen__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_1728055__(/*! ./Screen */ "./Screen.ts");
/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_1728055__(/*! ./Actor */ "./Actor.ts");
/* harmony import */ var _Math_index__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_1728055__(/*! ./Math/index */ "./Math/index.ts");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_1728055__(/*! ./Camera */ "./Camera.ts");
/* harmony import */ var _Debug_index__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_1728055__(/*! ./Debug/index */ "./Debug/index.ts");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_1728055__(/*! ./EventEmitter */ "./EventEmitter.ts");
/* harmony import */ var _Events_MediaEvents__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_1728055__(/*! ./Events/MediaEvents */ "./Events/MediaEvents.ts");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_1728055__(/*! ./Events */ "./Events.ts");
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_1728055__(/*! ./Label */ "./Label.ts");
/* harmony import */ var _Graphics_FontCommon__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_1728055__(/*! ./Graphics/FontCommon */ "./Graphics/FontCommon.ts");
/* harmony import */ var _Particles_index__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_1728055__(/*! ./Particles/index */ "./Particles/index.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_1728055__(/*! ./Scene */ "./Scene.ts");
/* harmony import */ var _TileMap_index__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_1728055__(/*! ./TileMap/index */ "./TileMap/index.ts");
/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_1728055__(/*! ./Timer */ "./Timer.ts");
/* harmony import */ var _Trigger__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_1728055__(/*! ./Trigger */ "./Trigger.ts");
/* harmony import */ var _ScreenElement__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_1728055__(/*! ./ScreenElement */ "./ScreenElement.ts");
/* harmony import */ var _Actions_index__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_1728055__(/*! ./Actions/index */ "./Actions/index.ts");
/* harmony import */ var _Collision_Index__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_1728055__(/*! ./Collision/Index */ "./Collision/Index.ts");
/* harmony import */ var _Interfaces_Index__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_1728055__(/*! ./Interfaces/Index */ "./Interfaces/Index.ts");
/* harmony import */ var _Resources_Index__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_1728055__(/*! ./Resources/Index */ "./Resources/Index.ts");
/* harmony import */ var _EntityComponentSystem_index__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_1728055__(/*! ./EntityComponentSystem/index */ "./EntityComponentSystem/index.ts");
/* harmony import */ var _Director_index__WEBPACK_IMPORTED_MODULE_26__ = __nested_webpack_require_1728055__(/*! ./Director/index */ "./Director/index.ts");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_27__ = __nested_webpack_require_1728055__(/*! ./Color */ "./Color.ts");
/* harmony import */ var _Graphics_index__WEBPACK_IMPORTED_MODULE_28__ = __nested_webpack_require_1728055__(/*! ./Graphics/index */ "./Graphics/index.ts");
/* harmony import */ var _Input_WheelEvent__WEBPACK_IMPORTED_MODULE_29__ = __nested_webpack_require_1728055__(/*! ./Input/WheelEvent */ "./Input/WheelEvent.ts");
/* harmony import */ var _Input_PointerEvent__WEBPACK_IMPORTED_MODULE_30__ = __nested_webpack_require_1728055__(/*! ./Input/PointerEvent */ "./Input/PointerEvent.ts");
/* harmony import */ var _Input_WheelDeltaMode__WEBPACK_IMPORTED_MODULE_31__ = __nested_webpack_require_1728055__(/*! ./Input/WheelDeltaMode */ "./Input/WheelDeltaMode.ts");
/* harmony import */ var _Input_PointerButton__WEBPACK_IMPORTED_MODULE_32__ = __nested_webpack_require_1728055__(/*! ./Input/PointerButton */ "./Input/PointerButton.ts");
/* harmony import */ var _Input_NativePointerButton__WEBPACK_IMPORTED_MODULE_33__ = __nested_webpack_require_1728055__(/*! ./Input/NativePointerButton */ "./Input/NativePointerButton.ts");
/* harmony import */ var _Input_PointerEventReceiver__WEBPACK_IMPORTED_MODULE_34__ = __nested_webpack_require_1728055__(/*! ./Input/PointerEventReceiver */ "./Input/PointerEventReceiver.ts");
/* harmony import */ var _Input_PointerAbstraction__WEBPACK_IMPORTED_MODULE_35__ = __nested_webpack_require_1728055__(/*! ./Input/PointerAbstraction */ "./Input/PointerAbstraction.ts");
/* harmony import */ var _Input_PointerComponent__WEBPACK_IMPORTED_MODULE_36__ = __nested_webpack_require_1728055__(/*! ./Input/PointerComponent */ "./Input/PointerComponent.ts");
/* harmony import */ var _Input_PointerSystem__WEBPACK_IMPORTED_MODULE_37__ = __nested_webpack_require_1728055__(/*! ./Input/PointerSystem */ "./Input/PointerSystem.ts");
/* harmony import */ var _Input_PointerType__WEBPACK_IMPORTED_MODULE_38__ = __nested_webpack_require_1728055__(/*! ./Input/PointerType */ "./Input/PointerType.ts");
/* harmony import */ var _Input_PointerScope__WEBPACK_IMPORTED_MODULE_39__ = __nested_webpack_require_1728055__(/*! ./Input/PointerScope */ "./Input/PointerScope.ts");
/* harmony import */ var _Input_Gamepad__WEBPACK_IMPORTED_MODULE_40__ = __nested_webpack_require_1728055__(/*! ./Input/Gamepad */ "./Input/Gamepad.ts");
/* harmony import */ var _Input_Keyboard__WEBPACK_IMPORTED_MODULE_41__ = __nested_webpack_require_1728055__(/*! ./Input/Keyboard */ "./Input/Keyboard.ts");
/* harmony import */ var _Input_InputHost__WEBPACK_IMPORTED_MODULE_42__ = __nested_webpack_require_1728055__(/*! ./Input/InputHost */ "./Input/InputHost.ts");
/* harmony import */ var _Input_InputMapper__WEBPACK_IMPORTED_MODULE_43__ = __nested_webpack_require_1728055__(/*! ./Input/InputMapper */ "./Input/InputMapper.ts");
/* harmony import */ var _Util_Index__WEBPACK_IMPORTED_MODULE_44__ = __nested_webpack_require_1728055__(/*! ./Util/Index */ "./Util/Index.ts");
/* harmony import */ var _Util_Browser__WEBPACK_IMPORTED_MODULE_45__ = __nested_webpack_require_1728055__(/*! ./Util/Browser */ "./Util/Browser.ts");
/* harmony import */ var _Util_Decorators__WEBPACK_IMPORTED_MODULE_46__ = __nested_webpack_require_1728055__(/*! ./Util/Decorators */ "./Util/Decorators.ts");
/* harmony import */ var _Util_Detector__WEBPACK_IMPORTED_MODULE_47__ = __nested_webpack_require_1728055__(/*! ./Util/Detector */ "./Util/Detector.ts");
/* harmony import */ var _Util_EasingFunctions__WEBPACK_IMPORTED_MODULE_48__ = __nested_webpack_require_1728055__(/*! ./Util/EasingFunctions */ "./Util/EasingFunctions.ts");
/* harmony import */ var _Util_Observable__WEBPACK_IMPORTED_MODULE_49__ = __nested_webpack_require_1728055__(/*! ./Util/Observable */ "./Util/Observable.ts");
/* harmony import */ var _Util_Log__WEBPACK_IMPORTED_MODULE_50__ = __nested_webpack_require_1728055__(/*! ./Util/Log */ "./Util/Log.ts");
/* harmony import */ var _Util_Pool__WEBPACK_IMPORTED_MODULE_51__ = __nested_webpack_require_1728055__(/*! ./Util/Pool */ "./Util/Pool.ts");
/* harmony import */ var _Util_Fps__WEBPACK_IMPORTED_MODULE_52__ = __nested_webpack_require_1728055__(/*! ./Util/Fps */ "./Util/Fps.ts");
/* harmony import */ var _Util_Clock__WEBPACK_IMPORTED_MODULE_53__ = __nested_webpack_require_1728055__(/*! ./Util/Clock */ "./Util/Clock.ts");
/* harmony import */ var _Util_WebAudio__WEBPACK_IMPORTED_MODULE_54__ = __nested_webpack_require_1728055__(/*! ./Util/WebAudio */ "./Util/WebAudio.ts");
/* harmony import */ var _Util_Toaster__WEBPACK_IMPORTED_MODULE_55__ = __nested_webpack_require_1728055__(/*! ./Util/Toaster */ "./Util/Toaster.ts");
/* harmony import */ var _Util_StateMachine__WEBPACK_IMPORTED_MODULE_56__ = __nested_webpack_require_1728055__(/*! ./Util/StateMachine */ "./Util/StateMachine.ts");
/* harmony import */ var _Util_Future__WEBPACK_IMPORTED_MODULE_57__ = __nested_webpack_require_1728055__(/*! ./Util/Future */ "./Util/Future.ts");
/* harmony import */ var _Util_Semaphore__WEBPACK_IMPORTED_MODULE_58__ = __nested_webpack_require_1728055__(/*! ./Util/Semaphore */ "./Util/Semaphore.ts");
/* harmony import */ var _Util_Coroutine__WEBPACK_IMPORTED_MODULE_59__ = __nested_webpack_require_1728055__(/*! ./Util/Coroutine */ "./Util/Coroutine.ts");
/* harmony import */ var _Util_Assert__WEBPACK_IMPORTED_MODULE_60__ = __nested_webpack_require_1728055__(/*! ./Util/Assert */ "./Util/Assert.ts");
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.30.1";

(0,_Polyfill__WEBPACK_IMPORTED_MODULE_0__.polyfill)();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.




























// ex.Events namespace

















// ex.Util namespaces


















// ex.Deprecated
// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';


/***/ }),

/***/ "./Director/Loader.logo.png":
/*!**********************************!*\
  !*** ./Director/Loader.logo.png ***!
  \**********************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1783234__) => {

__nested_webpack_require_1783234__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1783234__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");

/***/ }),

/***/ "./Graphics/Context/debug-font.png":
/*!*****************************************!*\
  !*** ./Graphics/Context/debug-font.png ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1787534__) => {

__nested_webpack_require_1787534__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_1787534__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABACAYAAAD1Xam+AAAAAXNSR0IArs4c6QAABlFJREFUeJztndmy4yoMRcWt/v9fdr8EWoDAaDD4JntVpeqcxBrMIGQDNhEAAAAAAAAAAAAAAOCrSbMfr+u6yoEpTY+906GV57YtPkjyXj9WZZ+wHWHfo2N3/bU6Tte9Rv6ptruqRyMvKvvIX/zY3I/vjLeqsg6l/CWdp0KHKO/1Y1H2EdsR9j06Ntdfp+N03SvkH2u7i3pu5XkQ+DNTkgNJSok+/183xpcdWZHjgUzpQ2pGD67vaf//KRAGAq3tdhCy2tcMQKPyXyz7iPqrdBjbX5h9g7xbtvWf4ZJvM4D/BKG24Sd+IkQ0TC9aW5NM5FbO2HgrPVzW2vmN50DZNv/QWtl5bfPy85SBtdy9dFmjsf2F2SehTBVE+u+tkE5+lAGcJlFwGuodwRRU2Qe3rx0FhPNflc3HWC7BEh8EDGVR5IMCiLnDONtPp87qhxVH/S/LvzUAuDs/kyGimA5oSONKR1w8vsLpv+v+S9vhmS71JRiX1xB5CWZNw7m6rMrllMag/RJyWb67BEgpDVMWSydc+K47pr35w05kWd7ReEq6116KaG4CsbJ7OmV9PdZLEKkONiC1/7ZONVgDsajLIJPYp2OUAXRpnPcGmnIE6eSK4nv5YQqqSYO52JqnYfYj/PdQXQIY7XszuMofMgZRT/1LdeC5h2I5/0EdWDMY2Yb05WDE1RodVdpSA5r85slArAVnSf+89iP896St0f5bZKVA7Gk/3ja8q+152/+wrLqBWZTem3IBADbRBoDuHgAA4HdAAADgh0EAAOCHQQAA4IdBAADgh0EAAOCHuVsKbJ3P9M7jjuxHzGfv8j9iDt47Dx7hP8cjq5F/o/0T62Aer//ZOgDrajBp6aNlOWTEajKLjgj/Pcs/vfZD/a++3Pc8hNfZ966EVeh5vP75luDRJUAl0KzJfnopaqbaTuzZiulc2BS5lltFXntu3dcQsXadl59Wn1H+dfYNtrt2d6D/LDF9HkCQw6eXFbr8P9X5W/un5Ol8gz1t39p5pWOPn0vLynbgdnfe8maEQw+UIPJdfxdOd/4oTtVD0IYg8wDywGas0I04T5O3P8/qf2UWwPpkn1PbOT1bN2tFe59EM7TvKf+TRFw+erZ2ey4hpS3hp9qBkqq/tjsSU1OYqucBWB1yynt5QxC42Mdk30pAEIio//zRG3feBzLUX+TTjCKwlH83aI/KbpQBVEHgUGF0j/SitcLofHem8q6AyH0wBhFv4WszuOjy0yK2vc/oRWQoP2X9ve78jfaLnpncbBqQSC6s0HnIRT0a2yNZjfxT8+ir8t+yDsDTWaS6X70GP33+d77stp+I5HtBdwEAAPBl8ECApcAA/DBvfSowAGAB7/05ZAAA/DAIAADMMU3fOuS2ggAAwBjrorKoxWiPBxHMAgAg490Ts0VeePdA+ZfJDKcCh7sBqY88mmjklZeOt9iXPrvx2I2QPRnN2/qzyJ84h4gNcbtfasq5mM1rZr+bBWh2A+bIIX13Z9wqL+nQvFno7v3oq4tJItCed7isUT6C/I7BUn9KP95wDicYBYpcjncrO2c/dmW4tBtw4RiRld1IDxDyYsoXMHxF1w3dyz0Nne8033AOFsT6VgRCafl89fenTZUfbm8CGhrgdDcS7anAsvnkkP0IeCfQ+JzYunky6jhNYj5bl7++4fJvN9WDSKS/292A0wyANyKDI91bfkm3kcH7ckaP/SKW/VHKRZAcI14pP3beu0fPyn/DuZQbWMogNnsc16sziE96f7H/iai7uTf0/3N8lwFz/e13T00Djt4OrInCnkeChXT+qOcKOLA21tJpsv/G8/COnGnw97J9QwbTvd6djYSv7fxEVTuV/LzNhj7nOawv6bfbAGCYEpQ6HxFtuxs6sq9tzOYHobQ6Nje+6vo5BwFrPZ4OgMayS4PPt1NlzdLfbRCYBoBc+NaO4JWPwLEf33oN3unY3InKPQBW6Z7nEZzEmrl4iZjC804lqgePPEOguQcwWghUphxm343wyt/pWpWR0OrR+jvyxavHajfb9pTjbt9bH07Z5/expM4TLWfwb7QQqMoC+UDWXZo/4RgA38LOgUvLJAAQ1Td9y9//0ylxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+g79apuVUsS5ZmwAAAABJRU5ErkJggg==");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nested_webpack_require_1790333__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1790333__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_1790333__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__nested_webpack_require_1790333__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_1790333__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_1790333__.o(definition, key) && !__nested_webpack_require_1790333__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_1790333__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_1790333__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module is referenced by other modules so it can't be inlined
/******/ var __nested_webpack_exports__ = __nested_webpack_require_1790333__("./index.ts");
/******/ var __webpack_exports__ActionCompleteEvent = __nested_webpack_exports__.ActionCompleteEvent;
/******/ var __webpack_exports__ActionContext = __nested_webpack_exports__.ActionContext;
/******/ var __webpack_exports__ActionQueue = __nested_webpack_exports__.ActionQueue;
/******/ var __webpack_exports__ActionSequence = __nested_webpack_exports__.ActionSequence;
/******/ var __webpack_exports__ActionStartEvent = __nested_webpack_exports__.ActionStartEvent;
/******/ var __webpack_exports__ActionsComponent = __nested_webpack_exports__.ActionsComponent;
/******/ var __webpack_exports__ActionsSystem = __nested_webpack_exports__.ActionsSystem;
/******/ var __webpack_exports__ActivateEvent = __nested_webpack_exports__.ActivateEvent;
/******/ var __webpack_exports__Actor = __nested_webpack_exports__.Actor;
/******/ var __webpack_exports__ActorEvents = __nested_webpack_exports__.ActorEvents;
/******/ var __webpack_exports__AddEvent = __nested_webpack_exports__.AddEvent;
/******/ var __webpack_exports__AddedComponent = __nested_webpack_exports__.AddedComponent;
/******/ var __webpack_exports__AffineMatrix = __nested_webpack_exports__.AffineMatrix;
/******/ var __webpack_exports__Animation = __nested_webpack_exports__.Animation;
/******/ var __webpack_exports__AnimationDirection = __nested_webpack_exports__.AnimationDirection;
/******/ var __webpack_exports__AnimationEvents = __nested_webpack_exports__.AnimationEvents;
/******/ var __webpack_exports__AnimationStrategy = __nested_webpack_exports__.AnimationStrategy;
/******/ var __webpack_exports__ArcadeSolver = __nested_webpack_exports__.ArcadeSolver;
/******/ var __webpack_exports__AudioContextFactory = __nested_webpack_exports__.AudioContextFactory;
/******/ var __webpack_exports__Axes = __nested_webpack_exports__.Axes;
/******/ var __webpack_exports__Axis = __nested_webpack_exports__.Axis;
/******/ var __webpack_exports__BaseAlign = __nested_webpack_exports__.BaseAlign;
/******/ var __webpack_exports__BezierCurve = __nested_webpack_exports__.BezierCurve;
/******/ var __webpack_exports__Blink = __nested_webpack_exports__.Blink;
/******/ var __webpack_exports__BodyComponent = __nested_webpack_exports__.BodyComponent;
/******/ var __webpack_exports__BoundingBox = __nested_webpack_exports__.BoundingBox;
/******/ var __webpack_exports__BrowserComponent = __nested_webpack_exports__.BrowserComponent;
/******/ var __webpack_exports__BrowserEvents = __nested_webpack_exports__.BrowserEvents;
/******/ var __webpack_exports__Buttons = __nested_webpack_exports__.Buttons;
/******/ var __webpack_exports__Camera = __nested_webpack_exports__.Camera;
/******/ var __webpack_exports__CameraEvents = __nested_webpack_exports__.CameraEvents;
/******/ var __webpack_exports__Canvas = __nested_webpack_exports__.Canvas;
/******/ var __webpack_exports__Circle = __nested_webpack_exports__.Circle;
/******/ var __webpack_exports__CircleCollider = __nested_webpack_exports__.CircleCollider;
/******/ var __webpack_exports__Clock = __nested_webpack_exports__.Clock;
/******/ var __webpack_exports__ClosestLineJumpTable = __nested_webpack_exports__.ClosestLineJumpTable;
/******/ var __webpack_exports__Collider = __nested_webpack_exports__.Collider;
/******/ var __webpack_exports__ColliderComponent = __nested_webpack_exports__.ColliderComponent;
/******/ var __webpack_exports__CollisionContact = __nested_webpack_exports__.CollisionContact;
/******/ var __webpack_exports__CollisionEndEvent = __nested_webpack_exports__.CollisionEndEvent;
/******/ var __webpack_exports__CollisionGroup = __nested_webpack_exports__.CollisionGroup;
/******/ var __webpack_exports__CollisionGroupManager = __nested_webpack_exports__.CollisionGroupManager;
/******/ var __webpack_exports__CollisionJumpTable = __nested_webpack_exports__.CollisionJumpTable;
/******/ var __webpack_exports__CollisionPostSolveEvent = __nested_webpack_exports__.CollisionPostSolveEvent;
/******/ var __webpack_exports__CollisionPreSolveEvent = __nested_webpack_exports__.CollisionPreSolveEvent;
/******/ var __webpack_exports__CollisionStartEvent = __nested_webpack_exports__.CollisionStartEvent;
/******/ var __webpack_exports__CollisionSystem = __nested_webpack_exports__.CollisionSystem;
/******/ var __webpack_exports__CollisionType = __nested_webpack_exports__.CollisionType;
/******/ var __webpack_exports__Color = __nested_webpack_exports__.Color;
/******/ var __webpack_exports__ColorBlindFlags = __nested_webpack_exports__.ColorBlindFlags;
/******/ var __webpack_exports__ColorBlindnessMode = __nested_webpack_exports__.ColorBlindnessMode;
/******/ var __webpack_exports__ColorBlindnessPostProcessor = __nested_webpack_exports__.ColorBlindnessPostProcessor;
/******/ var __webpack_exports__Component = __nested_webpack_exports__.Component;
/******/ var __webpack_exports__CompositeCollider = __nested_webpack_exports__.CompositeCollider;
/******/ var __webpack_exports__ConsoleAppender = __nested_webpack_exports__.ConsoleAppender;
/******/ var __webpack_exports__ContactConstraintPoint = __nested_webpack_exports__.ContactConstraintPoint;
/******/ var __webpack_exports__ContactEndEvent = __nested_webpack_exports__.ContactEndEvent;
/******/ var __webpack_exports__ContactSolveBias = __nested_webpack_exports__.ContactSolveBias;
/******/ var __webpack_exports__ContactStartEvent = __nested_webpack_exports__.ContactStartEvent;
/******/ var __webpack_exports__CoordPlane = __nested_webpack_exports__.CoordPlane;
/******/ var __webpack_exports__CrossFade = __nested_webpack_exports__.CrossFade;
/******/ var __webpack_exports__CurveBy = __nested_webpack_exports__.CurveBy;
/******/ var __webpack_exports__CurveTo = __nested_webpack_exports__.CurveTo;
/******/ var __webpack_exports__DeactivateEvent = __nested_webpack_exports__.DeactivateEvent;
/******/ var __webpack_exports__Debug = __nested_webpack_exports__.Debug;
/******/ var __webpack_exports__DebugConfig = __nested_webpack_exports__.DebugConfig;
/******/ var __webpack_exports__DebugGraphicsComponent = __nested_webpack_exports__.DebugGraphicsComponent;
/******/ var __webpack_exports__DebugSystem = __nested_webpack_exports__.DebugSystem;
/******/ var __webpack_exports__DebugText = __nested_webpack_exports__.DebugText;
/******/ var __webpack_exports__DefaultAntialiasOptions = __nested_webpack_exports__.DefaultAntialiasOptions;
/******/ var __webpack_exports__DefaultGarbageCollectionOptions = __nested_webpack_exports__.DefaultGarbageCollectionOptions;
/******/ var __webpack_exports__DefaultLoader = __nested_webpack_exports__.DefaultLoader;
/******/ var __webpack_exports__DefaultPixelArtOptions = __nested_webpack_exports__.DefaultPixelArtOptions;
/******/ var __webpack_exports__DegreeOfFreedom = __nested_webpack_exports__.DegreeOfFreedom;
/******/ var __webpack_exports__Delay = __nested_webpack_exports__.Delay;
/******/ var __webpack_exports__Detector = __nested_webpack_exports__.Detector;
/******/ var __webpack_exports__Die = __nested_webpack_exports__.Die;
/******/ var __webpack_exports__Direction = __nested_webpack_exports__.Direction;
/******/ var __webpack_exports__Director = __nested_webpack_exports__.Director;
/******/ var __webpack_exports__DirectorEvents = __nested_webpack_exports__.DirectorEvents;
/******/ var __webpack_exports__DisplayMode = __nested_webpack_exports__.DisplayMode;
/******/ var __webpack_exports__DynamicTree = __nested_webpack_exports__.DynamicTree;
/******/ var __webpack_exports__DynamicTreeCollisionProcessor = __nested_webpack_exports__.DynamicTreeCollisionProcessor;
/******/ var __webpack_exports__EX_VERSION = __nested_webpack_exports__.EX_VERSION;
/******/ var __webpack_exports__EaseBy = __nested_webpack_exports__.EaseBy;
/******/ var __webpack_exports__EaseTo = __nested_webpack_exports__.EaseTo;
/******/ var __webpack_exports__EasingFunctions = __nested_webpack_exports__.EasingFunctions;
/******/ var __webpack_exports__EdgeCollider = __nested_webpack_exports__.EdgeCollider;
/******/ var __webpack_exports__ElasticToActorStrategy = __nested_webpack_exports__.ElasticToActorStrategy;
/******/ var __webpack_exports__EmitterType = __nested_webpack_exports__.EmitterType;
/******/ var __webpack_exports__Engine = __nested_webpack_exports__.Engine;
/******/ var __webpack_exports__EngineEvents = __nested_webpack_exports__.EngineEvents;
/******/ var __webpack_exports__EnterTriggerEvent = __nested_webpack_exports__.EnterTriggerEvent;
/******/ var __webpack_exports__EnterViewPortEvent = __nested_webpack_exports__.EnterViewPortEvent;
/******/ var __webpack_exports__Entity = __nested_webpack_exports__.Entity;
/******/ var __webpack_exports__EntityEvents = __nested_webpack_exports__.EntityEvents;
/******/ var __webpack_exports__EntityManager = __nested_webpack_exports__.EntityManager;
/******/ var __webpack_exports__EventEmitter = __nested_webpack_exports__.EventEmitter;
/******/ var __webpack_exports__EventTypes = __nested_webpack_exports__.EventTypes;
/******/ var __webpack_exports__Events = __nested_webpack_exports__.Events;
/******/ var __webpack_exports__ExResponse = __nested_webpack_exports__.ExResponse;
/******/ var __webpack_exports__ExcaliburGraphicsContext2DCanvas = __nested_webpack_exports__.ExcaliburGraphicsContext2DCanvas;
/******/ var __webpack_exports__ExcaliburGraphicsContextWebGL = __nested_webpack_exports__.ExcaliburGraphicsContextWebGL;
/******/ var __webpack_exports__ExitTriggerEvent = __nested_webpack_exports__.ExitTriggerEvent;
/******/ var __webpack_exports__ExitViewPortEvent = __nested_webpack_exports__.ExitViewPortEvent;
/******/ var __webpack_exports__Fade = __nested_webpack_exports__.Fade;
/******/ var __webpack_exports__FadeInOut = __nested_webpack_exports__.FadeInOut;
/******/ var __webpack_exports__Flags = __nested_webpack_exports__.Flags;
/******/ var __webpack_exports__Flash = __nested_webpack_exports__.Flash;
/******/ var __webpack_exports__Follow = __nested_webpack_exports__.Follow;
/******/ var __webpack_exports__Font = __nested_webpack_exports__.Font;
/******/ var __webpack_exports__FontCache = __nested_webpack_exports__.FontCache;
/******/ var __webpack_exports__FontSource = __nested_webpack_exports__.FontSource;
/******/ var __webpack_exports__FontStyle = __nested_webpack_exports__.FontStyle;
/******/ var __webpack_exports__FontUnit = __nested_webpack_exports__.FontUnit;
/******/ var __webpack_exports__FpsSampler = __nested_webpack_exports__.FpsSampler;
/******/ var __webpack_exports__FrameStats = __nested_webpack_exports__.FrameStats;
/******/ var __webpack_exports__Future = __nested_webpack_exports__.Future;
/******/ var __webpack_exports__GameEvent = __nested_webpack_exports__.GameEvent;
/******/ var __webpack_exports__GameStartEvent = __nested_webpack_exports__.GameStartEvent;
/******/ var __webpack_exports__GameStopEvent = __nested_webpack_exports__.GameStopEvent;
/******/ var __webpack_exports__Gamepad = __nested_webpack_exports__.Gamepad;
/******/ var __webpack_exports__GamepadAxisEvent = __nested_webpack_exports__.GamepadAxisEvent;
/******/ var __webpack_exports__GamepadButtonEvent = __nested_webpack_exports__.GamepadButtonEvent;
/******/ var __webpack_exports__GamepadConnectEvent = __nested_webpack_exports__.GamepadConnectEvent;
/******/ var __webpack_exports__GamepadDisconnectEvent = __nested_webpack_exports__.GamepadDisconnectEvent;
/******/ var __webpack_exports__Gamepads = __nested_webpack_exports__.Gamepads;
/******/ var __webpack_exports__GarbageCollector = __nested_webpack_exports__.GarbageCollector;
/******/ var __webpack_exports__Gif = __nested_webpack_exports__.Gif;
/******/ var __webpack_exports__GifParser = __nested_webpack_exports__.GifParser;
/******/ var __webpack_exports__GlobalCoordinates = __nested_webpack_exports__.GlobalCoordinates;
/******/ var __webpack_exports__GpuParticleEmitter = __nested_webpack_exports__.GpuParticleEmitter;
/******/ var __webpack_exports__GpuParticleRenderer = __nested_webpack_exports__.GpuParticleRenderer;
/******/ var __webpack_exports__Graphic = __nested_webpack_exports__.Graphic;
/******/ var __webpack_exports__GraphicsComponent = __nested_webpack_exports__.GraphicsComponent;
/******/ var __webpack_exports__GraphicsGroup = __nested_webpack_exports__.GraphicsGroup;
/******/ var __webpack_exports__GraphicsSystem = __nested_webpack_exports__.GraphicsSystem;
/******/ var __webpack_exports__HashColliderProxy = __nested_webpack_exports__.HashColliderProxy;
/******/ var __webpack_exports__HashGridCell = __nested_webpack_exports__.HashGridCell;
/******/ var __webpack_exports__HashGridProxy = __nested_webpack_exports__.HashGridProxy;
/******/ var __webpack_exports__HiddenEvent = __nested_webpack_exports__.HiddenEvent;
/******/ var __webpack_exports__HorizontalFirst = __nested_webpack_exports__.HorizontalFirst;
/******/ var __webpack_exports__ImageFiltering = __nested_webpack_exports__.ImageFiltering;
/******/ var __webpack_exports__ImageSource = __nested_webpack_exports__.ImageSource;
/******/ var __webpack_exports__ImageSourceAttributeConstants = __nested_webpack_exports__.ImageSourceAttributeConstants;
/******/ var __webpack_exports__ImageWrapping = __nested_webpack_exports__.ImageWrapping;
/******/ var __webpack_exports__InitializeEvent = __nested_webpack_exports__.InitializeEvent;
/******/ var __webpack_exports__InputHost = __nested_webpack_exports__.InputHost;
/******/ var __webpack_exports__InputMapper = __nested_webpack_exports__.InputMapper;
/******/ var __webpack_exports__IsometricEntityComponent = __nested_webpack_exports__.IsometricEntityComponent;
/******/ var __webpack_exports__IsometricEntitySystem = __nested_webpack_exports__.IsometricEntitySystem;
/******/ var __webpack_exports__IsometricMap = __nested_webpack_exports__.IsometricMap;
/******/ var __webpack_exports__IsometricTile = __nested_webpack_exports__.IsometricTile;
/******/ var __webpack_exports__KeyEvent = __nested_webpack_exports__.KeyEvent;
/******/ var __webpack_exports__Keyboard = __nested_webpack_exports__.Keyboard;
/******/ var __webpack_exports__Keys = __nested_webpack_exports__.Keys;
/******/ var __webpack_exports__KillEvent = __nested_webpack_exports__.KillEvent;
/******/ var __webpack_exports__Label = __nested_webpack_exports__.Label;
/******/ var __webpack_exports__LimitCameraBoundsStrategy = __nested_webpack_exports__.LimitCameraBoundsStrategy;
/******/ var __webpack_exports__Line = __nested_webpack_exports__.Line;
/******/ var __webpack_exports__LineSegment = __nested_webpack_exports__.LineSegment;
/******/ var __webpack_exports__Loader = __nested_webpack_exports__.Loader;
/******/ var __webpack_exports__LoaderEvents = __nested_webpack_exports__.LoaderEvents;
/******/ var __webpack_exports__LockCameraToActorAxisStrategy = __nested_webpack_exports__.LockCameraToActorAxisStrategy;
/******/ var __webpack_exports__LockCameraToActorStrategy = __nested_webpack_exports__.LockCameraToActorStrategy;
/******/ var __webpack_exports__LogLevel = __nested_webpack_exports__.LogLevel;
/******/ var __webpack_exports__Logger = __nested_webpack_exports__.Logger;
/******/ var __webpack_exports__Material = __nested_webpack_exports__.Material;
/******/ var __webpack_exports__Matrix = __nested_webpack_exports__.Matrix;
/******/ var __webpack_exports__MatrixLocations = __nested_webpack_exports__.MatrixLocations;
/******/ var __webpack_exports__MediaEvent = __nested_webpack_exports__.MediaEvent;
/******/ var __webpack_exports__Meet = __nested_webpack_exports__.Meet;
/******/ var __webpack_exports__MotionComponent = __nested_webpack_exports__.MotionComponent;
/******/ var __webpack_exports__MotionSystem = __nested_webpack_exports__.MotionSystem;
/******/ var __webpack_exports__MoveBy = __nested_webpack_exports__.MoveBy;
/******/ var __webpack_exports__MoveByWithOptions = __nested_webpack_exports__.MoveByWithOptions;
/******/ var __webpack_exports__MoveTo = __nested_webpack_exports__.MoveTo;
/******/ var __webpack_exports__MoveToWithOptions = __nested_webpack_exports__.MoveToWithOptions;
/******/ var __webpack_exports__NativePointerButton = __nested_webpack_exports__.NativePointerButton;
/******/ var __webpack_exports__NativeSoundEvent = __nested_webpack_exports__.NativeSoundEvent;
/******/ var __webpack_exports__NativeSoundProcessedEvent = __nested_webpack_exports__.NativeSoundProcessedEvent;
/******/ var __webpack_exports__NineSlice = __nested_webpack_exports__.NineSlice;
/******/ var __webpack_exports__NineSliceStretch = __nested_webpack_exports__.NineSliceStretch;
/******/ var __webpack_exports__None = __nested_webpack_exports__.None;
/******/ var __webpack_exports__Observable = __nested_webpack_exports__.Observable;
/******/ var __webpack_exports__OffscreenSystem = __nested_webpack_exports__.OffscreenSystem;
/******/ var __webpack_exports__Pair = __nested_webpack_exports__.Pair;
/******/ var __webpack_exports__ParallaxComponent = __nested_webpack_exports__.ParallaxComponent;
/******/ var __webpack_exports__ParallelActions = __nested_webpack_exports__.ParallelActions;
/******/ var __webpack_exports__Particle = __nested_webpack_exports__.Particle;
/******/ var __webpack_exports__ParticleEmitter = __nested_webpack_exports__.ParticleEmitter;
/******/ var __webpack_exports__ParticleRenderer = __nested_webpack_exports__.ParticleRenderer;
/******/ var __webpack_exports__ParticleTransform = __nested_webpack_exports__.ParticleTransform;
/******/ var __webpack_exports__PhysicsStats = __nested_webpack_exports__.PhysicsStats;
/******/ var __webpack_exports__PhysicsWorld = __nested_webpack_exports__.PhysicsWorld;
/******/ var __webpack_exports__PointerAbstraction = __nested_webpack_exports__.PointerAbstraction;
/******/ var __webpack_exports__PointerButton = __nested_webpack_exports__.PointerButton;
/******/ var __webpack_exports__PointerComponent = __nested_webpack_exports__.PointerComponent;
/******/ var __webpack_exports__PointerEvent = __nested_webpack_exports__.PointerEvent;
/******/ var __webpack_exports__PointerEventReceiver = __nested_webpack_exports__.PointerEventReceiver;
/******/ var __webpack_exports__PointerScope = __nested_webpack_exports__.PointerScope;
/******/ var __webpack_exports__PointerSystem = __nested_webpack_exports__.PointerSystem;
/******/ var __webpack_exports__PointerType = __nested_webpack_exports__.PointerType;
/******/ var __webpack_exports__Polygon = __nested_webpack_exports__.Polygon;
/******/ var __webpack_exports__PolygonCollider = __nested_webpack_exports__.PolygonCollider;
/******/ var __webpack_exports__Pool = __nested_webpack_exports__.Pool;
/******/ var __webpack_exports__PostCollisionEvent = __nested_webpack_exports__.PostCollisionEvent;
/******/ var __webpack_exports__PostDebugDrawEvent = __nested_webpack_exports__.PostDebugDrawEvent;
/******/ var __webpack_exports__PostDrawEvent = __nested_webpack_exports__.PostDrawEvent;
/******/ var __webpack_exports__PostFrameEvent = __nested_webpack_exports__.PostFrameEvent;
/******/ var __webpack_exports__PostKillEvent = __nested_webpack_exports__.PostKillEvent;
/******/ var __webpack_exports__PostTransformDrawEvent = __nested_webpack_exports__.PostTransformDrawEvent;
/******/ var __webpack_exports__PostUpdateEvent = __nested_webpack_exports__.PostUpdateEvent;
/******/ var __webpack_exports__PreCollisionEvent = __nested_webpack_exports__.PreCollisionEvent;
/******/ var __webpack_exports__PreDebugDrawEvent = __nested_webpack_exports__.PreDebugDrawEvent;
/******/ var __webpack_exports__PreDrawEvent = __nested_webpack_exports__.PreDrawEvent;
/******/ var __webpack_exports__PreFrameEvent = __nested_webpack_exports__.PreFrameEvent;
/******/ var __webpack_exports__PreKillEvent = __nested_webpack_exports__.PreKillEvent;
/******/ var __webpack_exports__PreLoadEvent = __nested_webpack_exports__.PreLoadEvent;
/******/ var __webpack_exports__PreTransformDrawEvent = __nested_webpack_exports__.PreTransformDrawEvent;
/******/ var __webpack_exports__PreUpdateEvent = __nested_webpack_exports__.PreUpdateEvent;
/******/ var __webpack_exports__Projection = __nested_webpack_exports__.Projection;
/******/ var __webpack_exports__QuadIndexBuffer = __nested_webpack_exports__.QuadIndexBuffer;
/******/ var __webpack_exports__QuadTree = __nested_webpack_exports__.QuadTree;
/******/ var __webpack_exports__Query = __nested_webpack_exports__.Query;
/******/ var __webpack_exports__QueryManager = __nested_webpack_exports__.QueryManager;
/******/ var __webpack_exports__RadiusAroundActorStrategy = __nested_webpack_exports__.RadiusAroundActorStrategy;
/******/ var __webpack_exports__Random = __nested_webpack_exports__.Random;
/******/ var __webpack_exports__Raster = __nested_webpack_exports__.Raster;
/******/ var __webpack_exports__Ray = __nested_webpack_exports__.Ray;
/******/ var __webpack_exports__RealisticSolver = __nested_webpack_exports__.RealisticSolver;
/******/ var __webpack_exports__Rectangle = __nested_webpack_exports__.Rectangle;
/******/ var __webpack_exports__RemoveEvent = __nested_webpack_exports__.RemoveEvent;
/******/ var __webpack_exports__RemovedComponent = __nested_webpack_exports__.RemovedComponent;
/******/ var __webpack_exports__Repeat = __nested_webpack_exports__.Repeat;
/******/ var __webpack_exports__RepeatForever = __nested_webpack_exports__.RepeatForever;
/******/ var __webpack_exports__Resolution = __nested_webpack_exports__.Resolution;
/******/ var __webpack_exports__Resource = __nested_webpack_exports__.Resource;
/******/ var __webpack_exports__ResourceEvents = __nested_webpack_exports__.ResourceEvents;
/******/ var __webpack_exports__RotateBy = __nested_webpack_exports__.RotateBy;
/******/ var __webpack_exports__RotateByWithOptions = __nested_webpack_exports__.RotateByWithOptions;
/******/ var __webpack_exports__RotateTo = __nested_webpack_exports__.RotateTo;
/******/ var __webpack_exports__RotateToWithOptions = __nested_webpack_exports__.RotateToWithOptions;
/******/ var __webpack_exports__RotationType = __nested_webpack_exports__.RotationType;
/******/ var __webpack_exports__ScaleBy = __nested_webpack_exports__.ScaleBy;
/******/ var __webpack_exports__ScaleByWithOptions = __nested_webpack_exports__.ScaleByWithOptions;
/******/ var __webpack_exports__ScaleTo = __nested_webpack_exports__.ScaleTo;
/******/ var __webpack_exports__ScaleToWithOptions = __nested_webpack_exports__.ScaleToWithOptions;
/******/ var __webpack_exports__Scene = __nested_webpack_exports__.Scene;
/******/ var __webpack_exports__SceneEvents = __nested_webpack_exports__.SceneEvents;
/******/ var __webpack_exports__Screen = __nested_webpack_exports__.Screen;
/******/ var __webpack_exports__ScreenAppender = __nested_webpack_exports__.ScreenAppender;
/******/ var __webpack_exports__ScreenElement = __nested_webpack_exports__.ScreenElement;
/******/ var __webpack_exports__ScreenEvents = __nested_webpack_exports__.ScreenEvents;
/******/ var __webpack_exports__ScreenShader = __nested_webpack_exports__.ScreenShader;
/******/ var __webpack_exports__ScrollPreventionMode = __nested_webpack_exports__.ScrollPreventionMode;
/******/ var __webpack_exports__Semaphore = __nested_webpack_exports__.Semaphore;
/******/ var __webpack_exports__SeparatingAxis = __nested_webpack_exports__.SeparatingAxis;
/******/ var __webpack_exports__SeparationInfo = __nested_webpack_exports__.SeparationInfo;
/******/ var __webpack_exports__Shader = __nested_webpack_exports__.Shader;
/******/ var __webpack_exports__Shape = __nested_webpack_exports__.Shape;
/******/ var __webpack_exports__Side = __nested_webpack_exports__.Side;
/******/ var __webpack_exports__Slide = __nested_webpack_exports__.Slide;
/******/ var __webpack_exports__SolverStrategy = __nested_webpack_exports__.SolverStrategy;
/******/ var __webpack_exports__Sound = __nested_webpack_exports__.Sound;
/******/ var __webpack_exports__SoundEvents = __nested_webpack_exports__.SoundEvents;
/******/ var __webpack_exports__SparseHashGrid = __nested_webpack_exports__.SparseHashGrid;
/******/ var __webpack_exports__SparseHashGridCollisionProcessor = __nested_webpack_exports__.SparseHashGridCollisionProcessor;
/******/ var __webpack_exports__SpatialPartitionStrategy = __nested_webpack_exports__.SpatialPartitionStrategy;
/******/ var __webpack_exports__Sprite = __nested_webpack_exports__.Sprite;
/******/ var __webpack_exports__SpriteFont = __nested_webpack_exports__.SpriteFont;
/******/ var __webpack_exports__SpriteSheet = __nested_webpack_exports__.SpriteSheet;
/******/ var __webpack_exports__StandardClock = __nested_webpack_exports__.StandardClock;
/******/ var __webpack_exports__StateMachine = __nested_webpack_exports__.StateMachine;
/******/ var __webpack_exports__StrategyContainer = __nested_webpack_exports__.StrategyContainer;
/******/ var __webpack_exports__Stream = __nested_webpack_exports__.Stream;
/******/ var __webpack_exports__System = __nested_webpack_exports__.System;
/******/ var __webpack_exports__SystemManager = __nested_webpack_exports__.SystemManager;
/******/ var __webpack_exports__SystemPriority = __nested_webpack_exports__.SystemPriority;
/******/ var __webpack_exports__SystemType = __nested_webpack_exports__.SystemType;
/******/ var __webpack_exports__TagQuery = __nested_webpack_exports__.TagQuery;
/******/ var __webpack_exports__TestClock = __nested_webpack_exports__.TestClock;
/******/ var __webpack_exports__Text = __nested_webpack_exports__.Text;
/******/ var __webpack_exports__TextAlign = __nested_webpack_exports__.TextAlign;
/******/ var __webpack_exports__TextureLoader = __nested_webpack_exports__.TextureLoader;
/******/ var __webpack_exports__Tile = __nested_webpack_exports__.Tile;
/******/ var __webpack_exports__TileMap = __nested_webpack_exports__.TileMap;
/******/ var __webpack_exports__TileMapEvents = __nested_webpack_exports__.TileMapEvents;
/******/ var __webpack_exports__TiledAnimation = __nested_webpack_exports__.TiledAnimation;
/******/ var __webpack_exports__TiledSprite = __nested_webpack_exports__.TiledSprite;
/******/ var __webpack_exports__Timer = __nested_webpack_exports__.Timer;
/******/ var __webpack_exports__Toaster = __nested_webpack_exports__.Toaster;
/******/ var __webpack_exports__Transform = __nested_webpack_exports__.Transform;
/******/ var __webpack_exports__TransformComponent = __nested_webpack_exports__.TransformComponent;
/******/ var __webpack_exports__Transition = __nested_webpack_exports__.Transition;
/******/ var __webpack_exports__TreeNode = __nested_webpack_exports__.TreeNode;
/******/ var __webpack_exports__Trigger = __nested_webpack_exports__.Trigger;
/******/ var __webpack_exports__TriggerEvents = __nested_webpack_exports__.TriggerEvents;
/******/ var __webpack_exports__TwoPI = __nested_webpack_exports__.TwoPI;
/******/ var __webpack_exports__Util = __nested_webpack_exports__.Util;
/******/ var __webpack_exports__Vector = __nested_webpack_exports__.Vector;
/******/ var __webpack_exports__VectorView = __nested_webpack_exports__.VectorView;
/******/ var __webpack_exports__VertexBuffer = __nested_webpack_exports__.VertexBuffer;
/******/ var __webpack_exports__VertexLayout = __nested_webpack_exports__.VertexLayout;
/******/ var __webpack_exports__VerticalFirst = __nested_webpack_exports__.VerticalFirst;
/******/ var __webpack_exports__VisibleEvent = __nested_webpack_exports__.VisibleEvent;
/******/ var __webpack_exports__WebAudio = __nested_webpack_exports__.WebAudio;
/******/ var __webpack_exports__WebAudioInstance = __nested_webpack_exports__.WebAudioInstance;
/******/ var __webpack_exports__WheelDeltaMode = __nested_webpack_exports__.WheelDeltaMode;
/******/ var __webpack_exports__WheelEvent = __nested_webpack_exports__.WheelEvent;
/******/ var __webpack_exports__World = __nested_webpack_exports__.World;
/******/ var __webpack_exports__approximatelyEqual = __nested_webpack_exports__.approximatelyEqual;
/******/ var __webpack_exports__assert = __nested_webpack_exports__.assert;
/******/ var __webpack_exports__canonicalizeAngle = __nested_webpack_exports__.canonicalizeAngle;
/******/ var __webpack_exports__clamp = __nested_webpack_exports__.clamp;
/******/ var __webpack_exports__coroutine = __nested_webpack_exports__.coroutine;
/******/ var __webpack_exports__createId = __nested_webpack_exports__.createId;
/******/ var __webpack_exports__frac = __nested_webpack_exports__.frac;
/******/ var __webpack_exports__getDefaultPhysicsConfig = __nested_webpack_exports__.getDefaultPhysicsConfig;
/******/ var __webpack_exports__hasGraphicsTick = __nested_webpack_exports__.hasGraphicsTick;
/******/ var __webpack_exports__hasOnAdd = __nested_webpack_exports__.hasOnAdd;
/******/ var __webpack_exports__hasOnInitialize = __nested_webpack_exports__.hasOnInitialize;
/******/ var __webpack_exports__hasOnPostUpdate = __nested_webpack_exports__.hasOnPostUpdate;
/******/ var __webpack_exports__hasOnPreUpdate = __nested_webpack_exports__.hasOnPreUpdate;
/******/ var __webpack_exports__hasOnRemove = __nested_webpack_exports__.hasOnRemove;
/******/ var __webpack_exports__hasPostDraw = __nested_webpack_exports__.hasPostDraw;
/******/ var __webpack_exports__hasPreDraw = __nested_webpack_exports__.hasPreDraw;
/******/ var __webpack_exports__has_add = __nested_webpack_exports__.has_add;
/******/ var __webpack_exports__has_initialize = __nested_webpack_exports__.has_initialize;
/******/ var __webpack_exports__has_postupdate = __nested_webpack_exports__.has_postupdate;
/******/ var __webpack_exports__has_preupdate = __nested_webpack_exports__.has_preupdate;
/******/ var __webpack_exports__has_remove = __nested_webpack_exports__.has_remove;
/******/ var __webpack_exports__inverseLerp = __nested_webpack_exports__.inverseLerp;
/******/ var __webpack_exports__inverseLerpVector = __nested_webpack_exports__.inverseLerpVector;
/******/ var __webpack_exports__isActor = __nested_webpack_exports__.isActor;
/******/ var __webpack_exports__isAddedComponent = __nested_webpack_exports__.isAddedComponent;
/******/ var __webpack_exports__isComponentCtor = __nested_webpack_exports__.isComponentCtor;
/******/ var __webpack_exports__isLoaderConstructor = __nested_webpack_exports__.isLoaderConstructor;
/******/ var __webpack_exports__isMoveByOptions = __nested_webpack_exports__.isMoveByOptions;
/******/ var __webpack_exports__isMoveToOptions = __nested_webpack_exports__.isMoveToOptions;
/******/ var __webpack_exports__isRemovedComponent = __nested_webpack_exports__.isRemovedComponent;
/******/ var __webpack_exports__isRotateByOptions = __nested_webpack_exports__.isRotateByOptions;
/******/ var __webpack_exports__isRotateToOptions = __nested_webpack_exports__.isRotateToOptions;
/******/ var __webpack_exports__isScaleByOptions = __nested_webpack_exports__.isScaleByOptions;
/******/ var __webpack_exports__isScaleToOptions = __nested_webpack_exports__.isScaleToOptions;
/******/ var __webpack_exports__isSceneConstructor = __nested_webpack_exports__.isSceneConstructor;
/******/ var __webpack_exports__isScreenElement = __nested_webpack_exports__.isScreenElement;
/******/ var __webpack_exports__isSystemConstructor = __nested_webpack_exports__.isSystemConstructor;
/******/ var __webpack_exports__lerp = __nested_webpack_exports__.lerp;
/******/ var __webpack_exports__lerpAngle = __nested_webpack_exports__.lerpAngle;
/******/ var __webpack_exports__lerpVector = __nested_webpack_exports__.lerpVector;
/******/ var __webpack_exports__maxMessages = __nested_webpack_exports__.maxMessages;
/******/ var __webpack_exports__nextActionId = __nested_webpack_exports__.nextActionId;
/******/ var __webpack_exports__obsolete = __nested_webpack_exports__.obsolete;
/******/ var __webpack_exports__parseImageFiltering = __nested_webpack_exports__.parseImageFiltering;
/******/ var __webpack_exports__parseImageWrapping = __nested_webpack_exports__.parseImageWrapping;
/******/ var __webpack_exports__pixelSnapEpsilon = __nested_webpack_exports__.pixelSnapEpsilon;
/******/ var __webpack_exports__randomInRange = __nested_webpack_exports__.randomInRange;
/******/ var __webpack_exports__randomIntInRange = __nested_webpack_exports__.randomIntInRange;
/******/ var __webpack_exports__range = __nested_webpack_exports__.range;
/******/ var __webpack_exports__remap = __nested_webpack_exports__.remap;
/******/ var __webpack_exports__remapVector = __nested_webpack_exports__.remapVector;
/******/ var __webpack_exports__resetObsoleteCounter = __nested_webpack_exports__.resetObsoleteCounter;
/******/ var __webpack_exports__sign = __nested_webpack_exports__.sign;
/******/ var __webpack_exports__toDegrees = __nested_webpack_exports__.toDegrees;
/******/ var __webpack_exports__toRadians = __nested_webpack_exports__.toRadians;
/******/ var __webpack_exports__vec = __nested_webpack_exports__.vec;
/******/ var __webpack_exports__webgl = __nested_webpack_exports__.webgl;
/******/ 
/******/ 

//# sourceMappingURL=excalibur.development.js.map

/***/ }),

/***/ "./sample/config.ts":
/*!**************************!*\
  !*** ./sample/config.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config)
/* harmony export */ });
const Config = {
    PlayerSpeed: 16 * 2, // pixels/sec
    PlayerFrameSpeed: 200, // ms
};


/***/ }),

/***/ "./sample/player.ts":
/*!**************************!*\
  !*** ./sample/player.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Player: () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resources */ "./sample/resources.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./sample/config.ts");



class Player extends excalibur__WEBPACK_IMPORTED_MODULE_2__.Actor {
    constructor(args) {
        super({
            ...args,
            collisionType: excalibur__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Active
        });
    }
    onInitialize(engine) {
        const playerSpriteSheet = excalibur__WEBPACK_IMPORTED_MODULE_2__.SpriteSheet.fromImageSource({
            image: _resources__WEBPACK_IMPORTED_MODULE_0__.Resources.HeroSpriteSheetPng,
            grid: {
                spriteWidth: 16,
                spriteHeight: 16,
                rows: 8,
                columns: 8
            }
        });
        const leftIdle = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 1), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 1), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 1), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 1), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('left-idle', leftIdle);
        const rightIdle = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 2), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 2), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 2), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 2), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('right-idle', rightIdle);
        const upIdle = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 3), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 3), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 3), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 3), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('up-idle', upIdle);
        const downIdle = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 0), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 0), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 0), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 0), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('down-idle', downIdle);
        const leftWalk = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 5), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 5), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 5), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 5), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('left-walk', leftWalk);
        const rightWalk = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 6), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 6), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 6), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 6), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('right-walk', rightWalk);
        const upWalk = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 7), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 7), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 7), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 7), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('up-walk', upWalk);
        const downWalk = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Animation({
            frames: [
                { graphic: playerSpriteSheet.getSprite(0, 4), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(1, 4), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(2, 4), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
                { graphic: playerSpriteSheet.getSprite(3, 4), duration: _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerFrameSpeed },
            ]
        });
        this.graphics.add('down-walk', downWalk);
    }
    onPreUpdate(engine, elapsedMs) {
        this.vel = excalibur__WEBPACK_IMPORTED_MODULE_2__.Vector.Zero;
        this.graphics.use('down-idle');
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_2__.Keys.ArrowRight)) {
            this.vel = excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(_config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerSpeed, 0);
            this.graphics.use('right-walk');
        }
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_2__.Keys.ArrowLeft)) {
            this.vel = excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(-_config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerSpeed, 0);
            this.graphics.use('left-walk');
        }
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_2__.Keys.ArrowUp)) {
            this.vel = excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(0, -_config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerSpeed);
            this.graphics.use('up-walk');
        }
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_2__.Keys.ArrowDown)) {
            this.vel = excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(0, _config__WEBPACK_IMPORTED_MODULE_1__.Config.PlayerSpeed);
            this.graphics.use('down-walk');
        }
    }
}


/***/ }),

/***/ "./sample/resources.ts":
/*!*****************************!*\
  !*** ./sample/resources.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Resources: () => (/* binding */ Resources),
/* harmony export */   loader: () => (/* binding */ loader)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _excalibur_ldtk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @excalibur-ldtk */ "./src/index.ts");


const Resources = {
    HeroSpriteSheetPng: new excalibur__WEBPACK_IMPORTED_MODULE_1__.ImageSource('./Solaria Demo Pack Update 03/Solaria Demo Pack Update 03/16x16/Sprites/Hero 01.png'),
    LdtkResource: new _excalibur_ldtk__WEBPACK_IMPORTED_MODULE_0__.LdtkResource('./spacing-padding/spacing-padding.ldtk', {
        useTilemapCameraStrategy: true,
        useMapBackgroundColor: true,
    }),
    LdtkAutoTile: new _excalibur_ldtk__WEBPACK_IMPORTED_MODULE_0__.LdtkResource('./autotile/autotile.ldtk', {
        useMapBackgroundColor: true,
    }),
    LdtkPureAutoTile: new _excalibur_ldtk__WEBPACK_IMPORTED_MODULE_0__.LdtkResource('./dsml1/dsml1.ldtk', {
        useMapBackgroundColor: true,
    })
};
const loader = new excalibur__WEBPACK_IMPORTED_MODULE_1__.Loader();
for (let resource of Object.values(Resources)) {
    loader.addResource(resource);
}


/***/ }),

/***/ "./src/entity-layer.ts":
/*!*****************************!*\
  !*** ./src/entity-layer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntityLayer: () => (/* binding */ EntityLayer)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");

class EntityLayer {
    constructor(level, ldtkLayer, resource, order) {
        var _a, _b;
        this.ldtkLayer = ldtkLayer;
        this.resource = resource;
        this.order = order;
        this.entities = [];
        this.ldtkToEntity = new Map();
        this.entityToLdtk = new Map();
        this.worldPos = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(level.ldtkLevel.worldX, level.ldtkLevel.worldY);
        this.offset = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(ldtkLayer.__pxTotalOffsetX, ldtkLayer.__pxTotalOffsetY);
        if (ldtkLayer.entityInstances) {
            for (let entity of ldtkLayer.entityInstances) {
                const entityMetadata = resource.projectMetadata.defs.entities.find(e => {
                    return e.identifier === entity.__identifier;
                });
                if (resource.factories.has(entity.__identifier)) {
                    const factory = resource.factories.get(entity.__identifier);
                    if (factory) {
                        const newEntity = factory({
                            type: entity.__identifier,
                            worldPos: (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(entity.px[0], entity.px[1]).add(this.worldPos.add(this.offset)),
                            entity,
                            definition: entityMetadata,
                            layer: this,
                        });
                        if (newEntity) {
                            this.entities.push(newEntity);
                            this.ldtkToEntity.set(entity, newEntity);
                            this.entityToLdtk.set(newEntity, entity);
                        }
                    }
                }
                else {
                    const actor = new excalibur__WEBPACK_IMPORTED_MODULE_0__.Actor({
                        name: entity.__identifier,
                        pos: (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(entity.px[0], entity.px[1]).add(this.worldPos.add(this.offset)),
                        width: entity.width,
                        height: entity.height,
                        anchor: (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)((_a = entityMetadata === null || entityMetadata === void 0 ? void 0 : entityMetadata.pivotX) !== null && _a !== void 0 ? _a : 0, (_b = entityMetadata === null || entityMetadata === void 0 ? void 0 : entityMetadata.pivotY) !== null && _b !== void 0 ? _b : 0),
                        z: order
                    });
                    if (entity.__tile) {
                        const ts = resource.tilesets.get(entity.__tile.tilesetUid);
                        if (ts) {
                            const tsxCoord = Math.floor(entity.__tile.x / entity.__tile.w);
                            const tsyCoord = Math.floor(entity.__tile.y / entity.__tile.h);
                            const sprite = ts.spritesheet.getSprite(tsxCoord, tsyCoord);
                            if (sprite) {
                                actor.graphics.use(sprite);
                            }
                        }
                    }
                    this.entities.push(actor);
                    this.ldtkToEntity.set(entity, actor);
                    this.entityToLdtk.set(actor, entity);
                }
            }
        }
    }
    runFactories() {
        for (let entity of this.ldtkLayer.entityInstances) {
            const factory = this.resource.factories.get(entity.__identifier);
            if (!factory) {
                continue;
            }
            const entityMetadata = this.resource.projectMetadata.defs.entities.find(e => {
                return e.identifier === entity.__identifier;
            });
            const newEntity = factory({
                type: entity.__identifier,
                worldPos: (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(entity.px[0], entity.px[1]).add(this.worldPos.add(this.offset)),
                entity,
                definition: entityMetadata,
                layer: this,
            });
            if (newEntity) {
                // remove pre-existing entity (e.g. the default actor created for the entity placement)
                const preExisting = this.ldtkToEntity.get(entity);
                if (preExisting) {
                    const index = this.entities.indexOf(preExisting);
                    if (index > -1) {
                        this.entities.splice(index, 1);
                        this.ldtkToEntity.delete(entity);
                        this.entityToLdtk.delete(preExisting);
                    }
                }
                this.entities.push(newEntity);
                this.ldtkToEntity.set(entity, newEntity);
                this.entityToLdtk.set(newEntity, entity);
            }
        }
    }
    getEntitiesByIdentifier(identifier) {
        const ldtkEntities = this.getLdtkEntitiesByIdentifier(identifier);
        let results = [];
        for (const ldtk of ldtkEntities) {
            const maybeEntity = this.ldtkToEntity.get(ldtk);
            if (maybeEntity) {
                results.push(maybeEntity);
            }
        }
        return results;
    }
    getEntitiesByField(fieldIdentifier, value) {
        const ldtkEntities = this.getLdtkEntitiesByField(fieldIdentifier, value);
        let results = [];
        for (const ldtk of ldtkEntities) {
            const maybeEntity = this.ldtkToEntity.get(ldtk);
            if (maybeEntity) {
                results.push(maybeEntity);
            }
        }
        return results;
    }
    /**
     * Search layer for entities that match an identifier (case insensitive)
     * @param identifier
     * @returns
     */
    getLdtkEntitiesByIdentifier(identifier) {
        return this.ldtkLayer.entityInstances.filter(e => e.__identifier.toLocaleLowerCase() === identifier.toLowerCase());
    }
    /**
     * Search layer for entities that match a field and optionally a value (both case insensitive)
     * @param fieldIdentifier
     * @param value
     */
    getLdtkEntitiesByField(fieldIdentifier, value) {
        return this.ldtkLayer.entityInstances.filter(e => {
            if (value !== undefined) {
                let normalizedValue = value;
                if (typeof value === 'string') {
                    normalizedValue = value.toLocaleLowerCase();
                }
                const field = e.fieldInstances.find(f => f.__identifier.toLocaleLowerCase() === fieldIdentifier.toLocaleLowerCase());
                if (field) {
                    return field.__value === normalizedValue;
                }
                return false;
            }
            else {
                return !!e.fieldInstances.find(f => f.__identifier.toLocaleLowerCase() === fieldIdentifier.toLocaleLowerCase());
            }
        });
    }
}


/***/ }),

/***/ "./src/file-loader.ts":
/*!****************************!*\
  !*** ./src/file-loader.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchLoader: () => (/* binding */ FetchLoader)
/* harmony export */ });
const FetchLoader = async (path, contentType) => {
    const response = await fetch(path);
    switch (contentType.toLowerCase()) {
        case 'xml': return await response.text();
        case 'json': return await response.json();
        default: return await response.text();
    }
};


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntityLayer: () => (/* reexport safe */ _entity_layer__WEBPACK_IMPORTED_MODULE_1__.EntityLayer),
/* harmony export */   FetchLoader: () => (/* reexport safe */ _file_loader__WEBPACK_IMPORTED_MODULE_2__.FetchLoader),
/* harmony export */   IntGridLayer: () => (/* reexport safe */ _intgrid_layer__WEBPACK_IMPORTED_MODULE_3__.IntGridLayer),
/* harmony export */   LdtkEntityDefinition: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkEntityDefinition),
/* harmony export */   LdtkEntityInstance: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkEntityInstance),
/* harmony export */   LdtkLayerDefinition: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkLayerDefinition),
/* harmony export */   LdtkLayerInstance: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkLayerInstance),
/* harmony export */   LdtkLevel: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkLevel),
/* harmony export */   LdtkProjectMetadata: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_10__.LdtkProjectMetadata),
/* harmony export */   LdtkResource: () => (/* reexport safe */ _ldtk_resource__WEBPACK_IMPORTED_MODULE_0__.LdtkResource),
/* harmony export */   Level: () => (/* reexport safe */ _level__WEBPACK_IMPORTED_MODULE_5__.Level),
/* harmony export */   LevelResource: () => (/* reexport safe */ _level_resource__WEBPACK_IMPORTED_MODULE_4__.LevelResource),
/* harmony export */   LoaderCache: () => (/* reexport safe */ _loader_cache__WEBPACK_IMPORTED_MODULE_6__.LoaderCache),
/* harmony export */   TileLayer: () => (/* reexport safe */ _tile_layer__WEBPACK_IMPORTED_MODULE_8__.TileLayer),
/* harmony export */   Tileset: () => (/* reexport safe */ _tileset__WEBPACK_IMPORTED_MODULE_9__.Tileset),
/* harmony export */   filenameFromPath: () => (/* reexport safe */ _path_util__WEBPACK_IMPORTED_MODULE_7__.filenameFromPath),
/* harmony export */   mapPath: () => (/* reexport safe */ _path_util__WEBPACK_IMPORTED_MODULE_7__.mapPath),
/* harmony export */   pathInMap: () => (/* reexport safe */ _path_util__WEBPACK_IMPORTED_MODULE_7__.pathInMap),
/* harmony export */   pathRelativeToBase: () => (/* reexport safe */ _path_util__WEBPACK_IMPORTED_MODULE_7__.pathRelativeToBase)
/* harmony export */ });
/* harmony import */ var _ldtk_resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ldtk-resource */ "./src/ldtk-resource.ts");
/* harmony import */ var _entity_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity-layer */ "./src/entity-layer.ts");
/* harmony import */ var _file_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-loader */ "./src/file-loader.ts");
/* harmony import */ var _intgrid_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./intgrid-layer */ "./src/intgrid-layer.ts");
/* harmony import */ var _level_resource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./level-resource */ "./src/level-resource.ts");
/* harmony import */ var _level__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./level */ "./src/level.ts");
/* harmony import */ var _loader_cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loader-cache */ "./src/loader-cache.ts");
/* harmony import */ var _path_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path-util */ "./src/path-util.ts");
/* harmony import */ var _tile_layer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tile-layer */ "./src/tile-layer.ts");
/* harmony import */ var _tileset__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tileset */ "./src/tileset.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types */ "./src/types.ts");













/***/ }),

/***/ "./src/intgrid-layer.ts":
/*!******************************!*\
  !*** ./src/intgrid-layer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntGridLayer: () => (/* binding */ IntGridLayer)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");

class IntGridLayer {
    constructor(level, ldtkLayer, resource, order) {
        var _a, _b, _c, _d;
        this.order = order;
        this.worldPos = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(level.ldtkLevel.worldX, level.ldtkLevel.worldY);
        this.offset = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(ldtkLayer.__pxTotalOffsetX, ldtkLayer.__pxTotalOffsetY);
        this.ldtkLayer = ldtkLayer;
        if (ldtkLayer.intGridCsv.length || ldtkLayer.autoLayerTiles.length) {
            const rows = ldtkLayer.__cHei;
            const columns = ldtkLayer.__cWid;
            this.tilemap = new excalibur__WEBPACK_IMPORTED_MODULE_0__.TileMap({
                name: ldtkLayer.__identifier,
                pos: this.worldPos.add(this.offset),
                tileWidth: ldtkLayer.__gridSize,
                tileHeight: ldtkLayer.__gridSize,
                rows,
                columns,
            });
            this.tilemap.z = order;
            const graphics = this.tilemap.get(excalibur__WEBPACK_IMPORTED_MODULE_0__.GraphicsComponent);
            graphics.isVisible = ldtkLayer.visible;
            // find the intgrid metadata
            const layerMetadata = resource.projectMetadata.defs.layers.find(l => {
                return ldtkLayer.__identifier === l.identifier;
            });
            if (layerMetadata) {
                const solidValue = layerMetadata.intGridValues.find(val => {
                    var _a;
                    return ((_a = val === null || val === void 0 ? void 0 : val.identifier) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === 'solid';
                });
                for (let i = 0; i < ldtkLayer.intGridCsv.length; i++) {
                    const xCoord = i % columns;
                    const yCoord = Math.floor(i / columns);
                    const tile = this.tilemap.getTile(xCoord, yCoord);
                    if (solidValue && ldtkLayer.intGridCsv[i] === solidValue.value) {
                        tile.solid = true;
                    }
                    // TODO might be a mistake to treat 1 as solid if there isn't a labelled solid
                    if (!solidValue && ldtkLayer.intGridCsv[i] === 1) {
                        tile.solid = true;
                    }
                }
                if (ldtkLayer.__tilesetDefUid) {
                    this.tileset = resource.tilesets.get(ldtkLayer.__tilesetDefUid);
                    for (let i = 0; i < ldtkLayer.autoLayerTiles.length; i++) {
                        const tile = ldtkLayer.autoLayerTiles[i];
                        const xCoord = Math.floor(tile.px[0] / ldtkLayer.__gridSize);
                        const yCoord = Math.floor(tile.px[1] / ldtkLayer.__gridSize);
                        const exTile = this.tilemap.getTile(xCoord, yCoord);
                        if (exTile && this.tileset) {
                            const tsxCoord = Math.floor((tile.src[0] - ((_a = this.tileset.ldtkTileset.padding) !== null && _a !== void 0 ? _a : 0)) / (this.tileset.ldtkTileset.tileGridSize + ((_b = this.tileset.ldtkTileset.spacing) !== null && _b !== void 0 ? _b : 0)));
                            const tsyCoord = Math.floor((tile.src[1] - ((_c = this.tileset.ldtkTileset.padding) !== null && _c !== void 0 ? _c : 0)) / (this.tileset.ldtkTileset.tileGridSize + ((_d = this.tileset.ldtkTileset.spacing) !== null && _d !== void 0 ? _d : 0)));
                            // Bit 0 toggles x flip
                            // Bit 1 toggles 1 flip
                            // Examples: f=0 (no flip), f=1 (X flip only), f=2 (Y flip only), f=3 (both flips)
                            const flipHorizontal = !!(tile.f & 0b01);
                            const flipVertical = !!(tile.f & 0b10);
                            let sprite = this.tileset.spritesheet.getSprite(tsxCoord, tsyCoord);
                            if (flipHorizontal || flipVertical) {
                                sprite = sprite.clone();
                                sprite.flipHorizontal = flipHorizontal;
                                sprite.flipVertical = flipVertical;
                            }
                            if (sprite) {
                                exTile.addGraphic(sprite);
                            }
                            else {
                                console.error('Could not find sprite in LDtk spritesheet at', tsxCoord, tsyCoord);
                            }
                        }
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/ldtk-resource.ts":
/*!******************************!*\
  !*** ./src/ldtk-resource.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LdtkResource: () => (/* binding */ LdtkResource)
/* harmony export */ });
/* harmony import */ var _tile_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile-layer */ "./src/tile-layer.ts");
/* harmony import */ var _path_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-util */ "./src/path-util.ts");
/* harmony import */ var _file_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-loader */ "./src/file-loader.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./src/types.ts");
/* harmony import */ var compare_versions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! compare-versions */ "./node_modules/compare-versions/lib/esm/compare.js");
/* harmony import */ var _loader_cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-cache */ "./src/loader-cache.ts");
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _level_resource__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./level-resource */ "./src/level-resource.ts");
/* harmony import */ var _tileset__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tileset */ "./src/tileset.ts");
/* harmony import */ var _level__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./level */ "./src/level.ts");
/* harmony import */ var _entity_layer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./entity-layer */ "./src/entity-layer.ts");
/* harmony import */ var _intgrid_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./intgrid-layer */ "./src/intgrid-layer.ts");












class LdtkResource {
    constructor(path, options) {
        this.path = path;
        this.tilesets = new Map();
        this.levels = new Map();
        this.levelsByName = new Map();
        this.factories = new Map();
        this.fileLoader = _file_loader__WEBPACK_IMPORTED_MODULE_2__.FetchLoader;
        this._imageLoader = new _loader_cache__WEBPACK_IMPORTED_MODULE_4__.LoaderCache(excalibur__WEBPACK_IMPORTED_MODULE_10__.ImageSource);
        this._levelLoader = new _loader_cache__WEBPACK_IMPORTED_MODULE_4__.LoaderCache(_level_resource__WEBPACK_IMPORTED_MODULE_5__.LevelResource);
        this.startZIndex = 0;
        this.textQuality = 4;
        this.useExcaliburWiring = true;
        this.useMapBackgroundColor = false;
        this.useTilemapCameraStrategy = false;
        this.headless = false;
        this.strict = true;
        const { useExcaliburWiring, useTilemapCameraStrategy, entityIdentifierFactories, pathMap, useMapBackgroundColor, fileLoader, strict, headless, startZIndex } = { ...options };
        this.strict = strict !== null && strict !== void 0 ? strict : this.strict;
        this.headless = headless !== null && headless !== void 0 ? headless : this.headless;
        this.useExcaliburWiring = useExcaliburWiring !== null && useExcaliburWiring !== void 0 ? useExcaliburWiring : this.useExcaliburWiring;
        this.useTilemapCameraStrategy = useTilemapCameraStrategy !== null && useTilemapCameraStrategy !== void 0 ? useTilemapCameraStrategy : this.useTilemapCameraStrategy;
        this.useMapBackgroundColor = useMapBackgroundColor !== null && useMapBackgroundColor !== void 0 ? useMapBackgroundColor : this.useMapBackgroundColor;
        this.startZIndex = startZIndex !== null && startZIndex !== void 0 ? startZIndex : this.startZIndex;
        this.fileLoader = fileLoader !== null && fileLoader !== void 0 ? fileLoader : this.fileLoader;
        this.pathMap = pathMap;
        for (const key in entityIdentifierFactories) {
            this.registerEntityIdentifierFactory(key, entityIdentifierFactories[key]);
        }
    }
    async load() {
        var _a;
        const data = await this.fileLoader(this.path, 'json');
        if (this.strict) {
            try {
                this.projectMetadata = _types__WEBPACK_IMPORTED_MODULE_3__.LdtkProjectMetadata.parse(data);
            }
            catch (e) {
                console.error(`Could not parse LDtk map from location ${this.path}.\nExcalibur only supports the latest version of LDtk formats as of the plugin's release.`);
                console.error(`Is your map file corrupted or being interpreted as the wrong type?`);
                throw e;
            }
        }
        else {
            this.projectMetadata = data;
        }
        if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_11__.compare)(LdtkResource.supportedLdtkVersion, (_a = this.projectMetadata.jsonVersion) !== null && _a !== void 0 ? _a : '0.0.0', ">")) {
            console.warn(`The excalibur ldtk plugin officially supports ${LdtkResource.supportedLdtkVersion}+, the current map has LDtk version ${this.projectMetadata.jsonVersion}`);
        }
        // iterate through the defs
        // load the tilesets
        const imagesToLoad = [];
        for (let tileset of this.projectMetadata.defs.tilesets) {
            if (tileset.relPath) {
                const imagePath = (0,_path_util__WEBPACK_IMPORTED_MODULE_1__.pathRelativeToBase)(this.path, tileset.relPath, this.pathMap);
                const image = this._imageLoader.getOrAdd(imagePath);
                const friendlyTileset = new _tileset__WEBPACK_IMPORTED_MODULE_6__.Tileset({
                    image,
                    ldtkTileset: tileset
                });
                this.tilesets.set(tileset.uid, friendlyTileset);
            }
            else {
                if (tileset.identifier !== 'Internal_Icons') {
                    console.warn(`No tileset image provided for ${tileset.identifier}`);
                }
            }
        }
        // iterate through the levels
        // load the level metadata
        for (let level of this.projectMetadata.levels) {
            if (level.externalRelPath) {
                // external levels
                const levelPath = (0,_path_util__WEBPACK_IMPORTED_MODULE_1__.pathRelativeToBase)(this.path, level.externalRelPath, this.pathMap);
                this._levelLoader.getOrAdd(levelPath, this, {
                    headless: this.headless,
                    strict: this.strict,
                    fileLoader: this.fileLoader,
                    imageLoader: this._imageLoader,
                    pathMap: this.pathMap
                });
            }
            else {
                // embedded levels
                const friendlyLevel = new _level__WEBPACK_IMPORTED_MODULE_7__.Level(level, this);
                this.levels.set(level.uid, friendlyLevel);
                this.levelsByName.set(level.identifier.toLowerCase(), friendlyLevel);
            }
        }
        await Promise.all([this._imageLoader.load(), this._levelLoader.load()]);
        this._levelLoader.values().forEach(level => {
            this.levels.set(level.data.ldtkLevel.uid, level.data);
            this.levelsByName.set(level.data.ldtkLevel.identifier.toLowerCase(), level.data);
        });
        return this.data = this.projectMetadata;
    }
    ;
    isLoaded() {
        return !!this.data;
    }
    registerEntityIdentifierFactory(ldtkEntityIdentifier, factory) {
        this.factories.set(ldtkEntityIdentifier, factory);
    }
    registerEntityIdentifierFactories(factories) {
        for (const key in factories) {
            this.registerEntityIdentifierFactory(key, factories[key]);
        }
    }
    /**
     * Get a level by identifier
     * @param identifier
     * @returns
     */
    getLevel(identifier) {
        return this.levelsByName.get(identifier.toLowerCase());
    }
    /**
     * Get the entity layers, optionally provide a level identifier to filter to
     * @param levelIdentifier
     */
    getEntityLayers(levelIdentifier) {
        let results = [];
        if (levelIdentifier) {
            const level = this.getLevel(levelIdentifier);
            if (level) {
                for (let layer of level.layers) {
                    if (layer instanceof _entity_layer__WEBPACK_IMPORTED_MODULE_8__.EntityLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        else {
            for (const level of this.levels.values()) {
                for (let layer of level.layers) {
                    if (layer instanceof _entity_layer__WEBPACK_IMPORTED_MODULE_8__.EntityLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        return results;
    }
    getTileLayers(identifier) {
        let results = [];
        if (identifier) {
            const level = this.getLevel(identifier);
            if (level) {
                for (let layer of level.layers) {
                    if (layer instanceof _tile_layer__WEBPACK_IMPORTED_MODULE_0__.TileLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        else {
            for (const level of this.levels.values()) {
                for (let layer of level.layers) {
                    if (layer instanceof _tile_layer__WEBPACK_IMPORTED_MODULE_0__.TileLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        return results;
    }
    getIntGridLayers(identifier) {
        let results = [];
        if (identifier) {
            const level = this.getLevel(identifier);
            if (level) {
                for (let layer of level.layers) {
                    if (layer instanceof _intgrid_layer__WEBPACK_IMPORTED_MODULE_9__.IntGridLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        else {
            for (const level of this.levels.values()) {
                for (let layer of level.layers) {
                    if (layer instanceof _intgrid_layer__WEBPACK_IMPORTED_MODULE_9__.IntGridLayer) {
                        results.push(layer);
                    }
                }
            }
        }
        return results;
    }
    /**
     * Search layer for entities that match an identifier (case insensitive)
     * @param identifier
     * @returns
     */
    getLdtkEntitiesByIdentifier(identifier, levels) {
        let results = [];
        const levelsToSearch = levels !== null && levels !== void 0 ? levels : Array.from(this.levels.values()).map(l => l.ldtkLevel.identifier);
        for (const level of levelsToSearch) {
            const layers = this.getEntityLayers(level);
            for (let layer of layers) {
                results = results.concat(layer.getLdtkEntitiesByIdentifier(identifier));
            }
        }
        return results;
    }
    /**
     * Search levels for ldtk entities that match a field and optionally a value (both case insensitive)
     * @param fieldIdentifier
     * @param value
     */
    getLdtkEntitiesByField(fieldIdentifier, value, levels) {
        let results = [];
        const levelsToSearch = levels !== null && levels !== void 0 ? levels : Array.from(this.levels.values()).map(l => l.ldtkLevel.identifier);
        for (const level of levelsToSearch) {
            const layers = this.getEntityLayers(level);
            for (let layer of layers) {
                results = results.concat(layer.getLdtkEntitiesByField(fieldIdentifier, value));
            }
        }
        return results;
    }
    /**
     * Search levels for excalibur entities that match an identifier (case insensitive)
     * @param identifier
     * @param levels
     */
    getEntitiesByIdentifier(identifier, levels) {
        let results = [];
        const levelsToSearch = levels !== null && levels !== void 0 ? levels : Array.from(this.levels.values()).map(l => l.ldtkLevel.identifier);
        for (const level of levelsToSearch) {
            const layers = this.getEntityLayers(level);
            for (let layer of layers) {
                results = results.concat(layer.getEntitiesByIdentifier(identifier));
            }
        }
        return results;
    }
    /**
     * Search levels for excalibur entities that match a field and optionally a value (both case insensitive)
     * @param fieldIdentifier
     * @param value
     * @param levels
     */
    getEntitiesByField(fieldIdentifier, value, levels) {
        let results = [];
        const levelsToSearch = levels !== null && levels !== void 0 ? levels : Array.from(this.levels.values()).map(l => l.ldtkLevel.identifier);
        for (const level of levelsToSearch) {
            const layers = this.getEntityLayers(level);
            for (let layer of layers) {
                results = results.concat(layer.getEntitiesByField(fieldIdentifier, value));
            }
        }
        return results;
    }
    /**
     * Get the level bounds given a list of level identifiers (case insensitive)
     * @param levels
     */
    getLevelBounds(levels) {
        levels = levels !== null && levels !== void 0 ? levels : Array.from(this.levelsByName.keys());
        let bounds = null;
        for (const level of this.levels.values()) {
            if (!levels.includes(level.ldtkLevel.identifier)) {
                continue;
            }
            const firstTileLayer = this.getTileLayers(level.ldtkLevel.identifier)[0];
            if (firstTileLayer) {
                const tileBounds = excalibur__WEBPACK_IMPORTED_MODULE_10__.BoundingBox.fromDimension(firstTileLayer.tilemap.tileWidth * firstTileLayer.tilemap.columns, firstTileLayer.tilemap.tileHeight * firstTileLayer.tilemap.rows, excalibur__WEBPACK_IMPORTED_MODULE_10__.Vector.Zero, firstTileLayer.tilemap.pos);
                if (!bounds) {
                    bounds = tileBounds;
                }
                else {
                    bounds = bounds.combine(tileBounds);
                }
            }
        }
        return bounds !== null && bounds !== void 0 ? bounds : new excalibur__WEBPACK_IMPORTED_MODULE_10__.BoundingBox();
    }
    addToScene(scene, options) {
        var _a, _b;
        const { pos, useLevelOffsets } = { pos: (0,excalibur__WEBPACK_IMPORTED_MODULE_10__.vec)(0, 0), useLevelOffsets: true, ...options };
        for (let [id, level] of this.levels.entries()) {
            if ((_a = options === null || options === void 0 ? void 0 : options.levelFilter) === null || _a === void 0 ? void 0 : _a.length) {
                if (!options.levelFilter.includes(level.ldtkLevel.identifier)) {
                    continue;
                }
            }
            for (let layer of level.layers) {
                if (layer instanceof _tile_layer__WEBPACK_IMPORTED_MODULE_0__.TileLayer || layer instanceof _intgrid_layer__WEBPACK_IMPORTED_MODULE_9__.IntGridLayer) {
                    layer.tilemap.pos = layer.tilemap.pos.add(pos);
                    if (!useLevelOffsets) {
                        layer.tilemap.pos = layer.tilemap.pos.sub(layer.worldPos);
                    }
                    scene.add(layer.tilemap);
                }
                else {
                    layer.runFactories();
                    for (let entity of layer.entities) {
                        const tx = entity.get(excalibur__WEBPACK_IMPORTED_MODULE_10__.TransformComponent);
                        if (tx) {
                            tx.pos = tx.pos.add(pos);
                            if (!useLevelOffsets) {
                                tx.pos = tx.pos.sub(layer.worldPos);
                            }
                        }
                        scene.add(entity);
                    }
                }
            }
        }
        if (this.useExcaliburWiring) {
            const camera = this.getLdtkEntitiesByField('camera', true)[0];
            if (camera) {
                scene.camera.pos = (0,excalibur__WEBPACK_IMPORTED_MODULE_10__.vec)(camera.px[0], camera.px[0]);
                const zoom = camera.fieldInstances.find(f => f.__identifier.toLocaleLowerCase() === 'zoom');
                if (zoom) {
                    scene.camera.zoom = +zoom.__value;
                }
            }
        }
        if (this.useTilemapCameraStrategy) {
            let bounds = this.getLevelBounds(options === null || options === void 0 ? void 0 : options.levelFilter);
            scene.camera.strategy.limitCameraBounds(bounds);
        }
        if (this.useMapBackgroundColor) {
            for (let [id, level] of this.levels.entries()) {
                if ((_b = options === null || options === void 0 ? void 0 : options.levelFilter) === null || _b === void 0 ? void 0 : _b.length) {
                    if (!options.levelFilter.includes(level.ldtkLevel.identifier)) {
                        continue;
                    }
                }
                scene.backgroundColor = level.backgroundColor;
                break;
            }
        }
    }
}
LdtkResource.supportedLdtkVersion = "1.5.3";


/***/ }),

/***/ "./src/level-resource.ts":
/*!*******************************!*\
  !*** ./src/level-resource.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LevelResource: () => (/* binding */ LevelResource)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _loader_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-cache */ "./src/loader-cache.ts");
/* harmony import */ var _file_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file-loader */ "./src/file-loader.ts");
/* harmony import */ var _level__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./level */ "./src/level.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./src/types.ts");





/**
 * Loads LDtk levels that are stored in separate files
 */
class LevelResource {
    constructor(path, resource, options) {
        this.path = path;
        this.resource = resource;
        this.fileLoader = _file_loader__WEBPACK_IMPORTED_MODULE_1__.FetchLoader;
        this.strict = true;
        this.headless = false;
        const { headless, strict, fileLoader, imageLoader, pathMap } = { ...options };
        this.fileLoader = fileLoader !== null && fileLoader !== void 0 ? fileLoader : this.fileLoader;
        this.strict = strict !== null && strict !== void 0 ? strict : this.strict;
        this.headless = headless !== null && headless !== void 0 ? headless : this.headless;
        this.imageLoader = imageLoader !== null && imageLoader !== void 0 ? imageLoader : new _loader_cache__WEBPACK_IMPORTED_MODULE_0__.LoaderCache(excalibur__WEBPACK_IMPORTED_MODULE_4__.ImageSource);
        this.pathMap = pathMap !== null && pathMap !== void 0 ? pathMap : this.pathMap;
    }
    async load() {
        const data = await this.fileLoader(this.path, 'json');
        let level;
        if (this.strict) {
            try {
                level = _types__WEBPACK_IMPORTED_MODULE_3__.LdtkLevel.parse(data);
            }
            catch (e) {
                console.error(`Could not parse LDtk level data at ${this.path} are you sure a level is there and not corrupt?`);
                throw e;
            }
        }
        else {
            level = data;
        }
        return this.data = new _level__WEBPACK_IMPORTED_MODULE_2__.Level(level, this.resource);
    }
    isLoaded() {
        return !!this.data;
    }
}


/***/ }),

/***/ "./src/level.ts":
/*!**********************!*\
  !*** ./src/level.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Level: () => (/* binding */ Level)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _entity_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity-layer */ "./src/entity-layer.ts");
/* harmony import */ var _intgrid_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./intgrid-layer */ "./src/intgrid-layer.ts");
/* harmony import */ var _tile_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-layer */ "./src/tile-layer.ts");




class Level {
    constructor(ldtkLevel, resource) {
        var _a, _b, _c, _d;
        this.ldtkLevel = ldtkLevel;
        this.resource = resource;
        this.layers = [];
        if (ldtkLevel.__bgColor) {
            this.backgroundColor = excalibur__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex(ldtkLevel.__bgColor);
        }
        if (ldtkLevel.layerInstances) {
            let order = resource.startZIndex;
            let layers = ldtkLevel.layerInstances.slice().reverse();
            for (let layer of layers) {
                if (((_a = layer.entityInstances) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
                    this.layers.push(new _entity_layer__WEBPACK_IMPORTED_MODULE_0__.EntityLayer(this, layer, resource, order));
                }
                if (((_b = layer.gridTiles) === null || _b === void 0 ? void 0 : _b.length) !== 0) {
                    this.layers.push(new _tile_layer__WEBPACK_IMPORTED_MODULE_2__.TileLayer(this, layer, resource, order));
                }
                // Includes standard IntGrid, IntGrid w/ AutoTile & AutoTile layers
                if (((_c = layer.intGridCsv) === null || _c === void 0 ? void 0 : _c.length) !== 0 || ((_d = layer.autoLayerTiles) === null || _d === void 0 ? void 0 : _d.length) !== 0) {
                    this.layers.push(new _intgrid_layer__WEBPACK_IMPORTED_MODULE_1__.IntGridLayer(this, layer, resource, order));
                }
                order++;
            }
        }
    }
}


/***/ }),

/***/ "./src/loader-cache.ts":
/*!*****************************!*\
  !*** ./src/loader-cache.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoaderCache: () => (/* binding */ LoaderCache)
/* harmony export */ });
/**
 * Read through cache for loadables
 */
class LoaderCache {
    constructor(type) {
        this.type = type;
        this._loaded = false;
        this.cache = new Map();
    }
    getOrAdd(...args) {
        let resource = this.cache.get(args.join('+'));
        if (resource) {
            return resource;
        }
        resource = new this.type(...args);
        this.cache.set(args.join('+'), resource);
        return resource;
    }
    values() {
        if (this._loaded) {
            return Array.from(this.cache.values());
        }
        throw new Error(`Read through cache not yet loaded! No values to return!`);
    }
    async load() {
        const resources = Array.from(this.cache.entries());
        const results = await Promise.allSettled(resources.map(i => i[1].load()));
        // Check for errors loading resources
        let errored = 0;
        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            if (result.status === 'rejected') {
                console.error(`Error loading resource at ${resources[i][0]}, is your pathMap correct? or your LDtk map corrupted?`, result.reason);
                errored++;
            }
        }
        if (errored) {
            throw new Error(`Error loading ${errored} resources`);
        }
        this._loaded = true;
    }
}


/***/ }),

/***/ "./src/path-util.ts":
/*!**************************!*\
  !*** ./src/path-util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filenameFromPath: () => (/* binding */ filenameFromPath),
/* harmony export */   mapPath: () => (/* binding */ mapPath),
/* harmony export */   pathInMap: () => (/* binding */ pathInMap),
/* harmony export */   pathRelativeToBase: () => (/* binding */ pathRelativeToBase)
/* harmony export */ });
function filenameFromPath(inputPath) {
    const filenameExpression = /[^/\\&\?]+\.\w{2,4}(?=([\#\?&].*$|$))/ig;
    const matches = inputPath.match(filenameExpression);
    if (matches) {
        const match = matches[0];
        return match;
    }
    throw new Error(`Could not locate filename from path: ${inputPath}`);
}
function mapPath(inputPath, pathMap) {
    for (const { path, output } of pathMap) {
        if (typeof path === 'string') {
            if (inputPath.includes(path)) {
                return output;
            }
        }
        else {
            const match = inputPath.match(path);
            if (match) {
                return output.replace('[match]', match[0]);
                ;
            }
        }
    }
    return inputPath;
}
function pathInMap(inputPath, pathMap) {
    if (!pathMap)
        return false;
    for (const { path, output } of pathMap) {
        if (typeof path === 'string') {
            if (inputPath.includes(path)) {
                return true;
            }
        }
        else {
            const match = inputPath.match(path);
            if (match) {
                return true;
            }
        }
    }
    return false;
}
function pathRelativeToBase(basePath, relativeToBase, pathMap) {
    if (pathInMap(relativeToBase, pathMap) && pathMap) {
        return mapPath(relativeToBase, pathMap);
    }
    // Use absolute path if specified
    if (relativeToBase.indexOf('/') === 0) {
        return relativeToBase;
    }
    const originSplit = basePath.split('/');
    const relativeSplit = relativeToBase.split('/');
    // if origin path is a file, remove it so it's a directory
    if (originSplit[originSplit.length - 1].includes('.')) {
        originSplit.pop();
    }
    return originSplit.concat(relativeSplit).join('/');
}


/***/ }),

/***/ "./src/tile-layer.ts":
/*!***************************!*\
  !*** ./src/tile-layer.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileLayer: () => (/* binding */ TileLayer)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");

class TileLayer {
    constructor(level, ldtkLayer, resource, order) {
        var _a, _b, _c, _d;
        this.order = order;
        this.worldPos = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(level.ldtkLevel.worldX, level.ldtkLevel.worldY);
        this.offset = (0,excalibur__WEBPACK_IMPORTED_MODULE_0__.vec)(ldtkLayer.__pxTotalOffsetX, ldtkLayer.__pxTotalOffsetY);
        this.ldtkLayer = ldtkLayer;
        this.tilemap = new excalibur__WEBPACK_IMPORTED_MODULE_0__.TileMap({
            name: ldtkLayer.__identifier,
            pos: this.worldPos.add(this.offset),
            tileWidth: ldtkLayer.__gridSize,
            tileHeight: ldtkLayer.__gridSize,
            rows: ldtkLayer.__cHei,
            columns: ldtkLayer.__cWid,
        });
        this.tilemap.z = order;
        const graphics = this.tilemap.get(excalibur__WEBPACK_IMPORTED_MODULE_0__.GraphicsComponent);
        graphics.isVisible = ldtkLayer.visible;
        if (ldtkLayer.__tilesetDefUid) {
            this.tileset = resource.tilesets.get(ldtkLayer.__tilesetDefUid);
            for (let tile of ldtkLayer.gridTiles) {
                const xCoord = Math.floor(tile.px[0] / ldtkLayer.__gridSize);
                const yCoord = Math.floor(tile.px[1] / ldtkLayer.__gridSize);
                const exTile = this.tilemap.getTile(xCoord, yCoord);
                if (this.tileset) {
                    const tsxCoord = Math.floor((tile.src[0] - ((_a = this.tileset.ldtkTileset.padding) !== null && _a !== void 0 ? _a : 0)) / (this.tileset.ldtkTileset.tileGridSize + ((_b = this.tileset.ldtkTileset.spacing) !== null && _b !== void 0 ? _b : 0)));
                    const tsyCoord = Math.floor((tile.src[1] - ((_c = this.tileset.ldtkTileset.padding) !== null && _c !== void 0 ? _c : 0)) / (this.tileset.ldtkTileset.tileGridSize + ((_d = this.tileset.ldtkTileset.spacing) !== null && _d !== void 0 ? _d : 0)));
                    // Bit 0 toggles x flip
                    // Bit 1 toggles 1 flip
                    // Examples: f=0 (no flip), f=1 (X flip only), f=2 (Y flip only), f=3 (both flips)
                    const flipHorizontal = !!(tile.f & 0b01);
                    const flipVertical = !!(tile.f & 0b10);
                    let sprite = this.tileset.spritesheet.getSprite(tsxCoord, tsyCoord);
                    if (flipHorizontal || flipVertical) {
                        sprite = sprite.clone();
                        sprite.flipHorizontal = flipHorizontal;
                        sprite.flipVertical = flipVertical;
                    }
                    if (sprite) {
                        exTile.addGraphic(sprite);
                    }
                    else {
                        console.error('Could not find sprite in LDtk spritesheet at', tsxCoord, tsyCoord);
                    }
                }
            }
        }
        else {
            console.error('Could not tileset in LDtk', ldtkLayer.__tilesetDefUid, ldtkLayer.__tilesetRelPath);
        }
    }
}


/***/ }),

/***/ "./src/tileset.ts":
/*!************************!*\
  !*** ./src/tileset.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tileset: () => (/* binding */ Tileset)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");

class Tileset {
    constructor(options) {
        var _a, _b, _c, _d;
        const { image, ldtkTileset } = options;
        this.image = image;
        this.ldtkTileset = ldtkTileset;
        this.spritesheet = excalibur__WEBPACK_IMPORTED_MODULE_0__.SpriteSheet.fromImageSource({
            image,
            grid: {
                rows: ldtkTileset.pxHei / ldtkTileset.tileGridSize,
                columns: ldtkTileset.pxWid / ldtkTileset.tileGridSize,
                spriteHeight: ldtkTileset.tileGridSize,
                spriteWidth: ldtkTileset.tileGridSize
            },
            spacing: {
                margin: {
                    x: (_a = ldtkTileset.spacing) !== null && _a !== void 0 ? _a : 0,
                    y: (_b = ldtkTileset.spacing) !== null && _b !== void 0 ? _b : 0,
                },
                originOffset: {
                    x: (_c = ldtkTileset.padding) !== null && _c !== void 0 ? _c : 0,
                    y: (_d = ldtkTileset.padding) !== null && _d !== void 0 ? _d : 0
                }
            }
        });
    }
}


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LdtkEntityDefinition: () => (/* binding */ LdtkEntityDefinition),
/* harmony export */   LdtkEntityInstance: () => (/* binding */ LdtkEntityInstance),
/* harmony export */   LdtkLayerDefinition: () => (/* binding */ LdtkLayerDefinition),
/* harmony export */   LdtkLayerInstance: () => (/* binding */ LdtkLayerInstance),
/* harmony export */   LdtkLevel: () => (/* binding */ LdtkLevel),
/* harmony export */   LdtkProjectMetadata: () => (/* binding */ LdtkProjectMetadata)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");

const LdtkTilesetRectangle = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    h: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    tilesetUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    w: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    x: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    y: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkPixel = zod__WEBPACK_IMPORTED_MODULE_0__.z.tuple([zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), zod__WEBPACK_IMPORTED_MODULE_0__.z.number()]);
const LdtkFieldInstance = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    __tile: LdtkTilesetRectangle.nullable(),
    __type: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), //z.union([z.literal('Int'), z.literal('Float'), z.literal('String'), z.literal('Bool'), z.literal('Enum')]), // TODO this might not work with ENUM
    __value: zod__WEBPACK_IMPORTED_MODULE_0__.z.any(),
    defUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkTileInstance = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    a: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    f: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), // 2-bit int 0bXY flip
    px: LdtkPixel,
    src: LdtkPixel,
    t: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkEntityInstance = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __grid: LdtkPixel,
    __identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    __pivot: LdtkPixel,
    __smartColor: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    __tags: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),
    __tile: LdtkTilesetRectangle.nullable(),
    __worldX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    __worldY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    defUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    fieldInstances: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkFieldInstance),
    height: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    iid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    px: LdtkPixel,
    width: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkLayerInstance = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __cHei: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __cWid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __gridSize: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    __opacity: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __pxTotalOffsetX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __pxTotalOffsetY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __tilesetDefUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    __tilesetRelPath: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    __type: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('IntGrid'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('Entities'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('Tiles'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('AutoLayer')]),
    autoLayerTiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkTileInstance), // only in auto layers
    entityInstances: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkEntityInstance), // only in entity layers
    gridTiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkTileInstance),
    iid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    intGridCsv: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.number()), // __cWid x __cHei, 0 means empty, values start at 1
    layerDefUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    levelId: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    overrideTilesetUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    pxOffsetX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pxOffsetY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    visible: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean()
});
const LdtkLevel = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __bgColor: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    bgColor: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    __bgPos: zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        cropRect: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.tuple([zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), zod__WEBPACK_IMPORTED_MODULE_0__.z.number()])), // cropX, cropY, cropWidth, cropHeight
        scale: zod__WEBPACK_IMPORTED_MODULE_0__.z.tuple([zod__WEBPACK_IMPORTED_MODULE_0__.z.number(), zod__WEBPACK_IMPORTED_MODULE_0__.z.number()]),
        topLeftPx: LdtkPixel
    }).nullable(),
    __neighbours: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        dir: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('n'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('s'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('w'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('e'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('ne'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('nw'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('se'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('sw'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('o'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('<'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('>')]),
        levelIid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
    })),
    bgRelPath: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    externalRelPath: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    fieldInstances: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkFieldInstance),
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    iid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    layerInstances: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkLayerInstance).nullable(), // null if the save levels separately is enabled
    pxHei: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pxWid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    worldDepth: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    worldX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    worldY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkWorld = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    iid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    levels: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkLevel),
    worldGridHeight: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    worldGridWidth: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    // TODO is this a typo Vania?
    worldLayout: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('Free'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('GridVania'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('LinearHorizontal'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('LinearVertical')]),
});
const LdtkEnumValueDefinition = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    color: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    tileRect: LdtkTilesetRectangle.nullable()
});
const LdtkEnumDefinition = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    externalRelPath: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    iconTilesetUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    tags: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),
    uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    values: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkEnumValueDefinition)
});
const LdtkTilesetDefinition = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __cHei: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    __cWid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    customData: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        data: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        tileId: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
    })),
    embedAtlas: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    enumTags: zod__WEBPACK_IMPORTED_MODULE_0__.z.optional(zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        enumValueId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        tileIds: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.number())
    }))),
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    padding: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pxHei: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pxWid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    relPath: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    spacing: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    tags: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),
    tagsSourceEnumUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    tileGridSize: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkLayerDefinition = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    __type: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("IntGrid"), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Entities"), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Tiles"), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("AutoLayer")]),
    autoSourceLayerDefUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    displayOpacity: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    gridSize: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    intGridValues: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        color: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        groupUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
        identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
        tile: LdtkTilesetRectangle.nullable(),
        value: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
    })),
    intGridValuesGroups: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        color: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
        identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
        uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
    })),
    parallaxFactorX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    parallaxFactorY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    parallaxScaling: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean(),
    pxOffsetX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pxOffsetY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    tilesetDefUid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
});
const LdtkEntityDefinition = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    color: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    height: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    nineSliceBorders: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.number()),
    pivotX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    pivotY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    tileRect: LdtkTilesetRectangle.nullable(),
    tileRenderMode: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Cover"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("FitInside"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Repeat"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Stretch"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("FullSizeCropped"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("FullSizeUncropped"),
        zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("NineSlice")
    ]),
    tilesetId: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    uiTileRect: LdtkTilesetRectangle.nullable(),
    uid: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    width: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
});
const LdtkDefinitions = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    tilesets: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkTilesetDefinition),
    enums: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkEnumDefinition),
    layers: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkLayerDefinition),
    entities: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkEntityDefinition)
});
const LdtkProjectMetadata = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    iid: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    bgColor: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    defs: LdtkDefinitions,
    externalLevels: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean(),
    jsonVersion: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    levels: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkLevel),
    toc: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        identifier: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        instancesData: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
            fields: zod__WEBPACK_IMPORTED_MODULE_0__.z.any(),
            heiPx: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
            iids: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
            widPix: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
            worldX: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
            worldY: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()
        }))
    })),
    // Moving to worlds array
    worldGridHeight: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    worldGridWidth: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),
    // TODO is this a LDtk docs typo Vania?
    worldLayout: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('Free'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('GridVania'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('LinearHorizontal'), zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('LinearVertical')]).nullable(),
    worlds: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LdtkWorld)
});


/***/ }),

/***/ "./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BRAND: () => (/* binding */ BRAND),
/* harmony export */   DIRTY: () => (/* binding */ DIRTY),
/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),
/* harmony export */   INVALID: () => (/* binding */ INVALID),
/* harmony export */   NEVER: () => (/* binding */ NEVER),
/* harmony export */   OK: () => (/* binding */ OK),
/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),
/* harmony export */   Schema: () => (/* binding */ ZodType),
/* harmony export */   ZodAny: () => (/* binding */ ZodAny),
/* harmony export */   ZodArray: () => (/* binding */ ZodArray),
/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),
/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),
/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),
/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),
/* harmony export */   ZodDate: () => (/* binding */ ZodDate),
/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),
/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),
/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),
/* harmony export */   ZodError: () => (/* binding */ ZodError),
/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),
/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),
/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),
/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),
/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),
/* harmony export */   ZodMap: () => (/* binding */ ZodMap),
/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),
/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),
/* harmony export */   ZodNever: () => (/* binding */ ZodNever),
/* harmony export */   ZodNull: () => (/* binding */ ZodNull),
/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),
/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),
/* harmony export */   ZodObject: () => (/* binding */ ZodObject),
/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),
/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),
/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),
/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),
/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),
/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),
/* harmony export */   ZodSchema: () => (/* binding */ ZodType),
/* harmony export */   ZodSet: () => (/* binding */ ZodSet),
/* harmony export */   ZodString: () => (/* binding */ ZodString),
/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),
/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),
/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),
/* harmony export */   ZodType: () => (/* binding */ ZodType),
/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),
/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),
/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),
/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),
/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),
/* harmony export */   any: () => (/* binding */ anyType),
/* harmony export */   array: () => (/* binding */ arrayType),
/* harmony export */   bigint: () => (/* binding */ bigIntType),
/* harmony export */   boolean: () => (/* binding */ booleanType),
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   custom: () => (/* binding */ custom),
/* harmony export */   date: () => (/* binding */ dateType),
/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),
/* harmony export */   "default": () => (/* binding */ z),
/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),
/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),
/* harmony export */   effect: () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),
/* harmony export */   getParsedType: () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   intersection: () => (/* binding */ intersectionType),
/* harmony export */   isAborted: () => (/* binding */ isAborted),
/* harmony export */   isAsync: () => (/* binding */ isAsync),
/* harmony export */   isDirty: () => (/* binding */ isDirty),
/* harmony export */   isValid: () => (/* binding */ isValid),
/* harmony export */   late: () => (/* binding */ late),
/* harmony export */   lazy: () => (/* binding */ lazyType),
/* harmony export */   literal: () => (/* binding */ literalType),
/* harmony export */   makeIssue: () => (/* binding */ makeIssue),
/* harmony export */   map: () => (/* binding */ mapType),
/* harmony export */   nan: () => (/* binding */ nanType),
/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),
/* harmony export */   never: () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   nullable: () => (/* binding */ nullableType),
/* harmony export */   number: () => (/* binding */ numberType),
/* harmony export */   object: () => (/* binding */ objectType),
/* harmony export */   objectUtil: () => (/* binding */ objectUtil),
/* harmony export */   oboolean: () => (/* binding */ oboolean),
/* harmony export */   onumber: () => (/* binding */ onumber),
/* harmony export */   optional: () => (/* binding */ optionalType),
/* harmony export */   ostring: () => (/* binding */ ostring),
/* harmony export */   pipeline: () => (/* binding */ pipelineType),
/* harmony export */   preprocess: () => (/* binding */ preprocessType),
/* harmony export */   promise: () => (/* binding */ promiseType),
/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),
/* harmony export */   record: () => (/* binding */ recordType),
/* harmony export */   set: () => (/* binding */ setType),
/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),
/* harmony export */   strictObject: () => (/* binding */ strictObjectType),
/* harmony export */   string: () => (/* binding */ stringType),
/* harmony export */   symbol: () => (/* binding */ symbolType),
/* harmony export */   transformer: () => (/* binding */ effectsType),
/* harmony export */   tuple: () => (/* binding */ tupleType),
/* harmony export */   undefined: () => (/* binding */ undefinedType),
/* harmony export */   union: () => (/* binding */ unionType),
/* harmony export */   unknown: () => (/* binding */ unknownType),
/* harmony export */   util: () => (/* binding */ util),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   z: () => (/* binding */ z)
/* harmony export */ });
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap, // contextual error map is first priority
            ctx.schemaErrorMap, // then schema-bound map if available
            overrideMap, // then global override map
            overrideMap === errorMap ? undefined : errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if (!decoded.typ || !decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result)
            ? result.then((data) => freeze(data))
            : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
function custom(check, params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return util; },
    get objectUtil () { return objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    datetimeRegex: datetimeRegex,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!************************!*\
  !*** ./sample/main.ts ***!
  \************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.development.js");
/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ "./sample/player.ts");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources */ "./sample/resources.ts");



excalibur__WEBPACK_IMPORTED_MODULE_2__.Flags.useLegacyImageRenderer();
const game = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Engine({
    resolution: {
        width: 256,
        height: 256,
    },
    suppressPlayButton: false,
    pixelArt: true,
    pixelRatio: 4,
    displayMode: excalibur__WEBPACK_IMPORTED_MODULE_2__.DisplayMode.FitScreen,
});
game.start(_resources__WEBPACK_IMPORTED_MODULE_1__.loader).then(() => {
    console.log('Game start!');
    _resources__WEBPACK_IMPORTED_MODULE_1__.Resources.LdtkResource.registerEntityIdentifierFactory('PlayerStart', (props) => {
        const player = new _player__WEBPACK_IMPORTED_MODULE_0__.Player({
            name: 'player',
            anchor: excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(props.entity.__pivot[0], props.entity.__pivot[1]),
            width: props.entity.width,
            height: props.entity.height,
            pos: props.worldPos,
            z: props.layer.order
        });
        return player;
    });
    // Provide a type to the plugin to use for a specific entity identifier
    // Player.ts
    _resources__WEBPACK_IMPORTED_MODULE_1__.Resources.LdtkResource.addToScene(game.currentScene, {
        pos: excalibur__WEBPACK_IMPORTED_MODULE_2__.vec(0, 0),
        levelFilter: ['Level_0', 'Level_1']
    });
    const player = game.currentScene.world.entityManager.getByName('player')[0];
    if (player instanceof _player__WEBPACK_IMPORTED_MODULE_0__.Player) {
        game.currentScene.camera.clearAllStrategies();
        game.currentScene.camera.strategy.lockToActor(player);
        const bounds = _resources__WEBPACK_IMPORTED_MODULE_1__.Resources.LdtkResource.getLevelBounds(['Level_0', 'Level_1']);
        game.currentScene.camera.strategy.limitCameraBounds(bounds);
    }
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=sample.js.map